<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Complete Think</title>
  
  <subtitle>Thinking, Coding, and Learning.</subtitle>
  <link href="https://rickhw.github.io/atom.xml" rel="self"/>
  
  <link href="https://rickhw.github.io/"/>
  <updated>2023-07-01T23:37:15.674Z</updated>
  <id>https://rickhw.github.io/</id>
  
  <author>
    <name>Rick Hwang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置頂 - 全站索引</title>
    <link href="https://rickhw.github.io/2035/01/21/Index/"/>
    <id>https://rickhw.github.io/2035/01/21/Index/</id>
    <published>2035-01-21T02:30:00.000Z</published>
    <updated>2023-07-01T23:37:15.674Z</updated>
    
    <content type="html"><![CDATA[<p>這篇是整個 Blog 的全站索引，如果您是第一次來這裡，可以先看看這篇索引，大概知道 Blog 的全貌：</p><ul><li>[理念] <a href="/2017/11/26/Thinking-in-Essence/">思考本質、實踐、抽象、想像力、教育</a></li><li>[目錄] <a href="/2017/07/01/Index-Management/">經營管理</a>: 整理管理經驗談、管理哲學、經營、領導、用人之道、學習方法、專案管理</li><li>[目錄] <a href="/2017/07/01/Index-Software-Engineering-In-Practice/">軟體工程實踐</a>: 包含軟體架構、開發、測試、維運等 … 實踐的心得。</li><li>[目錄] <a href="/categories/Distributed-Systems">分散式系統</a>，包含分散式系統理論、Cloud Native - <a href="/tags/Kubernetes/">Kubernetes</a>、<a href="/2016/10/01/AWS-Study-Roadmap/">AWS</a>。</li><li>[參考] <a href="/2017/07/01/Reference/Books/">參考書</a>、<a href="/2017/07/01/Reference/Tech-Terms/">資訊技術與工程專有名詞</a>、<a href="/2017/07/01/Reference/SC-Terms/">計算機科學專有名詞</a>、<a href="/2017/07/01/Reference/Mgmt-Terms/">經營管理專有名詞</a></li><li>[系列文] <a href="/tags/Bus-Memo/">公車隨筆</a>、<a href="/tags/Learning-Approaches/">寫作與閱讀系列文</a>、<a href="/tags/%E6%BA%9D%E9%80%9A/">溝通</a>、<a href="/tags/Meetings/">會議效率</a></li><li>[關於] <a href="/2017/12/29/About/About-This-Blog/">這個部落格</a>、<a href="/2017/12/29/About/About-Author/">關於作者</a>、<a href="/2017/09/20/About/Learning-Approaches/">學習法則</a>、<a href="/2014/12/27/Management/%E7%B6%93%E7%87%9F%E4%B9%8B%E9%81%93/">經營之道</a>、<a href="/2017/12/02/About/Epiphany/">一些領悟</a>、<a href="/2014/10/26/Management/Classified-Philosophy/">分類哲學</a></li><li>[站內記事]: <a href="/2035/01/21/Updated/">文章更新紀錄</a>, <a href="/2013/11/26/Stats/">點閱率統計</a></li></ul><blockquote><p>不管是程式、文章、資料、還是房間，我都會定期重新整理 &#x2F; 重構，核心概念來自於 <a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></p></blockquote><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇是整個 Blog 的全站索引，如果您是第一次來這裡，可以先看看這篇索引，大概知道 Blog 的全貌：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[理念] &lt;a href=&quot;/2017/11/26/Thinking-in-Essence/&quot;&gt;思考本質、實踐、抽象、想像力、教育&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/2017/07/01/Index-Management/&quot;&gt;經營管理&lt;/a&gt;: 整理管理經驗談、管理哲學、經營、領導、用人之道、學習方法、專案管理&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/2017/07/01/Index-Software-Engineering-In-Practice/&quot;&gt;軟體工程實踐&lt;/a&gt;: 包含軟體架構、開發、測試、維運等 … 實踐的心得。&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/categories/Distributed-Systems&quot;&gt;分散式系統&lt;/a&gt;，包含分散式系統理論、Cloud Native - &lt;a href=&quot;/tags/Kubernetes/&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a href=&quot;/2016/10/01/AWS-Study-Roadmap/&quot;&gt;AWS&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;[參考] &lt;a href=&quot;/2017/07/01/Reference/Books/&quot;&gt;參考書&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/Tech-Terms/&quot;&gt;資訊技術與工程專有名詞&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/SC-Terms/&quot;&gt;計算機科學專有名詞&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/Mgmt-Terms/&quot;&gt;經營管理專有名詞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[系列文] &lt;a href=&quot;/tags/Bus-Memo/&quot;&gt;公車隨筆&lt;/a&gt;、&lt;a href=&quot;/tags/Learning-Approaches/&quot;&gt;寫作與閱讀系列文&lt;/a&gt;、&lt;a href=&quot;/tags/%E6%BA%9D%E9%80%9A/&quot;&gt;溝通&lt;/a&gt;、&lt;a href=&quot;/tags/Meetings/&quot;&gt;會議效率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[關於] &lt;a href=&quot;/2017/12/29/About/About-This-Blog/&quot;&gt;這個部落格&lt;/a&gt;、&lt;a href=&quot;/2017/12/29/About/About-Author/&quot;&gt;關於作者&lt;/a&gt;、&lt;a href=&quot;/2017/09/20/About/Learning-Approaches/&quot;&gt;學習法則&lt;/a&gt;、&lt;a href=&quot;/2014/12/27/Management/%E7%B6%93%E7%87%9F%E4%B9%8B%E9%81%93/&quot;&gt;經營之道&lt;/a&gt;、&lt;a href=&quot;/2017/12/02/About/Epiphany/&quot;&gt;一些領悟&lt;/a&gt;、&lt;a href=&quot;/2014/10/26/Management/Classified-Philosophy/&quot;&gt;分類哲學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[站內記事]: &lt;a href=&quot;/2035/01/21/Updated/&quot;&gt;文章更新紀錄&lt;/a&gt;, &lt;a href=&quot;/2013/11/26/Stats/&quot;&gt;點閱率統計&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不管是程式、文章、資料、還是房間，我都會定期重新整理 &amp;#x2F; 重構，核心概念來自於 &lt;a href=&quot;/2014/10/26/Management/Classified-Philosophy/&quot;&gt;分類的哲學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>置頂 - 更新文章</title>
    <link href="https://rickhw.github.io/2035/01/21/Updated/"/>
    <id>https://rickhw.github.io/2035/01/21/Updated/</id>
    <published>2035-01-21T02:30:00.000Z</published>
    <updated>2023-07-01T23:37:15.675Z</updated>
    
    <content type="html"><![CDATA[<p>底下整理 Blog 更新的文章記錄，提供給想知道哪些文章有更動的朋友。</p><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">更新說明</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2023&#x2F;07&#x2F;01</td><td align="left">新增內容</td><td align="left"><a href="/2020/06/21/Management/Interview-Problems/">面試常見的問題</a></td><td align="left">新增錄影</td><td align="left">2020&#x2F;06&#x2F;21</td></tr><tr><td>2021&#x2F;08&#x2F;21</td><td align="left">更新參照</td><td align="left"><a href="/2015/08/22/Management/Senior-Software-Developer/">資深軟體工程師</a></td><td align="left">新增參考資料</td><td align="left">2015&#x2F;08&#x2F;22</td></tr><tr><td>2021&#x2F;04&#x2F;30</td><td align="left">新增資料</td><td align="left"><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></td><td align="left">新增軟體測試管理工具的選擇</td><td align="left">2019&#x2F;10&#x2F;30</td></tr></tbody></table><span id="more"></span><h2 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2021&#x2F;08&#x2F;21</td><td align="left">更新參照</td><td align="left"><a href="/2015/08/22/Management/Senior-Software-Developer/">資深軟體工程師</a></td><td align="left">2015&#x2F;08&#x2F;22</td></tr><tr><td>2021&#x2F;04&#x2F;30</td><td align="left">新增資料</td><td align="left"><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></td><td align="left">2019&#x2F;10&#x2F;30</td></tr><tr><td>2021&#x2F;04&#x2F;20</td><td align="left">新增資料</td><td align="left"><a href="/2019/03/17/Management/Perspective-in-XYZT/">看見怎樣的全貌 - 軟體開發的三體問題</a></td><td align="left">2019&#x2F;03&#x2F;17</td></tr><tr><td>2021&#x2F;03&#x2F;27</td><td align="left">新增資料</td><td align="left"><a href="/2020/03/07/ComputerScience/Cryptography/">摘要密碼學與資訊安全</a></td><td align="left">2020&#x2F;03&#x2F;07</td></tr></tbody></table><h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2020&#x2F;09&#x2F;13</td><td align="left">新增資料</td><td align="left"><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a></td><td align="left">2018&#x2F;06&#x2F;18</td></tr><tr><td>2020&#x2F;09&#x2F;13</td><td align="left">增加段落</td><td align="left"><a href="https://rickhw.github.io/2018/08/11/DistributedSystems/CAP-Theorem/">CAP Theorem</a></td><td align="left">2018&#x2F;08&#x2F;11</td></tr><tr><td>2020&#x2F;08&#x2F;09</td><td align="left">調整結構</td><td align="left"><a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></td><td align="left">2019&#x2F;03&#x2F;17</td></tr><tr><td>2020&#x2F;07&#x2F;25</td><td align="left">增加段落</td><td align="left"><a href="/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">一致性問題與共識演算法</a></td><td align="left">2018&#x2F;08&#x2F;11</td></tr><tr><td>2020&#x2F;06&#x2F;07</td><td align="left">增加段落</td><td align="left"><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></td><td align="left">2017&#x2F;09&#x2F;20</td></tr><tr><td>2020&#x2F;05&#x2F;26</td><td align="left">重構文章</td><td align="left"><a href="/2015/08/22/Management/Senior-Software-Developer/">資深軟體工程師</a></td><td align="left">2015&#x2F;08&#x2F;22</td></tr><tr><td>2020&#x2F;05&#x2F;09</td><td align="left">文句修飾</td><td align="left"><a href="/2019/06/05/DevOps/Github-Incident-Analysis/">GitHub Post-Incident Analysis</a></td><td align="left">2019&#x2F;06&#x2F;05</td></tr><tr><td>2020&#x2F;03&#x2F;22</td><td align="left">重構文章</td><td align="left"><a href="/2019/04/04/AWS/Study-Notes-EC2-Auto-Scaling-FAQ/">Study Notes - EC2 Auto Scaling 常見問題</a></td><td align="left">2019&#x2F;04&#x2F;04</td></tr><tr><td>2020&#x2F;03&#x2F;10</td><td align="left">增加段落</td><td align="left"><a href="/2018/06/08/Management/Naming-for-Products/">你的靈魂 - 談產品名稱的命名</a></td><td align="left">2018&#x2F;06&#x2F;08</td></tr><tr><td>2020&#x2F;03&#x2F;04</td><td align="left">增加段落</td><td align="left"><a href="/2018/10/08/DevOps/Chaos-Engineering/">Chaos Engineering (混沌工程)</a></td><td align="left">2018&#x2F;10&#x2F;08</td></tr><tr><td>2020&#x2F;02&#x2F;29</td><td align="left">增加段落</td><td align="left"><a href="/2020/02/08/Container/Why-Container/">Why Container</a></td><td align="left">2020&#x2F;02&#x2F;08</td></tr><tr><td>2020&#x2F;02&#x2F;08</td><td align="left">增加段落</td><td align="left"><a href="/2016/11/27/AWS/Whitepaper-AWS-Well-Architect-Framework/">Whitepaper - AWS Well-Architected Framework</a></td><td align="left">2016&#x2F;11&#x2F;27</td></tr><tr><td>2020&#x2F;01&#x2F;08</td><td align="left">增加段落</td><td align="left"><a href="/2019/09/09/AWS/Whitepaper-Using-AWS-For-Disaster-Recovery/">Whitepaper - Using AWS for Disaster Recovery</a></td><td align="left">2019&#x2F;09&#x2F;09</td></tr><tr><td>2020&#x2F;01&#x2F;31</td><td align="left">增加資料</td><td align="left"><a href="/2018/06/14/DevOps/Recap-What-is-Ops/">再談啥是維運？</a></td><td align="left">2018&#x2F;06&#x2F;14</td></tr><tr><td>2020&#x2F;01&#x2F;02</td><td align="left">增加段落</td><td align="left"><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></td><td align="left">2019&#x2F;10&#x2F;30</td></tr></tbody></table><hr><h2 id="2019-x2F-Q4"><a href="#2019-x2F-Q4" class="headerlink" title="2019&#x2F;Q4"></a>2019&#x2F;Q4</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;12&#x2F;15</td><td align="left">重構結構</td><td align="left"><a href="/2017/07/01/Reference/Books/">參考書</a></td><td align="left">2017&#x2F;07&#x2F;01</td></tr><tr><td>2019&#x2F;12&#x2F;13</td><td align="left">增加段落</td><td align="left"><a href="/2016/04/07/AWS/Study-Notes-S3/">Study Notes - AWS S3</a></td><td align="left">2016&#x2F;04&#x2F;07</td></tr><tr><td>2019&#x2F;11&#x2F;16</td><td align="left">重構文章</td><td align="left"><a href="/2016/11/27/AWS/Whitepaper-AWS-Well-Architect-Framework/">Whitepaper - AWS Well-Architected Framework</a></td><td align="left">2016&#x2F;11&#x2F;27</td></tr><tr><td>2019&#x2F;11&#x2F;16</td><td align="left">增加段落</td><td align="left"><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></td><td align="left">2018&#x2F;03&#x2F;18</td></tr><tr><td>2019&#x2F;10&#x2F;16</td><td align="left">增加段落</td><td align="left"><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></td><td align="left">2017&#x2F;09&#x2F;20</td></tr><tr><td>2019&#x2F;10&#x2F;16</td><td align="left">修改段落</td><td align="left"><a href="/2017/07/15/Container/Experience-minikube/">Experience minikube</a></td><td align="left">2017&#x2F;07&#x2F;15</td></tr><tr><td>2019&#x2F;10&#x2F;14</td><td align="left">增加段落</td><td align="left"><a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？</a></td><td align="left">2019&#x2F;09&#x2F;20</td></tr><tr><td>2019&#x2F;10&#x2F;14</td><td align="left">增加段落</td><td align="left"><a href="/2019/04/05/About/Working-Backwards/">一個人的 Working Backwards</a></td><td align="left">2019&#x2F;04&#x2F;05</td></tr><tr><td>2019&#x2F;10&#x2F;13</td><td align="left">增加段落</td><td align="left"><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a></td><td align="left">2018&#x2F;06&#x2F;18</td></tr><tr><td>2019&#x2F;10&#x2F;13</td><td align="left">修改段落</td><td align="left"><a href="/2016/08/17/AWS/Study-Notes-DynamoDB/">DynamoDB 學習筆記</a></td><td align="left">2016&#x2F;08&#x2F;17</td></tr><tr><td>2019&#x2F;10&#x2F;06</td><td align="left">修改段落</td><td align="left"><a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 安裝筆記 (ubuntu16.04) - kubeadm 手動</a></td><td align="left">2019&#x2F;03&#x2F;17</td></tr></tbody></table><h2 id="2019-x2F-Q3"><a href="#2019-x2F-Q3" class="headerlink" title="2019&#x2F;Q3"></a>2019&#x2F;Q3</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;09&#x2F;10</td><td align="left">增加段落</td><td align="left"><a href="/2018/12/16/DevOps/Hire-a-Release-Engineer/">需要專職的 Release Engineer？</a></td><td align="left">2018&#x2F;12&#x2F;16</td></tr><tr><td>2019&#x2F;09&#x2F;10</td><td align="left">增加段落</td><td align="left"><a href="/2019/01/21/Management/KM-and-Issue-Tracking/">Issue Tracking 在企業裡的價值 - KM</a></td><td align="left">2019&#x2F;01&#x2F;21</td></tr><tr><td>2019&#x2F;09&#x2F;01</td><td align="left">增加段落</td><td align="left"><a href="/2019/01/20/About/Reading/">閱讀能力的重要性</a></td><td align="left">2019&#x2F;01&#x2F;20</td></tr><tr><td>2019&#x2F;08&#x2F;31</td><td align="left">增加段落</td><td align="left"><a href="/2018/09/22/Management/Hiring-Step3-Interview-Values-Attitude/">人力招募 - 三、深度對話：價值觀</a></td><td align="left">2018&#x2F;09&#x2F;22</td></tr><tr><td>2019&#x2F;08&#x2F;20</td><td align="left">重構結構</td><td align="left"><a href="/2019/05/30/AWS/Federated-SSO-to-AWS-using-GSuite/">如何用 G Guite 整合 AWS Single Sign-On</a></td><td align="left">2019&#x2F;05&#x2F;30</td></tr></tbody></table><h2 id="2019-x2F-Q2"><a href="#2019-x2F-Q2" class="headerlink" title="2019&#x2F;Q2"></a>2019&#x2F;Q2</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;06&#x2F;11</td><td align="left">重構文章</td><td align="left"><a href="/2016/04/07/AWS/Study-Notes-S3/">Study Notes - AWS S3</a></td><td align="left">2016&#x2F;04&#x2F;07</td></tr><tr><td>2019&#x2F;05&#x2F;31</td><td align="left">增加段落</td><td align="left"><a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></td><td align="left">2014&#x2F;10&#x2F;26</td></tr><tr><td>2019&#x2F;05&#x2F;31</td><td align="left">增加段落</td><td align="left"><a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></td><td align="left">2017&#x2F;03&#x2F;18</td></tr><tr><td>2019&#x2F;04&#x2F;07</td><td align="left">重構結構</td><td align="left"><a href="/2016/02/21/AWS/Study-Notes-VPC/">Study Notes - Virtual Private Cloud (VPC)</a></td><td align="left">2016&#x2F;02&#x2F;21</td></tr><tr><td>2019&#x2F;04&#x2F;04</td><td align="left">重構結構</td><td align="left"><a href="/2017/02/04/AWS/Study-Notes-EC2-Auto-Scaling/">Study Notes - EC2 Auto Scaling</a></td><td align="left">2017&#x2F;02&#x2F;04</td></tr><tr><td>2019&#x2F;04&#x2F;04</td><td align="left">調整結構</td><td align="left"><a href="/2017/02/11/DevOps/Resource-Provisioning-and-DevOps/">Resource Provisioning and DevOps</a></td><td align="left">2017&#x2F;02&#x2F;11</td></tr></tbody></table><h2 id="2019-x2F-Q1"><a href="#2019-x2F-Q1" class="headerlink" title="2019&#x2F;Q1"></a>2019&#x2F;Q1</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2019&#x2F;03&#x2F;23</td><td align="left">增加段落</td><td align="left"><a href="/2018/01/24/DistributedSystems/Overview-API-Gateway/">Overview API Gateway</a></td><td align="left">2018&#x2F;01&#x2F;24</td></tr><tr><td>2019&#x2F;01&#x2F;18</td><td align="left">增加段落</td><td align="left"><a href="/2018/07/08/DevOps/Artifacts-Management/">Artifacts Management</a></td><td align="left">2018&#x2F;07&#x2F;08</td></tr><tr><td>2019&#x2F;01&#x2F;11</td><td align="left">增加段落</td><td align="left"><a href="/2018/04/01/DevOps/How-To-Make-CICD-Quality/">怎樣的 CI&#x2F;CD 才夠 Quality?</a></td><td align="left">2018&#x2F;04&#x2F;01</td></tr><tr><td>2019&#x2F;01&#x2F;06</td><td align="left">重構結構</td><td align="left"><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></td><td align="left">2017&#x2F;09&#x2F;20</td></tr><tr><td>2019&#x2F;01&#x2F;06</td><td align="left">增加段落</td><td align="left"><a href="/2018/08/20/Management/Overview-Hiring/">聊聊人力招募</a></td><td align="left">2017&#x2F;02&#x2F;04</td></tr><tr><td>2019&#x2F;01&#x2F;06</td><td align="left">文句修飾</td><td align="left"><a href="/2017/11/14/DevOps/Go-Live/">Go Live</a></td><td align="left">2017&#x2F;11&#x2F;14</td></tr><tr><td>2019&#x2F;01&#x2F;05</td><td align="left">文句修飾</td><td align="left"><a href="/2018/12/16/DevOps/Hire-a-Release-Engineer/">需要專職的 Release Engineer？</a></td><td align="left">2018&#x2F;12&#x2F;16</td></tr></tbody></table><hr><h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><h2 id="2018-x2F-Q4"><a href="#2018-x2F-Q4" class="headerlink" title="2018&#x2F;Q4"></a>2018&#x2F;Q4</h2><table><thead><tr><th>更新時間</th><th align="left">更新方式</th><th align="left">文章標題</th><th align="left">發布時間</th></tr></thead><tbody><tr><td>2018&#x2F;12&#x2F;26</td><td align="left">重構系列文</td><td align="left"><a href="/2017/03/02/AWS/Study-Notes-CloudWatch/">Study Notes - CloudWatch</a></td><td align="left">2017&#x2F;03&#x2F;02</td></tr><tr><td>2018&#x2F;12&#x2F;22</td><td align="left">重構系列文</td><td align="left"><a href="/2017/03/30/AWS/Study-Notes-CloudFormation/">Study Notes - CloudFormation</a></td><td align="left">2017&#x2F;03&#x2F;30</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;底下整理 Blog 更新的文章記錄，提供給想知道哪些文章有更動的朋友。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;更新時間&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;更新方式&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;文章標題&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;更新說明&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;發布時間&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;2023&amp;#x2F;07&amp;#x2F;01&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增內容&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2020/06/21/Management/Interview-Problems/&quot;&gt;面試常見的問題&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增錄影&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2020&amp;#x2F;06&amp;#x2F;21&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2021&amp;#x2F;08&amp;#x2F;21&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;更新參照&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2015/08/22/Management/Senior-Software-Developer/&quot;&gt;資深軟體工程師&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增參考資料&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2015&amp;#x2F;08&amp;#x2F;22&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2021&amp;#x2F;04&amp;#x2F;30&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增資料&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;/2019/10/30/SQA/Problems-In-Software-Testing/&quot;&gt;關於軟體測試，一些觀察到的現象&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;新增軟體測試管理工具的選擇&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;2019&amp;#x2F;10&amp;#x2F;30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>為什麼有些人都不刪除用不到的程式碼？</title>
    <link href="https://rickhw.github.io/2023/07/11/Coding/Why-Keep-Old-Code/"/>
    <id>https://rickhw.github.io/2023/07/11/Coding/Why-Keep-Old-Code/</id>
    <published>2023-07-10T19:33:00.000Z</published>
    <updated>2023-07-12T11:11:58.550Z</updated>
    
    <content type="html"><![CDATA[<p>原文是我在 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid069YbbrasrKAnqcrL7bnME8ajSZiaGh5LvhxoPX5qrCbsbY4ohiq3QzLz3qWQXD9vl">fb 寫下</a> 草稿，主要針對靠北工程師 <a href="https://www.facebook.com/init.kobeengineer/posts/pfbid0GxdVfaGnYi3YHKWo1vzhApBkSNpQext32nLy1KmhihKc3ogAp6uEWtgoEUosXn3Nl">鄉民提的問題</a>。幾乎一面倒的狀況之下，分享我自己的經驗與看法，提供不一樣的思路與前後文。</p><p><img src="/images/Coding/Why-Keep-Old-Code/main.png"></p><span id="more"></span><h2 id="個人觀點"><a href="#個人觀點" class="headerlink" title="個人觀點"></a>個人觀點</h2><p>以前也會這樣做，現在還是會這樣做，背後核心的想法是：</p><blockquote><p>修改的當下,<br>有沒有 &#x2F; 能不能 <code>意會 (awareness)</code> 到過去曾經發生事情</p></blockquote><p>這就像, 大家都知道發脾氣解決不了問題, 難的是當下, 你要觀察到自己已經要發脾氣了, <code>認知 (awareness)</code> 要控制自己的情緒.</p><p>開始修改一段既有的邏輯, 假設是一個 function 裡的某個 block A:</p><ul><li>有沒有理解該 block A 原本的設計？</li><li>該 block A 是否有明確的範圍? <ul><li>Q: 已經是 block 為啥會有範圍問題？</li><li>A: 這就是問題, 就差在修改當下你有沒意識到這問題</li></ul></li><li>修改之後, 過些時間 (無論長短), 會來還記得為什麼這樣改?</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>我知道很多人會說, 可以看 git log, 現在 IDE 也會即時秀在上面, 工具的確可以幫助這點, 我覺得沒什麼問題.</p><p>但實務上, 在改 code 的當下, 重點還是要意會到, 這次的 change 與過去的設計的差異. git log &#x2F; IDE &#x2F; 留下就的 code 背後動機都是如此. 至於哪一個比較有效, 就是選擇.</p><blockquote><p>這段話的邏輯，與用實體看板的動機是一樣的。類似問題在選擇 實體看板與數位看板 經常出現。</p></blockquote><h3 id="務實的認知-Awareness-方法"><a href="#務實的認知-Awareness-方法" class="headerlink" title="務實的認知 (Awareness) 方法"></a>務實的認知 (Awareness) 方法</h3><p>老人的老方法, 就是把舊的放在上面, 但是會有 flag 註記為什麼改, 如果是 change 就一定要保留舊的, 像是一個 legacy code, 因為時間關係, 在一個超大的 <code>if ( ... // 五行  ) &#123;&#125; </code> 條件式, 上面已經有七八個 flag, 標示 defect number, issue tracing 上會記錄問題的背景, 討論的前因後果, 可能相關的 issue.</p><p>執行面, 時間關係, 只能先改, 之後再來重構.</p><blockquote><p>對, 我知道, 這種 Code 要重構, 要如何如何 …. (省略 3000 個字,<br>時間夠, 我可以整個都重寫 … 重點是沒時間<br>工程師都很常靠北別人寫的文件不清楚, 但靠北之前, 請問問自己花了多少時間寫文件.</p></blockquote><p>很多時候, 不知道前因後果, 只是為了改而改, 只會把問題越搞越撲逤迷離. 留下麵包屑, 留下 defect number, 才是有機會重構的線索.</p><h3 id="想當年-真實案例"><a href="#想當年-真實案例" class="headerlink" title="想當年, 真實案例"></a>想當年, 真實案例</h3><p>我還很菜的時候, 就做過這種重構的事. 但那風險非常高, 等於過去曾發生的 defect 要一次全解.</p><blockquote><p>註：那年代還沒有 Unit Test 這種名稱, 但有類似做法.</p></blockquote><p>那是一個類似 insert 的演算法, 簡單說就是一個文字編輯器, 當 insert 一個 character 的時候, 整文章的 linked list 結構被加入一些 node, 然後圖形介面要重新 render 的時候, 發生邏輯的誤判, 造成畫面大亂.</p><p>那時候我就重新分析這個演算法, 但是發現整個已經非常混亂了, 我改下去不是變成英雄, 不然就是背鍋俠. 最後 … 畫了一張很大的流程圖, 讓老闆知道, 不是我不改 … 而是我太菜, 不敢改 …. (算是權衡之計)</p><p>我之所以意會到這件事情, 是因為很多前人都有留 flag &#x2F; 還有舊的邏輯 (comment out), 所以我很清楚知道, 這段結構過去的傷疤與問題, 打開 code 當下馬上就意會 (awareness) 到這個問題了 …</p><p>這就是為什麼, 很多老人都會把舊的 code 放在上面, 不砍的原因.</p><h2 id="非黑即白"><a href="#非黑即白" class="headerlink" title="非黑即白"></a>非黑即白</h2><p>說說一些不一樣的看法.</p><p>重點還是看一下 Context (前後文), Situation (情況), 再來下定論.</p><p>真實世界的運作，不是那麼單純的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文是我在 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid069YbbrasrKAnqcrL7bnME8ajSZiaGh5LvhxoPX5qrCbsbY4ohiq3QzLz3qWQXD9vl&quot;&gt;fb 寫下&lt;/a&gt; 草稿，主要針對靠北工程師 &lt;a href=&quot;https://www.facebook.com/init.kobeengineer/posts/pfbid0GxdVfaGnYi3YHKWo1vzhApBkSNpQext32nLy1KmhihKc3ogAp6uEWtgoEUosXn3Nl&quot;&gt;鄉民提的問題&lt;/a&gt;。幾乎一面倒的狀況之下，分享我自己的經驗與看法，提供不一樣的思路與前後文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Coding/Why-Keep-Old-Code/main.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://rickhw.github.io/categories/Coding/"/>
    
    
    <category term="Code Convension" scheme="https://rickhw.github.io/tags/Code-Convension/"/>
    
  </entry>
  
  <entry>
    <title>SRE 常見問題 - 訪談紀錄</title>
    <link href="https://rickhw.github.io/2023/07/06/DevOps/SRE-FAQ/"/>
    <id>https://rickhw.github.io/2023/07/06/DevOps/SRE-FAQ/</id>
    <published>2023-07-06T04:43:00.000Z</published>
    <updated>2023-07-08T11:32:58.727Z</updated>
    
    <content type="html"><![CDATA[<p>整理一段關於 SRE 問題的訪談紀錄，歡迎大家提供不一樣的經驗與想法。</p><span id="more"></span><h2 id="Q1-企業內部的-SRE-與-DevOps-工作內容與分工？"><a href="#Q1-企業內部的-SRE-與-DevOps-工作內容與分工？" class="headerlink" title="Q1. 企業內部的 SRE 與 DevOps 工作內容與分工？"></a>Q1. 企業內部的 SRE 與 DevOps 工作內容與分工？</h2><p>這要看企業規模，而且大部分企業對於 DevOps &#x2F; SRE 的理解與定義可能都有差異。</p><p>個人經歷過大多是這樣分：</p><ul><li><code>Feature Team / DevOps</code>: 負責業務邏輯的開發團隊 (Scrum Team)，團隊裡可能有一個或多個專屬的 DevOps Engineer 負責處理所有的 CI &#x2F; CD 工作。 </li><li><code>Infra Team / SRE</code>: 負責處理 App 以外的東西，包含 Cloud &#x2F; Network &#x2F; Cost &#x2F; Provisioning &#x2F; Observability  &#x2F; Monitoring &#x2F; Architecture &#x2F; Artifact Repos &#x2F; CI&#x2F;CD 平台 &#x2F; Security …. Etc.</li></ul><p>其實很多企業，對於怎麼定義 SRE or DevOps 是沒有想法的，或者是有自己的解讀 … 所以討論這樣的題目時，通常我都會先反問對方的期待與認知，確認彼此 <code>On the same page</code>.</p><p>實務上，少於 500 人的企業，這兩個角色 (DevOps &#x2F; SRE) 對老闆來講，是沒差的；大於 500 人的企業，這兩個角色對老闆來講，還是沒差。。。</p><p>所以有時候工作上，不要太糾結自己的範圍，而是要思考，現在處在的環境，自己要怎麼做才會有貢獻 (亮點)。</p><p>換個角度想：</p><blockquote><p>你花了 5 萬塊，一個月請一個人，希望得到什麼？</p></blockquote><p>聽起來像是幹話，但很現實，因為勞雇就是一種買賣。</p><h2 id="Q2-SRE-工程師，需要具備的基礎技能有哪些？"><a href="#Q2-SRE-工程師，需要具備的基礎技能有哪些？" class="headerlink" title="Q2. SRE 工程師，需要具備的基礎技能有哪些？"></a>Q2. SRE 工程師，需要具備的基礎技能有哪些？</h2><p>依照 SRE 原文的定義，我認為的 SRE 本質是：</p><blockquote><p>用軟體工程，解決維運任務</p></blockquote><p>這句話我這樣拆解：</p><ul><li><code>專業職能</code>：軟體工程，包含程式設計&amp;開發&amp;測試 &#x2F; 系統工程＆架構<ul><li>軟體工程就是作出可以 Reusable &#x2F; Scalable 的東西，可以從 1 變成 10 的概念</li></ul></li><li><code>領域知識</code>：系統維運，包含異常處理, 事件管理, 自動化工程 … 很多，可以參閱我以前整理的 <a href="/2018/03/29/About/2018-Serverless-All-Star/">R&amp;R 分布圖</a></li></ul><p>專業技能：</p><ul><li><code>Programming</code>: Python&#x2F;Golang, Web, RDB, Cache, Queue.</li><li><code>Networking</code>: Protocol (TCP &#x2F; UDP &#x2F; HTTP &#x2F; DNS &#x2F; BGP  …), Network Devices (Switch &#x2F; Router &#x2F; AP … etc)</li><li><code>System</code>: Public Cloud, OS (Linux, OS), Storage</li><li>Observability &amp; Monitoring</li></ul><p>專業技能很粗略地寫，因為這些內容的技術過幾年就會翻一輪，實務上用人不會找 100% 符合的 (也找不到)，更多是找基礎好、可以栽培、個性積極的，當然要解釋成成本考量也是可以的。</p><p>相關用人的邏輯，可以參閱 <a href="/2018/09/18/Management/Hiring-Step2-Interview-Skills/">人力招募 - 二、見面談：招募第一關 面試</a></p><h2 id="Q3-在建置-SRE-團隊中，過程有遇到哪些痛點？"><a href="#Q3-在建置-SRE-團隊中，過程有遇到哪些痛點？" class="headerlink" title="Q3. 在建置 SRE 團隊中，過程有遇到哪些痛點？"></a>Q3. 在建置 SRE 團隊中，過程有遇到哪些痛點？</h2><p>所謂「痛點」要看用什麼角度來看，其中「政治問題」是避免不了的。</p><p>大多在業務上站上位置的角色，都是強勢的一方，也就是上位。這在任何企業都一樣，不管什麼產業都一樣，因為企業本質就是賺錢，開源單位講話大聲，成本單位大多能做的是滿足他們，這樣的供需關係，在很多企業裡都差不多，能改變關係的是少數。</p><p>所以大部分的現象 (不是問題) 都是組織結構上任務與資源不對等，更多的是 R&amp;R 不分，執行任務過程勞心、勞力、傷神又傷心，衍生的感覺就是「痛點」。(上述現象，把 SRE 換成 QA 一樣適用)</p><p>用人與人才培養也是問題，但是不能算是痛點，這方面需要耐心與信心，創造機會與耐心教導，還是可以做得好。</p><p>再來是怎麼讓 Feature Team 與 Infra &#x2F; SRE Team 能夠有效協作的「共識」，也就是制度。當遇到一件事情的時候，該怎麼區分這件事情的 ownership？官大說了算？該怎麼理性溝通？例如線上炸鍋，炸鍋解決了，因為系統資源不足，所以 Responsiblity 就是在 SRE &#x2F; Infra？大多是，實務上很多就是「政治」角力，讓這件事情正確的 R&amp;R 歪掉。</p><p>這個案例，大概是實務上的痛點，因為資源不足，更多時候是程式改善可以解決，但有時候「用錢能解決的問題不是問題」，就蓋過真正的問題了，那個問題幾年後通常會再爆出來，但已經沒人知道為什麼了 (省略一本書的故事 ….</p><p>可能的解法：建立一個可以跟 Feature Team 協作的制度，概念類似 AWS 的 Shared Responsibility。但建立這個「雙方」的智度，要有「自己」的制度，讓自己的制度動起來，站穩腳步。然後再去跟 Feature team 討論雙方的制度。大概的概念可以參閱我在 <a href="/2022/05/10/About/2022-SREConf2022/">SRE Conf 2022 分享</a> 的 P58.</p><h2 id="Q4-過去是怎麼進行內部-SRE-人才培訓？"><a href="#Q4-過去是怎麼進行內部-SRE-人才培訓？" class="headerlink" title="Q4. 過去是怎麼進行內部 SRE 人才培訓？"></a>Q4. 過去是怎麼進行內部 SRE 人才培訓？</h2><p>針對傳統 OP (管系統, 管設備, 不寫 Code) 的訓練，務實面的方式以及過程摘要如下：</p><ol><li>手把手教，以 Python &#x2F; Cloud 為主，像是 Python runs on Lambda (AWS)，Export as API。<ul><li>從他們本來就熟悉的領域切入，不要弄太難或者太多觀念 (ex: OOP, Framework)，重心擺在領域問題能用簡單的 Code &amp; Cloud 解決</li><li>從簡單的日常維運開始，像是備份、檢查 DNS &#x2F; SSL 過期 &#x2F; Health Check，可以玩 Cloud + Programming，不會太難，又有成就感。</li></ul></li><li>訓練開發 API 封裝 Public Cloud &#x2F; SaaS 的功能，提供給 CI &#x2F; CD 整合時、維運時使用<ul><li>減少 Feature Team 接觸 Cloud 的面積，因為大部分的 Public Cloud 的功能只能用到 20%，很容易讓人有選擇困難，透過 API 封裝，簡化 Feature team 的使用難度，又可以讓 SRE 設計 API &#x2F; Coding，雙贏。</li><li>更多參閱 <a href="/2022/05/10/About/2022-SREConf2022/">SRE Conf 2022 分享</a> 的 P47.</li></ul></li><li>資深一點的：透過 GitOps 的方法，設計較複雜的架構，像是非同步排程任務，只要 commit 就可以發動任務.<ul><li>這是長期策略，也就是未來雙方協作都是透過 GitOps 驅動</li><li>Policy as Code 的第一步。</li><li>看到 Code 一翻兩瞪眼，雙方容易聚焦，減少爭議</li></ul></li><li>訓練處理異常：從異常中學習架構是怎麼一回事，系統是怎麼運作的<ul><li>一個 Request 第一次跟第二次 Latency 不一樣，這是怎麼一回事？</li><li>就像醫生看到症狀，就可以大概知道問題在哪。但前提是醫生是了解人體結構與運作原理的，SRE 了解架構，才有辦法隔空抓藥。</li></ul></li></ol><p>管理角度，可以參閱我寫的 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tWjKzm9BnagRqknGrnXfzA2DbqTCq1xCcFTdZjvRtkA2pu1rLSbpvfsYGFAe9Mtdl">人才發展策略地圖 (草稿)</a>，這份草稿不止 SRE，只要是軟體開發團隊都適用。</p><h2 id="Q5-在-SRE-人才的培育上，應該要上哪些課程？"><a href="#Q5-在-SRE-人才的培育上，應該要上哪些課程？" class="headerlink" title="Q5. 在 SRE 人才的培育上，應該要上哪些課程？"></a>Q5. 在 SRE 人才的培育上，應該要上哪些課程？</h2><p>如果我有機會規劃學程，快速摘要一些想法，不見得可行，但是要先有一版出來 (先有再求好)。</p><p>3 + 3 代表三學分，兩個學期，如果是專職課程，3 &#x3D; 6 個月</p><ul><li>API 開發 (3 + 3): Python &#x2F; Golang, Cache, Queue, OpenAPI</li><li>網路基礎 (3 + 3)</li><li>軟體交付實務 (3 + 3)</li><li>監控 實務 (3 + 3)</li><li>架構 (3 + 3 + 3): Public Cloud &#x2F; K8s</li><li>分散式系統 (3 + 3): 可以參閱最近 <a href="https://sre.google/classroom/imageserver/?fbclid=IwAR1ncyFGKq7Kv3EVLl3REJun5xMp29Wntan3ZaqPRuC2xmei2hQ_hAKmAuY">Google 出的課程</a></li></ul><p>CS 有以下:</p><ul><li>OS &#x2F; Compute Architecture</li><li>Networking</li><li>Database</li><li>Programming (3+3) &#x2F; Data structure &#x2F; Algorithm</li></ul><p>是否一定要 CS (計算機科學 &#x2F; 資工 &#x2F; 資管) 背景？我個人希望要有，最好是數學相關背景的。當然，這是我個人的偏好而已。我也用過不是這樣背景，但表現也非常優秀的人。</p><hr><h2 id="聽歌"><a href="#聽歌" class="headerlink" title="聽歌"></a>聽歌</h2><p>聽著 <a href="https://www.youtube.com/watch?v=qna0SwJtoU4&list=RDEM0c_-4xca83hAcgJgn1Y86g&index=4">李玟 (Coco)</a> 的精選，寫文章。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li>推薦：<a href="/2018/08/03/DevOps/An-Introduction-to-SRE/">Site Reliability Engineering (SRE, 網站可靠性工程)</a></li><li>演講：<a href="/2022/05/10/About/2022-SREConf2022/">SRE Conference 2022 - 91APP 在 AWS 上的 SRE 實踐之路</a></li><li>演講：<a href="/2018/03/29/About/2018-Serverless-All-Star/">Serverless All-Star - Ops as Code using Serverless</a></li><li>演講：<a href="/2017/06/21/AWS/Stategies-System-Monitor_and_CloudWatch/">淺談系統監控與 CloudWatch 的應用</a></li><li>演講：<a href="/2018/05/26/About/201805-Monitoring-Tools-CloudWatch/">Monitoring Tools 大亂鬥 - AWS CloudWatch</a></li><li><a href="/2018/01/07/DevOps/Emergency-Response/">緊急應變 (Emergency Response)</a></li></ul><h2 id="其它參考"><a href="#其它參考" class="headerlink" title="其它參考"></a>其它參考</h2><ul><li><a href="https://sre.google/classroom/imageserver/?fbclid=IwAR1ncyFGKq7Kv3EVLl3REJun5xMp29Wntan3ZaqPRuC2xmei2hQ_hAKmAuY">SRE Classroom: Distributed ImageServer</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tWjKzm9BnagRqknGrnXfzA2DbqTCq1xCcFTdZjvRtkA2pu1rLSbpvfsYGFAe9Mtdl">人才發展策略</a> (draft, 2022&#x2F;10&#x2F;26)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理一段關於 SRE 問題的訪談紀錄，歡迎大家提供不一樣的經驗與想法。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://rickhw.github.io/categories/DevOps/"/>
    
    <category term="SRE" scheme="https://rickhw.github.io/categories/DevOps/SRE/"/>
    
    
    <category term="Monitoring" scheme="https://rickhw.github.io/tags/Monitoring/"/>
    
    <category term="SRE" scheme="https://rickhw.github.io/tags/SRE/"/>
    
    <category term="Emergency Response" scheme="https://rickhw.github.io/tags/Emergency-Response/"/>
    
    <category term="Incident Management" scheme="https://rickhw.github.io/tags/Incident-Management/"/>
    
    <category term="Software Engineering" scheme="https://rickhw.github.io/tags/Software-Engineering/"/>
    
  </entry>
  
  <entry>
    <title>API 設計 - API 整合矩陣</title>
    <link href="https://rickhw.github.io/2023/07/02/DistributedSystems/API-Integration-Matrix/"/>
    <id>https://rickhw.github.io/2023/07/02/DistributedSystems/API-Integration-Matrix/</id>
    <published>2023-07-02T05:30:00.000Z</published>
    <updated>2023-07-02T01:20:03.671Z</updated>
    
    <content type="html"><![CDATA[<p>API 存在的目的，最早期是程式邏輯可以重複使用，例如 時間相關的工具，透過標準的介面定義，以及模組化的概念，每個人在開發應用程式的時候，都可以引用同一個函示庫，透過標準介面就可以調用。像是 Java 語言的 <code>java.util.Date</code> 這樣的標準介面，所以 API 的概念就出現了。</p><span id="more"></span><p>後來程式跟程式之間也要相互調用，像是 Java 要使用 linux ls 的資料，所以產生了 <code>Inter-Process Communication (IPC)</code>，讓 Process 跟 Process 之間可以相互調用。</p><p>但這都還是在同一個作業系統裡面，分散式系統的出現，開始出現 RPC (Remote Procedure Call)，讓跨系統之間可以相互調用，做出更複雜的功能。</p><p>類似的概念，到了 Web &#x2F; HTTP 出現之後，SOA 概念興起，跨服務之間的溝通，就變得更重要了，API 的概念又被更放大了。</p><h2 id="什麼是-API？"><a href="#什麼是-API？" class="headerlink" title="什麼是 API？"></a>什麼是 API？</h2><p><code>API (Application Programming Interface)</code> 指的是讓 <code>兩個以上</code> 的 <code>異質系統</code>，相互調用彼此功能的可程式化介面。例如：</p><blockquote><p>在 Windows (作業系統) 上有一個 行事曆 (Desktop 應用程式)，他需要取得 Windows 本身提供的時間資訊，所以調用 <code>Windows.Date()</code> 取得現在的時間。</p></blockquote><p>這個例子，Windows 和 行事曆 兩者就是異質系統，而 Windows 提供的 <code>Windows.Date()</code> 就是個 API 介面，通常這種稱為 Syscall。</p><p>API 泛指各種可以相互調用的介面，包含以下：</p><ul><li><code>Libraries</code>: 各種 C 的 .h、Java &#x2F; C# Code 的 Interface 都算是<ul><li>同一個程式語言之間，使用彼此功能的介面</li></ul></li><li><code>RPC</code>: Remote Procedure Call 遠程調用介面，技術觀點就是跨語言 &#x2F; 跨系統之間的調用，垂直整合 (系統與程式)、水平整合 (系統與系統)<ul><li><code>Web</code>: 基於 HTTP 協議的介面，也是本文的主角，屬於水平整合的 <code>系統與系統</code> 溝通</li><li><code>SSH</code>: 透過 SSH 下的 remote call</li></ul></li></ul><h2 id="API-Integration-Matrix"><a href="#API-Integration-Matrix" class="headerlink" title="API Integration Matrix"></a>API Integration Matrix</h2><p>常見的 API 整合方式，以 <code>提供者與使用者</code> 的角度，API 形式則用 <code>系統與程式</code> 區分，定義這兩者如下：</p><ul><li>Pub&#x2F;Sub：API 有提供者 (Publisher) 也有使用者 (Subscriber)</li><li>系統：只作業系統、或者 Web Services</li><li>程式：應用程式，像是 Desktop、開一個 Port 走 TCP &#x2F; UDP 的應用<ul><li>應用程式之間大多透過 <code>Inter-Process Communication (IPC)</code> 交互通訊，更多參閱 <a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">Shell and Bash Concepts</a></li></ul></li></ul><p>依照這樣的定義，整理出以下的整合矩陣：</p><p><img src="/images/DistributedSystems/API-Product-Plan-Design-Overview/API-Integration-Matrix_v20230701.png"></p><p>這四個象限分別說明如下：</p><ul><li>A: 指的是系統發布 API ，提供給程式使用<ul><li>例如：Linux 提供 Syscall 給應用程式 ls 使用。</li></ul></li><li>B: 程式跟程式之間相互調用使用，例如：<ul><li>使用 Springboot 開發 Web 應用。</li><li>這裡指的程式是同一種語言，如果是不同語言，那屬於 D 象限。</li></ul></li><li>C: 與 A 相反，程式語言提供介面給系統使用，例如：<ul><li>微軟瀏覽器 Edge 的常駐程式，當需要更新版本的時候，提供介面讓 macOS 調用，並通知使用者有新版本更新</li></ul></li><li>D: 系統對系統，像是：<ul><li>Web Service 彼此之間 API 的調用</li><li>Linux 之間的溝通與調用 RPC，也是這個範圍</li><li>如果是跨作業系統溝通，例如 Linux 調用 Windows，這年代大多會封裝成 Web API 的方式調用，例如 AWS 的 microVM - <a href="https://github.com/firecracker-microvm/firecracker">FireCracker</a> 預設就有 WebAPI 可以使用</li></ul></li></ul><p>因為分散式系統的大爆炸，所以 D 象限大爆炸，特別是基於 Web &#x2F; HTTP 的 API，所以現在口語上說 API 的時候，很多時候都是泛指 Web API，特別是 RESTful API，當然也會包含其他像是 gRPC &#x2F; GraphQL 等不同的實踐技術。</p><p>實際上 D 範圍包含 A &#x2F; C &#x2F; B 三大塊，也就是為了達到 D 的目的，開發工作會橫跨另外三個。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a></li><li><a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</a></li><li><a href="/2018/01/24/DistributedSystems/Overview-API-Gateway/">Overview API Gateway</a></li><li><a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">Shell and Bash Concepts</a></li><li><a href="/2023/06/24/DistributedSystems/API-Communication-Protocol/">分散式系統設計 - 摘要 API 通訊模式與協議</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://dineshchandgr.medium.com/api-things-every-software-engineer-must-know-api-integration-economy-protocols-endpoint-4649ecbc7c41">API things every Software Engineer must know — API Integration, Economy, Protocols, Endpoint, Security…</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;API 存在的目的，最早期是程式邏輯可以重複使用，例如 時間相關的工具，透過標準的介面定義，以及模組化的概念，每個人在開發應用程式的時候，都可以引用同一個函示庫，透過標準介面就可以調用。像是 Java 語言的 &lt;code&gt;java.util.Date&lt;/code&gt; 這樣的標準介面，所以 API 的概念就出現了。&lt;/p&gt;</summary>
    
    
    
    <category term="Distributed Systems" scheme="https://rickhw.github.io/categories/Distributed-Systems/"/>
    
    
    <category term="Distributed Communication" scheme="https://rickhw.github.io/tags/Distributed-Communication/"/>
    
    <category term="API Platform" scheme="https://rickhw.github.io/tags/API-Platform/"/>
    
    <category term="API First" scheme="https://rickhw.github.io/tags/API-First/"/>
    
    <category term="Contract First" scheme="https://rickhw.github.io/tags/Contract-First/"/>
    
    <category term="API Governance" scheme="https://rickhw.github.io/tags/API-Governance/"/>
    
    <category term="API Management" scheme="https://rickhw.github.io/tags/API-Management/"/>
    
    <category term="API Styles" scheme="https://rickhw.github.io/tags/API-Styles/"/>
    
    <category term="API Protocol" scheme="https://rickhw.github.io/tags/API-Protocol/"/>
    
  </entry>
  
  <entry>
    <title>API 設計 - 摘要 API 通訊模式與協議</title>
    <link href="https://rickhw.github.io/2023/06/24/DistributedSystems/API-Communication-Protocol/"/>
    <id>https://rickhw.github.io/2023/06/24/DistributedSystems/API-Communication-Protocol/</id>
    <published>2023-06-24T05:30:00.000Z</published>
    <updated>2023-07-02T05:58:01.392Z</updated>
    
    <content type="html"><![CDATA[<p><code>API First</code> 在跨企業的系統交互越來越頻繁的今天，提供有效的擴展業務的方法。過往什麼功能都要自行開發，但卻因為內部資源不足；亦或錯估新業務規模的深度與需求層次，造成投入沒有成效、或者必須不斷的加碼投入，最後才意會到，這是個獨立領域，需要獨立的專業團隊，像是 MarTech、支付、通訊 …</p><p>API First 的概念，背後是雙方在技術上彼此溝通的通訊協議，透過這層協議，雙方可以更快速的仰賴彼此的擅長的領域，進而拓展業務。最常見的就是電商與支付系統、廣告服務、電信系統、物流業、與 ChatBot &#x2F; AI … 等整合。</p><p>開放 API 是個策略性決策，背後代表著要與合作夥伴達成策略聯盟，本質上是 B2B 的商業行為；同時開放 API 也意味著內部系統需要有高度整合，提供對外統一介面與標準，讓合作夥伴在開發過程，可以有一致性的使用介面與理解。</p><p>基於這樣的前提，只要是 API 對外開放，大概都要面對本文要提到的問題：<code>API 通訊模式與協議</code></p><span id="more"></span><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文摘要基於 B2B 的業務模式，開放 API 時必須要規劃的對內、對外通訊模式，以及分析實務上的情境組合。</p><h2 id="通訊模式"><a href="#通訊模式" class="headerlink" title="通訊模式"></a>通訊模式</h2><p><code>通訊模式</code> 代表 API 對內、對外彼此交互的方式，整理如下圖：</p><p><img src="/images/DistributedSystems/API-Comm-Protocol/API-Comm-Mode_v20230623.png"></p><p>圖中定義的系統包含如下：</p><ol><li><code>API Platform</code>: 主要處理的是外部通訊請求，<ul><li>架構角色包含 API Gateway, API Manaement, API Operation 等部分<ul><li>API Gateway: 職責包含 AAA, Traffic Control, Protection, Rate Limit,</li><li>Management: API 的 Publisher &#x2F; Scription, Token &amp; Key Management &#x2F; Lifecycle &#x2F; Documentation … 等。背後本質是 API Governance.</li><li>API Operation: 包含 Obervability &amp; Monitoring, APM, Tracing, Logging, Cache … 等.</li></ul></li><li>整合 API Platform 對外處理合作夥伴的 API 請求, 同時轉發請求給對應的內部服務.</li></ul></li><li><code>Service X</code>: 企業內部各種 Domain Services 的泛稱，像是訂單 &#x2F; 商品 &#x2F; 庫存 … 等.<ul><li>這些服務都是內部系統，不直接對外</li><li>這些服務跟服務之間的溝通，必須遵循 <code>內部通訊協議 (Internal Commucation Protocol, ICP)</code></li></ul></li><li><code>External Services</code>: 使用 API 的合作夥伴，這裡的案例是 B2B</li><li><code>Client</code>: 提供給 End User 使用的 GUI 介面形式，包含 Mobile, Desktop, Web … 等.</li></ol><p>這四個角色之間，彼此之間的溝通用不同顏色以及標示 (C2, B3, C4, C3, D4 … )，搭配 <code>情境矩陣</code> 收斂實際的範圍。</p><h2 id="情境矩陣"><a href="#情境矩陣" class="headerlink" title="情境矩陣"></a>情境矩陣</h2><p>這四個角色之間的通訊，有 16 種排列組合，整理出以下的情境矩陣：</p><p><img src="/images/DistributedSystems/API-Comm-Protocol/API-Comm-Scenario_v20230623.png"></p><p>這十六種排列組合，彼此之間都有可能會相互通訊，情境矩陣則展開了所有的可能，經過分析後，刪除不合理、不需要、不必要的排列組合 (A1, B2, C1 …)，確立我們需要關注的組合，最核心情境有以下：</p><ol><li><code>Session Base</code>: 排列組合中的 A2</li><li><code>External API</code>: 排列組合中的 B3, C4</li><li><code>Internal Commucation</code>: 排列組合中的 C3, D3, D4</li><li><code>External Invcation</code>: 排列組合中的 C2, D2</li></ol><p>有了這樣的定義與理解之後，針對每個通訊模式，就可以定義適當的 Context ，讓彼此有一致的標準溝通，包含 (但不限於) 以下：</p><ol><li>認證授權</li><li>服務治理</li><li>展開適當的架構設計</li><li>追蹤管理</li><li>API 設計方法</li><li>API 生態系的管理與治理</li><li>API 維運</li><li>… etc.</li></ol><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>下圖是網路上很有名的故事，個人覺得核心是「經營之道」：</p><p><img src="/images/DistributedSystems/API-Comm-Protocol/Biz.png"></p><p>故事摘要如下：</p><blockquote><p>第一個猶太人來到小鎮上開了個加油站，生意很旺。第二個猶太人來了，發現加油站生意很不錯，想到加油站的客戶需要吃飯，所以投資開了個餐館。第三個猶太人來了，想到來小鎮的人多了需要住宿，於是開了個飯店。第四個猶太人又發現住店的人需要生活用品，於是開了超市。第五個，第六個……來的人越來越多，吃飯住宿旅遊經商的人又需要加油，於是加油站、餐館、飯店、超市的生意相繼更旺了，逐步小鎮就成了一個經濟繁榮的小鎮，很多猶太人都富裕了。</p><p>第一個中國人來到小鎮上開了個加油站，生意很旺。第二個中國人來了，發現第一個人投資的加油站生意真令人羨慕，趕緊開了第二個加油站。第三個中國人又來了，看見前面2個同胞的加油站生意很好妒嫉得眼紅，火速開了第三個加油站。第四，第五個同胞過來都是一樣，開加油站還打折促銷……最後惡性競爭，然後紛紛倒閉，小鎮又回到原點……</p></blockquote><p>先不論故事中的反諷，但是猶太人的重點就在於經營的過程，透過整合的方式，而不是硬碰硬，透過共榮、相互依存的概念，集結成一個生態系。API 本身就是生態系中的一環，企業透過開放 API，與其他異業結合，相互協助、相互依存，形成一個生態系。</p><p>有了這個核心的模式與情境，接下來就可以討論實際上架構設計時的選擇與設計思路，以及市面上的解決方案。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a></li><li><a href="/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/">摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</a></li><li><a href="/2018/01/24/DistributedSystems/Overview-API-Gateway/">Overview API Gateway</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;API First&lt;/code&gt; 在跨企業的系統交互越來越頻繁的今天，提供有效的擴展業務的方法。過往什麼功能都要自行開發，但卻因為內部資源不足；亦或錯估新業務規模的深度與需求層次，造成投入沒有成效、或者必須不斷的加碼投入，最後才意會到，這是個獨立領域，需要獨立的專業團隊，像是 MarTech、支付、通訊 …&lt;/p&gt;
&lt;p&gt;API First 的概念，背後是雙方在技術上彼此溝通的通訊協議，透過這層協議，雙方可以更快速的仰賴彼此的擅長的領域，進而拓展業務。最常見的就是電商與支付系統、廣告服務、電信系統、物流業、與 ChatBot &amp;#x2F; AI … 等整合。&lt;/p&gt;
&lt;p&gt;開放 API 是個策略性決策，背後代表著要與合作夥伴達成策略聯盟，本質上是 B2B 的商業行為；同時開放 API 也意味著內部系統需要有高度整合，提供對外統一介面與標準，讓合作夥伴在開發過程，可以有一致性的使用介面與理解。&lt;/p&gt;
&lt;p&gt;基於這樣的前提，只要是 API 對外開放，大概都要面對本文要提到的問題：&lt;code&gt;API 通訊模式與協議&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Distributed Systems" scheme="https://rickhw.github.io/categories/Distributed-Systems/"/>
    
    
    <category term="Distributed Communication" scheme="https://rickhw.github.io/tags/Distributed-Communication/"/>
    
    <category term="API Platform" scheme="https://rickhw.github.io/tags/API-Platform/"/>
    
    <category term="API First" scheme="https://rickhw.github.io/tags/API-First/"/>
    
    <category term="Contract First" scheme="https://rickhw.github.io/tags/Contract-First/"/>
    
    <category term="Communication Protocol" scheme="https://rickhw.github.io/tags/Communication-Protocol/"/>
    
  </entry>
  
  <entry>
    <title>一場失敗會議</title>
    <link href="https://rickhw.github.io/2023/06/14/Management/Failed-Meeting/"/>
    <id>https://rickhw.github.io/2023/06/14/Management/Failed-Meeting/</id>
    <published>2023-06-14T10:21:00.000Z</published>
    <updated>2023-06-15T09:40:29.728Z</updated>
    
    <content type="html"><![CDATA[<p>原文是 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02wkn7qeuR29WFShcVFkBUmr9AfEbD96fwgjdvyZbigNjxVmy8xqti4AvFdqJebmiEl">2021&#x2F;06&#x2F;14</a> 寫下的 memo，摘錄一場失敗的會議有哪些現象，與另一篇 <a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a> 成對比。</p><span id="more"></span><h2 id="1-會議發起者、與會議控制的問題"><a href="#1-會議發起者、與會議控制的問題" class="headerlink" title="1. 會議發起者、與會議控制的問題"></a>1. 會議發起者、與會議控制的問題</h2><h3 id="1-1-太多人參加"><a href="#1-1-太多人參加" class="headerlink" title="1.1 太多人參加"></a>1.1 太多人參加</h3><p>很多人參加，有兩個意思：很多層級、或者同一個層級的人很多。</p><p>各種層級、角色都有，上至 CxO、VP、Director、Manager，到 Engineering Team 都有。人類的溝通，不同層級之間討論事情，大部分 (80%) 是需要翻譯的，換言之，如果沒有從基層幹起，一路往上的人，或者具備一定的人格特質，要跨那麼大維度溝通本身就是個不容易的事情，因為很常會出現這種現象：</p><blockquote><p>TCP 跟 HTTP 放在一起討論<br>討論 狗 和 熱狗 的差異</p></blockquote><p>這種現象很常出現在各種社會事件，媒體公關事件最明顯，那種抗議場合的溝通。</p><p>理想會議人數同 scrum team &lt;&#x3D; 8 人，這樣的溝通常會比較有效率，所有人對於事物的理解，才會一致。</p><p>類似的案例：</p><ol><li>宣誓大會</li><li>All-Hands Meetings、年會</li><li>部門會議</li></ol><h3 id="1-2-會議目的不清楚-這場會議目的到底是？"><a href="#1-2-會議目的不清楚-這場會議目的到底是？" class="headerlink" title="1.2 會議目的不清楚: 這場會議目的到底是？"></a>1.2 會議目的不清楚: 這場會議目的到底是？</h3><p>會議的目的通常有以下類型：</p><ol><li><code>討論</code>：因為資訊不足，希望透過討論，尋求建議，相互請教的過程。<ul><li>這種目的不要在太多人的場合討論，特別是一次跨太多部門的人一起頭論，基本上是沒意義的。因為狀況會同 1.1 的結果。</li><li>實際有效做法是主要負責的人，跟關係部門 (1:N)，每次一對一 (1:1) 的過，過程負責人發現 X &#x2F; Y 有衝突，在私下找 X &#x2F; Y 負責人做決議，最後由負責的人做總結與決策。</li><li>理想的是 <code>星狀溝通</code>，必要時才是 <code>網狀溝通</code>。</li></ul></li><li><code>找共識</code>：希望提供彙整的資訊 &#x2F; 報告，進而找到共識、做決策？</li><li><code>公告布達，產生行動</code>：已經有共識、已經做好決策，要開始執行了，主要目的是分工，資源協調</li></ol><h3 id="1-3-會議角色混亂，沒有控制"><a href="#1-3-會議角色混亂，沒有控制" class="headerlink" title="1.3 會議角色混亂，沒有控制"></a>1.3 會議角色混亂，沒有控制</h3><p>會議進行過程，沒有分工，詳細解法參閱 <a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></p><h3 id="1-4-會議主軸資訊量過大"><a href="#1-4-會議主軸資訊量過大" class="headerlink" title="1.4 會議主軸資訊量過大"></a>1.4 會議主軸資訊量過大</h3><p>這是最常發生的現象，成年人在一個小時裡能夠專注的時間只有 30%，能夠理解全部資訊量的人通常是更少。</p><p>主講者把自己深思幾個月的結論，一次放出來，但沒有做適度的抽象畫整理，造成與會者瞬間看到太多資訊，無法理解，進而產生有效的討論，或者造成不同層次的討論，最常看到的是現象是：</p><blockquote><p>TCP 跟 HTTP 放在一起討論，層次根本就搞錯了。<br>討論 狗 和 熱狗 的差異</p></blockquote><p>背後的問題： <code>如何有效表達</code> ，也就是說故事、或者是具象化表達的技巧，參閱 <a href="/2020/03/24/Management/Principles-of-Communication/">溝通原理</a></p><h3 id="1-5-準備不全"><a href="#1-5-準備不全" class="headerlink" title="1.5 準備不全"></a>1.5 準備不全</h3><p>為了時程，硬上。</p><h3 id="1-6-沒有結論"><a href="#1-6-沒有結論" class="headerlink" title="1.6 沒有結論"></a>1.6 沒有結論</h3><p>花了時間，卻沒有任何產出。</p><p>也不知道接下來要做什麼？後續應該怎麼跟進？</p><hr><h2 id="2-與會者的問題"><a href="#2-與會者的問題" class="headerlink" title="2. 與會者的問題"></a>2. 與會者的問題</h2><h3 id="2-1-沒有搞清楚會議主題就進來"><a href="#2-1-沒有搞清楚會議主題就進來" class="headerlink" title="2.1 沒有搞清楚會議主題就進來"></a>2.1 沒有搞清楚會議主題就進來</h3><p>被邀請，不管哪一場都參加。這種很容易出現在社會新鮮人。</p><p>通常一場會議參與者超過 10 個以上，其實都可以考慮不要出席。除非裡面有需要獲取的情報。</p><h3 id="2-2-不恰當的提問"><a href="#2-2-不恰當的提問" class="headerlink" title="2.2 不恰當的提問"></a>2.2 不恰當的提問</h3><ul><li>用封閉問題 (現場 &#x2F; 細節) 打 開放問題 (概念 &#x2F; 抽象)</li><li>或者反過來，用開放問題，對封閉問題</li><li>開放問題：這東西的定義是什麼？</li><li>封閉問題：這東西是不是什麼什麼？</li><li>問跟會議主軸無關的問題</li></ul><h3 id="2-3-沒有參與討論"><a href="#2-3-沒有參與討論" class="headerlink" title="2.3 沒有參與討論"></a>2.3 沒有參與討論</h3><p>Steve Jobs 在自傳中提到，會議的目的就是要參與討論，在會議中沒有參與討論、沒有發言，Steve Jobs 會請他出去。反之，當收到會議邀請時，如果這場會議主題跟自己沒關係，是不用免強參與的。</p><blockquote><p>沒有參與討論，另外一個潛在問題是：「企業有沒有營造一個讓員工願意發言的環境」，更深層的意涵是：「管理團對有沒有營造一個安全的發言空間？」</p></blockquote><h3 id="2-4-會前沒有先閱讀資料"><a href="#2-4-會前沒有先閱讀資料" class="headerlink" title="2.4 會前沒有先閱讀資料"></a>2.4 會前沒有先閱讀資料</h3><p>有些資訊，在會前就會送出來，節省大家開會的時間。所以當參與者沒有在會前先閱讀的時候，到會議詢問已經提供的資訊，就會變成很浪費時間。</p><h3 id="2-5-提過去問過，有結論的問題"><a href="#2-5-提過去問過，有結論的問題" class="headerlink" title="2.5 提過去問過，有結論的問題"></a>2.5 提過去問過，有結論的問題</h3><p>提出這問題的人，只要是高層，很有機會就會翻盤整個計畫。</p><p>有時候是高層的問題，要適度提醒；但有時候也是與會者自己的問題。</p><h3 id="2-6-中斷：沒有聽完就想講自己的想法"><a href="#2-6-中斷：沒有聽完就想講自己的想法" class="headerlink" title="2.6 中斷：沒有聽完就想講自己的想法"></a>2.6 中斷：沒有聽完就想講自己的想法</h3><p>很容易發生上對下的情境，上面的人 (通常是直屬主管) 很有想法 &#x2F; 經驗，但負責執行的人準備很久，還沒說完就被上面的人中斷，然後作結論。這種狀況，不見得都是主管的錯，但有的時候這樣的方式，會讓底下的人很受傷，甚至會對於跟主管溝通起了反感。這種上位者（管理、主管）都是造成團隊運作效率低效、團隊成員最後不敢做決策的主因。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="會議系列文"><a href="#會議系列文" class="headerlink" title="會議系列文"></a>會議系列文</h2><ol><li><a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></li><li><a href="/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/">開會原則</a></li><li><a href="/2019/08/25/Management/Problems-of-Meeting/">會議的普遍現象</a></li><li><a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></li><li><a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li></ol><h2 id="溝通"><a href="#溝通" class="headerlink" title="溝通"></a>溝通</h2><ul><li><a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li><li><a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="/2014/12/10/Management/%E6%BA%9D%E9%80%9A-%E6%88%90%E6%9C%AC/">溝通 &#x3D; 成本</a></li><li><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;原文是 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02wkn7qeuR29WFShcVFkBUmr9AfEbD96fwgjdvyZbigNjxVmy8xqti4AvFdqJebmiEl&quot;&gt;2021&amp;#x2F;06&amp;#x2F;14&lt;/a&gt; 寫下的 memo，摘錄一場失敗的會議有哪些現象，與另一篇 &lt;a href=&quot;/2020/10/11/Management/Effective-Meetings/&quot;&gt;一場有效的會議&lt;/a&gt; 成對比。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="溝通" scheme="https://rickhw.github.io/tags/%E6%BA%9D%E9%80%9A/"/>
    
    <category term="Bus Memo" scheme="https://rickhw.github.io/tags/Bus-Memo/"/>
    
    <category term="Meetings" scheme="https://rickhw.github.io/tags/Meetings/"/>
    
    <category term="時間管理" scheme="https://rickhw.github.io/tags/%E6%99%82%E9%96%93%E7%AE%A1%E7%90%86/"/>
    
    <category term="會議原則" scheme="https://rickhw.github.io/tags/%E6%9C%83%E8%AD%B0%E5%8E%9F%E5%89%87/"/>
    
    <category term="溝通成本" scheme="https://rickhw.github.io/tags/%E6%BA%9D%E9%80%9A%E6%88%90%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>新書上市 - 共同著作《軟體測試實務 I、II》</title>
    <link href="https://rickhw.github.io/2023/05/23/About/2023-Software-Test-Practice/"/>
    <id>https://rickhw.github.io/2023/05/23/About/2023-Software-Test-Practice/</id>
    <published>2023-05-23T13:42:30.000Z</published>
    <updated>2023-06-19T13:12:25.133Z</updated>
    
    <content type="html"><![CDATA[<p>2022 年初的時候，經過朋友的介紹認識成大資工系 <a href="https://researchoutput.ncku.edu.tw/zh/persons/shin-jie-lee">李信杰 教授</a>，因此才有了這本書的誕生。</p><p>李老師對軟體工程非常有熱情，特別是軟體測試領域，是全球最熱門開源測試軟體 Selenium IDE V3、Katalon Recorder 與 Qualys Recorder 原型創造者。</p><p><img src="/images/About/2023-swtesting/MP22255-3d.png"></p><span id="more"></span><h2 id="寫作的背後"><a href="#寫作的背後" class="headerlink" title="寫作的背後"></a>寫作的背後</h2><p>2022 年暑假，在老師的熱情邀 (ㄊㄨㄟ) 約 (ㄎㄥ) 之下，讓我有機會分享一場心路歷程：<a href="/2022/08/13/SQA/Path-to-Software-Testing/">從理想、到現實的距離，開啟品味軟體測試之路</a>，重新燃起對於軟體測試與品質的想法，然後也著手寫下多年積累的想法。</p><p>在這個過程中，同步進行的就是本文的主角，也就是《軟體測試實務》的共同著作，老師從收文、討論、到收稿、校稿、一校、二校、三校，定稿，確認出版。一路走來，跟著業界的前輩們一起努力，大家一條心，期望分享做寶貴的心得與經驗！</p><p>經過約半年的寫作，以及大約四個月的協作，終於確立出版，因為文章篇幅很多，所以分成一、二兩冊 (未來還會有三、四？)，過程中我邀請前同事，優秀的現任測試主管 - 師孝一起參與寫作，同時也貢獻了 Blog 上一些文章的內容 (後面羅列)，也把以前曾經想寫，但一直沒 (ㄊㄡ) 空 (ㄌㄢˇ) 寫的，完整的寫出來。</p><p>除了我自己的心得與想法，書本還有其他各大知名企業的團隊，大家貢獻的心得與經驗，希望大家的想法與經驗，可以為業界軟體帶來新的動能與不同的觀點。</p><h2 id="新書發表會的分享-updated-20230618"><a href="#新書發表會的分享-updated-20230618" class="headerlink" title="新書發表會的分享 (updated: 20230618)"></a>新書發表會的分享 (updated: 20230618)</h2><p>分享錄影：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/tk_yAHkFlkU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>分享簡報：</p><iframe src="https://www.slideshare.net/slideshow/embed_code/key/GRNOyyqJJt3YGg?hostedIn=slideshare&page=upload" width="476" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe><p>活動照片</p><p><img src="/images/About/2023-swtesting/LINE_ALBUM_230619_0.jpg"></p><p><img src="/images/About/2023-swtesting/LINE_ALBUM_230619_85.jpg"></p><p><img src="/images/About/2023-swtesting/LINE_ALBUM_230619_116.jpg"></p><h2 id="Rick-貢獻的內容與站內相關文章"><a href="#Rick-貢獻的內容與站內相關文章" class="headerlink" title="Rick 貢獻的內容與站內相關文章"></a>Rick 貢獻的內容與站內相關文章</h2><ul><li>第一冊 CH01 軟體測試工程師的職涯手冊<ul><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li><a href="/2015/08/20/SQA/Three-Kinds-Of-QA/">三種 QA (Quality Assurance)</a></li><li><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></li></ul></li><li>第一冊 CH05 從零開始，軟體測試團隊建立實戰<ul><li><a href="/2022/09/18/SQA/Integration-Test-and-Execution-Strategy/">整合測試與執行策略</a></li><li><a href="/2018/03/18/SQA/Gossip-System-Testing/">輕鬆聊：系統測試 (SVT) 的三兩事</a></li><li><a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li></ul></li><li>第二冊 CH01 Web Service系統容量量測的實務方法論<ul><li><a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？（壓測）</a></li></ul></li></ul><h2 id="相關資訊-amp-購買通路"><a href="#相關資訊-amp-購買通路" class="headerlink" title="相關資訊 &amp; 購買通路"></a>相關資訊 &amp; 購買通路</h2><ul><li><a href="https://sites.google.com/view/swtesting">書本官方網站</a></li><li>天瓏書局連結<ul><li><a href="https://www.tenlong.com.tw/products/9786263334854">軟體測試實務 : 業界成功案例與高效實踐 [ I ]</a></li><li><a href="https://www.tenlong.com.tw/products/9786263334861">軟體測試實務 : 業界成功案例與高效實踐 [ II ]</a></li></ul></li></ul><p><img src="/images/About/2023-swtesting/MP22256-3d.png"></p><p><img src="/images/About/2023-swtesting/swtesting0.png"><br><img src="/images/About/2023-swtesting/swtesting1.png"><br><img src="/images/About/2023-swtesting/swtesting2.png"></p><p><img src="/images/About/2023-swtesting/tenlong1.png"><br><img src="/images/About/2023-swtesting/tenlong2.png"></p><hr><h1 id="站內軟體測試相關文章"><a href="#站內軟體測試相關文章" class="headerlink" title="站內軟體測試相關文章"></a>站內軟體測試相關文章</h1><ul><li><a href="/2014/05/09/SQA/Problems_In-Software-Autotest/">軟體自動化測試常見的問題</a></li><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li><a href="/2015/08/20/SQA/Three-Kinds-Of-QA/">三種 QA</a></li><li><a href="/2017/12/03/SQA/Regression-Test-Is-Tough/">從 iOS 無限黑屏事件，淺談軟體測試階段 - 回歸測試 Regression Test</a></li><li><a href="/2017/08/30/DevOps/Automation-or-Process/">自動化 XXX 的陷阱</a></li><li><a href="/2018/03/18/SQA/Gossip-System-Testing/">輕鬆聊：系統測試 (SVT) 的三兩事</a></li><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li><li><a href="/2018/07/22/SQA/Performance-Test/">淺談效能測試</a></li><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2023/05/23/About/2023-Software-Test-Practice/">新書上市 - 共同著作《軟體測試實務 I、II》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022 年初的時候，經過朋友的介紹認識成大資工系 &lt;a href=&quot;https://researchoutput.ncku.edu.tw/zh/persons/shin-jie-lee&quot;&gt;李信杰 教授&lt;/a&gt;，因此才有了這本書的誕生。&lt;/p&gt;
&lt;p&gt;李老師對軟體工程非常有熱情，特別是軟體測試領域，是全球最熱門開源測試軟體 Selenium IDE V3、Katalon Recorder 與 Qualys Recorder 原型創造者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/About/2023-swtesting/MP22255-3d.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Books" scheme="https://rickhw.github.io/tags/Books/"/>
    
    <category term="Software Test" scheme="https://rickhw.github.io/tags/Software-Test/"/>
    
  </entry>
  
  <entry>
    <title>K8s 學習筆記 - 在 MacBook Pro M1 安裝 K3s</title>
    <link href="https://rickhw.github.io/2023/01/17/Container/Install-K3s-on-MBPR-M1/"/>
    <id>https://rickhw.github.io/2023/01/17/Container/Install-K3s-on-MBPR-M1/</id>
    <published>2023-01-17T01:41:58.000Z</published>
    <updated>2023-03-28T05:01:50.719Z</updated>
    
    <content type="html"><![CDATA[<p>在 Macbook Pro M1 (Apple Silicon) 安裝 K3s 的筆記。</p><span id="more"></span><hr><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><h2 id="K3d-vs-K3s"><a href="#K3d-vs-K3s" class="headerlink" title="K3d vs K3s"></a>K3d vs K3s</h2><p>K3d 其實是 <code>K3s in Docker</code> 的縮寫，也就是透過 docker 把 K8s 的角色跑起來，包含 api, kube-api, kube-proxy, coredns … 等。兩者的使用對象有所差異，整理如下：</p><ul><li>開發者：適合用 K3d 快速建立 cluster，測試自己的應用程式。<ul><li>如果要在 Apple Silicon 的環境使用 k8s，也可以用 k3d 就可以。</li></ul></li><li>K8s admin：適合用 K3s 設計與規劃 K8s cluster，模擬各種 cluster 的需求。</li></ul><p>K3s 的架構與原理如下圖：</p><p><img src="/images/Container/k3s/k3s-architecture-single-server.svg"></p><p>Source: <a href="https://docs.k3s.io/architecture">https://docs.k3s.io/architecture</a></p><p>類似於 dapr 的 hosted mode 與 cluster mode.</p><h2 id="Multipasss"><a href="#Multipasss" class="headerlink" title="Multipasss"></a>Multipasss</h2><p><a href="https://multipass.run/">multipass</a> 是 ubuntu 的公司出的，針對 ubuntu 在三大作業系統上可以順利運行 ubuntu vm 的工具，本身提供的 ubuntu image 也是輕量化過的。</p><h3 id="安裝-multipass"><a href="#安裝-multipass" class="headerlink" title="安裝 multipass"></a>安裝 multipass</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">❯ brew install --cask multipass</span><br><span class="line">Running `brew update --auto-update`...</span><br><span class="line">==&gt; Auto-updated Homebrew!</span><br><span class="line">Updated 1 tap (homebrew/core).</span><br><span class="line">==&gt; New Formulae</span><br><span class="line">aptos          cargo-about    ecoji          grayskull      kwctl          podsync        twm            xorg-server</span><br><span class="line">aws-sam-cli    cargo-deny     fgbio          jbang          mpfrcx         quartz-wm      video-compare  xrdb</span><br><span class="line">bossa          cascadia       flagd          jreleaser      ocm            ruby@3.1       xinit</span><br><span class="line">bzip3          cdebug         gokey          kubent         openvino       simdutf        xmodmap</span><br><span class="line"></span><br><span class="line">You have 3 outdated formulae installed.</span><br><span class="line">You can upgrade them with brew upgrade</span><br><span class="line">or list them with brew outdated.</span><br><span class="line"></span><br><span class="line">==&gt; Tapping homebrew/cask</span><br><span class="line">Cloning into <span class="string">&#x27;/opt/homebrew/Library/Taps/homebrew/homebrew-cask&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 702522, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (57/57), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (41/41), <span class="keyword">done</span>.</span><br><span class="line">Receiving objects:  39% (273984/702522), 98.74 MiB | 3.09 MiB/s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==&gt; Installing Cask multipass</span><br><span class="line">==&gt; Running installer <span class="keyword">for</span> multipass; your password may be necessary.</span><br><span class="line">Package installers may write to any location; options such as `--appdir` are ignored.</span><br><span class="line">Password:</span><br><span class="line">installer: Package name is multipass</span><br><span class="line">installer: Installing at base path /</span><br><span class="line">installer: The install was successful.</span><br><span class="line">🍺  multipass was successfully installed!</span><br></pre></td></tr></table></figure><p>基本的使用參數：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">❯ multipass version</span><br><span class="line">multipass   1.10.1+mac</span><br><span class="line">multipassd  1.10.1+mac</span><br><span class="line"></span><br><span class="line"><span class="comment">## Help</span></span><br><span class="line">❯ multipass <span class="built_in">help</span></span><br><span class="line">Usage: multipass [options] &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">Create, control and connect to Ubuntu instances.</span><br><span class="line"></span><br><span class="line">This is a <span class="built_in">command</span> line utility <span class="keyword">for</span> multipass, a</span><br><span class="line">service that manages Ubuntu instances.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看 launch 的 help</span></span><br><span class="line">❯ multipass <span class="built_in">help</span> launch</span><br><span class="line">Usage: multipass launch [options] [[&lt;remote:&gt;]&lt;image&gt; | &lt;url&gt;]</span><br><span class="line">Create and start a new instance.</span><br><span class="line"></span><br><span class="line"><span class="comment">## 提供哪一些 Images</span></span><br><span class="line">❯ multipass find</span><br><span class="line">Image                       Aliases           Version          Description</span><br><span class="line">snapcraft:core18            18.04             20201111         Snapcraft builder <span class="keyword">for</span> Core 18</span><br><span class="line">snapcraft:core20            20.04             20210921         Snapcraft builder <span class="keyword">for</span> Core 20</span><br><span class="line">snapcraft:core22            22.04             20220426         Snapcraft builder <span class="keyword">for</span> Core 22</span><br><span class="line">18.04                       bionic            20230112         Ubuntu 18.04 LTS</span><br><span class="line">20.04                       focal             20230111         Ubuntu 20.04 LTS</span><br><span class="line">22.04                       jammy,lts         20230107         Ubuntu 22.04 LTS</span><br><span class="line">anbox-cloud-appliance                         latest           Anbox Cloud Appliance</span><br><span class="line">charm-dev                                     latest           A development and testing environment <span class="keyword">for</span> charmers</span><br><span class="line">docker                                        latest           A Docker environment with Portainer and related tools</span><br><span class="line">jellyfin                                      latest           Jellyfin is a Free Software Media System that puts you <span class="keyword">in</span> control of managing and streaming your media.</span><br><span class="line">minikube                                      latest           minikube is <span class="built_in">local</span> Kubernetes</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="啟動虛擬機"><a href="#啟動虛擬機" class="headerlink" title="啟動虛擬機"></a>啟動虛擬機</h3><p>透過 multipass 啟動一個虛擬機，指定虛擬機名稱、記憶體、Disk、CPU 數量、網路模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">❯ multipass launch --name k3s-main \</span><br><span class="line">    --mem 4G --disk 20G \</span><br><span class="line">    --cpus 2</span><br><span class="line"></span><br><span class="line">Launched: k3s-main</span><br><span class="line"></span><br><span class="line">❯ multipass info k3s-main</span><br><span class="line">Name:           k3s-main</span><br><span class="line">State:          Running</span><br><span class="line">IPv4:           192.168.64.3</span><br><span class="line">Release:        Ubuntu 22.04.1 LTS</span><br><span class="line">Image <span class="built_in">hash</span>:     3100a27357a0 (Ubuntu 22.04 LTS)</span><br><span class="line">Load:           0.88 0.37 0.14</span><br><span class="line">Disk usage:     2.4G out of 19.2G</span><br><span class="line">Memory usage:   749.0M out of 3.8G</span><br><span class="line">Mounts:         --</span><br><span class="line"></span><br><span class="line">❯ <span class="built_in">mkdir</span> -p ~/Temp/K8s</span><br><span class="line"></span><br><span class="line"><span class="comment">## 掛載磁碟: Host Machine to Virtual Machine</span></span><br><span class="line">❯ multipass mount ~/Temp/K8s k3s:~/k8s</span><br><span class="line">Enabling support <span class="keyword">for</span> mounting \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 刪除虛擬機</span></span><br><span class="line">❯ multipass delete k3s-main</span><br><span class="line">❯ multipass purge</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>進去虛擬機</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">❯ multipass shell k3s-main</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看 disk 狀況</span></span><br><span class="line">ubuntu@k3s-main:~$ <span class="built_in">df</span> -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">tmpfs           393M  864K  392M   1% /run</span><br><span class="line">/dev/vda1        20G  1.9G   18G  10% /</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">/dev/vda15      105M  5.3M  100M   5% /boot/efi</span><br><span class="line">tmpfs           393M  4.0K  393M   1% /run/user/1000</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看 CPU 狀況, 需要安裝 apt install cpuinfo</span></span><br><span class="line">ubuntu@k3s-main:~$ cpu-info</span><br><span class="line">Packages:</span><br><span class="line">0: Intel Core i9-9900K</span><br><span class="line">1: Intel Core i9-9900K</span><br><span class="line">Microarchitectures:</span><br><span class="line">2x Sky Lake</span><br><span class="line">Cores:</span><br><span class="line">0: 1 processor (0), Intel Sky Lake</span><br><span class="line">1: 1 processor (1), Intel Sky Lake</span><br><span class="line">Logical processors (System ID):</span><br><span class="line">0 (0): APIC ID 0x00000000</span><br><span class="line">1 (1): APIC ID 0x00000001</span><br></pre></td></tr></table></figure><p>整理幾個 multipass 運作的資訊：</p><ul><li>multipass 程序主要工作在 <code>/Library/Application Support/com.canonical.multipass</code></li><li>multipass 預設使用 <code>qemu</code> 為 Hypervisor，虛擬磁碟為 COW2 格式，網路為 Bridge 模式</li><li>虛擬機的預設路徑為：<code>/var/root/Library/Application Support/multipassd/</code> (需要 root 權限才能存取)</li><li>multipass 預設透過 luanchd 跟著作業系統啟動<ul><li>配置檔位置： <code>/Library/LaunchDaemons/com.canonical.multipassd.plist</code></li></ul></li></ul><hr><h1 id="安裝-K3s"><a href="#安裝-K3s" class="headerlink" title="安裝 K3s"></a>安裝 K3s</h1><h2 id="直接安裝"><a href="#直接安裝" class="headerlink" title="直接安裝"></a>直接安裝</h2><p>如果在 macOS 直接安裝 k3s 會出現以下訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ curl -sfL https://get.k3s.io | sh -</span><br><span class="line">[ERROR]  Can not find systemd or openrc to use as a process supervisor <span class="keyword">for</span> k3s</span><br></pre></td></tr></table></figure><p>不管是 Intel or Apple Silicon 都是。</p><h2 id="在-VM-裡面安裝-K3s"><a href="#在-VM-裡面安裝-K3s" class="headerlink" title="在 VM 裡面安裝 K3s"></a>在 VM 裡面安裝 K3s</h2><p>透過 multipass 裝起好一台 VM 之後，進去裡面再安裝 K3s 就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在虛擬機裡面</span></span><br><span class="line">root@k3s:~<span class="comment"># curl -sfL https://get.k3s.io | sh -</span></span><br><span class="line">[INFO]  Finding release <span class="keyword">for</span> channel stable</span><br><span class="line">[INFO]  Using v1.25.5+k3s2 as release</span><br><span class="line">[INFO]  Downloading <span class="built_in">hash</span> https://github.com/k3s-io/k3s/releases/download/v1.25.5+k3s2/sha256sum-arm64.txt</span><br><span class="line">[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.25.5+k3s2/k3s-arm64</span><br><span class="line">[INFO]  Verifying binary download</span><br><span class="line">[INFO]  Installing k3s to /usr/local/bin/k3s</span><br><span class="line">[INFO]  Skipping installation of SELinux RPM</span><br><span class="line">[INFO]  Creating /usr/local/bin/kubectl symlink to k3s</span><br><span class="line">[INFO]  Creating /usr/local/bin/crictl symlink to k3s</span><br><span class="line">[INFO]  Creating /usr/local/bin/ctr symlink to k3s</span><br><span class="line">[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh</span><br><span class="line">[INFO]  Creating uninstall script /usr/local/bin/k3s-uninstall.sh</span><br><span class="line">[INFO]  <span class="built_in">env</span>: Creating environment file /etc/systemd/system/k3s.service.env</span><br><span class="line">[INFO]  systemd: Creating service file /etc/systemd/system/k3s.service</span><br><span class="line">[INFO]  systemd: Enabling k3s unit</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/k3s.service → /etc/systemd/system/k3s.service.</span><br><span class="line">[INFO]  systemd: Starting k3se</span><br><span class="line"></span><br><span class="line"><span class="comment">## 確認 K8s 安裝的狀況</span></span><br><span class="line">ubuntu@k3s-main:~$ sudo kubectl get po,no --all-namespaces</span><br><span class="line">NAMESPACE     NAME                                          READY   STATUS      RESTARTS   AGE</span><br><span class="line">kube-system   pod/local-path-provisioner-79f67d76f8-w946b   1/1     Running     0          8m15s</span><br><span class="line">kube-system   pod/coredns-597584b69b-9mx2w                  1/1     Running     0          8m15s</span><br><span class="line">kube-system   pod/metrics-server-5f9f776df5-p826z           1/1     Running     0          8m15s</span><br><span class="line">kube-system   pod/helm-install-traefik-crd-bq27h            0/1     Completed   0          8m15s</span><br><span class="line">kube-system   pod/helm-install-traefik-b6vb4                0/1     Completed   1          8m15s</span><br><span class="line">kube-system   pod/svclb-traefik-09095d96-v9fpk              2/2     Running     0          7m45s</span><br><span class="line">kube-system   pod/traefik-66c46d954f-r48tq                  1/1     Running     0          7m45s</span><br><span class="line"></span><br><span class="line">NAMESPACE   NAME            STATUS   ROLES                  AGE     VERSION</span><br><span class="line">            node/k3s-main   Ready    control-plane,master   8m31s   v1.25.5+k3s2</span><br><span class="line"></span><br><span class="line">ubuntu@k3s-main:~$ sudo kubectl api-resources</span><br><span class="line">NAME                              SHORTNAMES   APIVERSION                             NAMESPACED   KIND</span><br><span class="line">bindings                                       v1                                     <span class="literal">true</span>         Binding</span><br><span class="line">componentstatuses                 cs           v1                                     <span class="literal">false</span>        ComponentStatus</span><br><span class="line">configmaps                        cm           v1                                     <span class="literal">true</span>         ConfigMap</span><br><span class="line">endpoints                         ep           v1                                     <span class="literal">true</span>         Endpoints</span><br><span class="line">events                            ev           v1                                     <span class="literal">true</span>         Event</span><br><span class="line">... 略 ...</span><br><span class="line"></span><br><span class="line">ubuntu@k3s-main:~$ sudo kubectl get rs --all-namespaces</span><br><span class="line">NAMESPACE     NAME                                DESIRED   CURRENT   READY   AGE</span><br><span class="line">kube-system   local-path-provisioner-79f67d76f8   1         1         1       10m</span><br><span class="line">kube-system   coredns-597584b69b                  1         1         1       10m</span><br><span class="line">kube-system   metrics-server-5f9f776df5           1         1         1       10m</span><br><span class="line">kube-system   traefik-66c46d954f                  1         1         1       10m</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在 Host Machine，取得 K8s 的 Node Token</span></span><br><span class="line">❯ multipass <span class="built_in">exec</span> k3s-main sudo <span class="built_in">cat</span> /var/lib/rancher/k3s/server/node-token</span><br><span class="line">K1082f1ce868a513c55999a7eba68ab888dc2035baf2323131466364f65bf5f0220::server:27b105f74351819669c0481da7c87baa</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在 Master Node 裏取得 KubeConfig</span></span><br><span class="line"><span class="comment">## 如果要在 Master Node 之外使用，複製檔案內容後，</span></span><br><span class="line"><span class="comment">## 記得把 server: https://127.0.0.1:6443 改成 Master Node 的 IP</span></span><br><span class="line"><span class="built_in">cat</span> /etc/rancher/k3s/k3s.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="新增-Worker-Node"><a href="#新增-Worker-Node" class="headerlink" title="新增 Worker Node"></a>新增 Worker Node</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">multipass launch --name k3s-worker1 --mem 2G --disk 20G</span><br><span class="line">multipass launch --name k3s-worker2 --mem 2G --disk 20G</span><br><span class="line"></span><br><span class="line">multipass shell k3s-worker1</span><br><span class="line">multipass shell k3s-worker2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 進去 VM 裡</span></span><br><span class="line">curl -sfL https://get.k3s.io | K3S_URL=https://192.168.64.3:6443 K3S_TOKEN=<span class="string">&quot;K102a46f234cf614bd49a50092389d8e03fed00618846936782fbdae904c32ee9d5::server:5fc3190151a2de0126199cc6fbd94acf&quot;</span> sh -</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在 Master Node</span></span><br><span class="line">ubuntu@k3s-main:~$ sudo kubectl get no</span><br><span class="line">NAME          STATUS   ROLES                  AGE   VERSION</span><br><span class="line">k3s-main      Ready    control-plane,master   65m   v1.25.5+k3s2</span><br><span class="line">k3s-worker1   Ready    &lt;none&gt;                 75s   v1.25.5+k3s2</span><br><span class="line">k3s-worker2   Ready    &lt;none&gt;                 2s    v1.25.5+k3s2</span><br></pre></td></tr></table></figure><h2 id="移除-Worker-Node"><a href="#移除-Worker-Node" class="headerlink" title="移除 Worker Node"></a>移除 Worker Node</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain k3s-worker --delete-emptydir-data --force --ignore-daemonsets</span><br><span class="line"></span><br><span class="line">root@k3s:~<span class="comment"># kubectl delete node k3s-worker</span></span><br><span class="line">node <span class="string">&quot;k3s-worker&quot;</span> deleted</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h1><p>底下都在 k3s-master node 裡面執行。</p><p>建立測試網頁: <code>index.html</code>，內容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把這個 HTML 設定成 configmap:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ kubectl create configmap hello-world --from-file index.html</span><br></pre></td></tr></table></figure><p>建立 K8s YAML:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;traefik&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span>  <span class="string">hello-world</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello-world-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">hello-world</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world-volume</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world-volume</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">hello-world</span></span><br></pre></td></tr></table></figure><p>執行這段 YAML </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ kubectl apply -f hello-world.yml</span><br><span class="line">~$ kubectl get po</span><br><span class="line">NAME                                 READY   STATUS    RESTARTS   AGE</span><br><span class="line">hello-world-nginx-5876d86d96-k2mm6   1/1     Running   0          4m25s</span><br><span class="line">hello-world-nginx-5876d86d96-krsrh   1/1     Running   0          4m25s</span><br><span class="line">hello-world-nginx-5876d86d96-wq9hf   1/1     Running   0          4m25s</span><br></pre></td></tr></table></figure><p>測試：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~$ curl localhost:80</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">  &lt;title&gt;Hello World!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;Hello World!&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h1><h2 id="Q-可以把-master-和-worker-node-裝在同一台-VM"><a href="#Q-可以把-master-和-worker-node-裝在同一台-VM" class="headerlink" title="Q: 可以把 master 和 worker node 裝在同一台 VM?"></a>Q: 可以把 master 和 worker node 裝在同一台 VM?</h2><p>不可以，Port 會出現衝突，要裝在同一台 VM，就用 K3d</p><p>如果已經執行了，記得跑 <code>k3s-agent-uninstall.sh</code> 或者 <code>k3s-uninstall.sh</code> 刪掉造成衝突的一方，然後重新啟動 service 即可: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start k3s.service</span><br><span class="line">systemctl status k3s.service</span><br></pre></td></tr></table></figure><!--## 安裝 K3d如果想透過<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">❯ curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash</span><br><span class="line"></span><br><span class="line">Preparing to install k3d into /usr/local/bin</span><br><span class="line">Password:</span><br><span class="line">k3d installed into /usr/local/bin/k3d</span><br><span class="line">Run <span class="string">&#x27;k3d --help&#x27;</span> to see what you can <span class="keyword">do</span> with it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 建立 Cluster -- 有啟動 docker</span></span><br><span class="line">❯ k3d cluster create mycluster</span><br><span class="line">INFO[0000] Prep: Network</span><br><span class="line">INFO[0000] Created network <span class="string">&#x27;k3d-mycluster&#x27;</span></span><br><span class="line">INFO[0000] Created image volume k3d-mycluster-images</span><br><span class="line">INFO[0000] Starting new tools node...</span><br><span class="line">INFO[0001] Creating node <span class="string">&#x27;k3d-mycluster-server-0&#x27;</span></span><br><span class="line">INFO[0002] Pulling image <span class="string">&#x27;ghcr.io/k3d-io/k3d-tools:5.4.6&#x27;</span></span><br><span class="line">INFO[0004] Pulling image <span class="string">&#x27;docker.io/rancher/k3s:v1.24.4-k3s1&#x27;</span></span><br><span class="line">INFO[0016] Creating LoadBalancer <span class="string">&#x27;k3d-mycluster-serverlb&#x27;</span></span><br><span class="line">INFO[0018] Pulling image <span class="string">&#x27;ghcr.io/k3d-io/k3d-proxy:5.4.6&#x27;</span></span><br><span class="line">INFO[0027] Starting Node <span class="string">&#x27;k3d-mycluster-tools&#x27;</span></span><br><span class="line">INFO[0028] Using the k3d-tools node to gather environment information</span><br><span class="line">INFO[0028] Starting new tools node...</span><br><span class="line">INFO[0028] Starting Node <span class="string">&#x27;k3d-mycluster-tools&#x27;</span></span><br><span class="line">INFO[0030] Starting cluster <span class="string">&#x27;mycluster&#x27;</span></span><br><span class="line">INFO[0030] Starting servers...</span><br><span class="line">INFO[0030] Starting Node <span class="string">&#x27;k3d-mycluster-server-0&#x27;</span></span><br><span class="line">INFO[0033] All agents already running.</span><br><span class="line">INFO[0033] Starting helpers...</span><br><span class="line">INFO[0033] Starting Node <span class="string">&#x27;k3d-mycluster-serverlb&#x27;</span></span><br><span class="line">INFO[0039] Injecting records <span class="keyword">for</span> hostAliases (incl. host.k3d.internal) and <span class="keyword">for</span> 3 network members into CoreDNS configmap...</span><br><span class="line">INFO[0042] Cluster <span class="string">&#x27;mycluster&#x27;</span> created successfully!</span><br><span class="line">INFO[0042] You can now use it like this:</span><br><span class="line">kubectl cluster-info</span><br><span class="line"></span><br><span class="line"><span class="comment">## 建立 Cluster -- 沒有啟動 docker</span></span><br><span class="line">❯ k3d cluster create mycluster</span><br><span class="line">ERRO[0000] Failed to get nodes <span class="keyword">for</span> cluster <span class="string">&#x27;mycluster&#x27;</span>: docker failed to get containers with labels <span class="string">&#x27;map[k3d.cluster:mycluster]&#x27;</span>: failed to list containers: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">INFO[0000] Prep: Network</span><br><span class="line">ERRO[0000] Failed Cluster Preparation: Failed Network Preparation: failed to create cluster network: failed to check <span class="keyword">for</span> duplicate docker networks: docker failed to list networks: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">ERRO[0000] Failed to create cluster &gt;&gt;&gt; Rolling Back</span><br><span class="line">INFO[0000] Deleting cluster <span class="string">&#x27;mycluster&#x27;</span></span><br><span class="line">ERRO[0000] Failed to get nodes <span class="keyword">for</span> cluster <span class="string">&#x27;mycluster&#x27;</span>: docker failed to get containers with labels <span class="string">&#x27;map[k3d.cluster:mycluster]&#x27;</span>: failed to list containers: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br><span class="line">ERRO[0000] failed to get cluster: No nodes found <span class="keyword">for</span> given cluster</span><br><span class="line">FATA[0000] Cluster creation FAILED, also FAILED to rollback changes!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 刪除 K3d cluster</span></span><br><span class="line">❯ k3d cluster delete mycluster</span><br><span class="line">INFO[0000] Deleting cluster <span class="string">&#x27;mycluster&#x27;</span></span><br><span class="line">INFO[0000] Deleting cluster network <span class="string">&#x27;k3d-mycluster&#x27;</span></span><br><span class="line">INFO[0000] Deleting 2 attached volumes...</span><br><span class="line">WARN[0000] Failed to delete volume <span class="string">&#x27;k3d-mycluster-images&#x27;</span> of cluster <span class="string">&#x27;mycluster&#x27;</span>: failed to find volume <span class="string">&#x27;k3d-mycluster-images&#x27;</span>: Error: No such volume: k3d-mycluster-images -&gt; Try to delete it manually</span><br><span class="line">INFO[0000] Removing cluster details from default kubeconfig...</span><br><span class="line">INFO[0000] Removing standalone kubeconfig file (<span class="keyword">if</span> there is one)...</span><br><span class="line">INFO[0000] Successfully deleted cluster mycluster!</span><br></pre></td></tr></table></figure><p>–&gt;</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章：K8s-相關"><a href="#站內文章：K8s-相關" class="headerlink" title="站內文章：K8s 相關"></a>站內文章：K8s 相關</h2><ul><li><a href="/2017/07/15/Container/Experience-minikube/">Experience minikube</a></li><li><a href="/2021/09/23/AWS/Experience-EKS-Anywhere/">Experience EKS Anywhere</a></li><li><a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></li><li><a href="/2019/03/17/Container/Install-Addons-For-K8s/">K8s 學習筆記 - 工具篇</a></li><li><a href="/2019/03/17/Container/Admin-Maintenance-And-Troubleshooting-K8s/">K8s 學習筆記 - 維護與常見問題</a></li><li><a href="/2019/10/13/AWS/Study-Notes-EKS_Provision-Cluster/">EKS 學習筆記 - 基礎安裝篇</a></li><li><a href="/2019/10/19/AWS/Study-Notes-EKS_Networking/">EKS 學習筆記 - 網路規劃與管理篇</a></li></ul><h2 id="VPC-網路規劃"><a href="#VPC-網路規劃" class="headerlink" title="VPC - 網路規劃"></a>VPC - 網路規劃</h2><ul><li><a href="/2016/02/21/AWS/Study-Notes-VPC/">Study Notes - Virtual Private Cloud (VPC)</a></li><li><a href="/2018/04/08/GCP/Building-a-VPN-Between-GCP-and-AWS/">Building a VPN Between GCP and AWS</a></li><li><a href="/2017/02/04/AWS/Study-Notes-EC2-Auto-Scaling/">Study Notes - EC2 Auto Scaling 基礎介紹</a></li><li><a href="/2017/07/07/AWS/Plan-And-Deisgn-Multiple-VPCs-in-Different-Regions/">Plan and Design Multiple VPCs in Different Regions</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://dev.to/chillaranand/local-kubernetes-cluster-with-k3s-on-mac-m1-i57">https://dev.to/chillaranand/local-kubernetes-cluster-with-k3s-on-mac-m1-i57</a></li><li><a href="https://dev.to/sr229/how-to-use-nginx-ingress-controller-in-k3s-2ck2">https://dev.to/sr229/how-to-use-nginx-ingress-controller-in-k3s-2ck2</a></li><li><a href="https://zhuanlan.zhihu.com/p/435237515">Multipass 对已经存在的实例进行调整</a></li><li><a href="https://www.jeffgeerling.com/blog/2022/quick-hello-world-http-deployment-testing-k3s-and-traefik">https://www.jeffgeerling.com/blog/2022/quick-hello-world-http-deployment-testing-k3s-and-traefik</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Macbook Pro M1 (Apple Silicon) 安裝 K3s 的筆記。&lt;/p&gt;</summary>
    
    
    
    <category term="Container" scheme="https://rickhw.github.io/categories/Container/"/>
    
    
    <category term="Kubernetes" scheme="https://rickhw.github.io/tags/Kubernetes/"/>
    
    <category term="Ubuntu" scheme="https://rickhw.github.io/tags/Ubuntu/"/>
    
    <category term="K8s" scheme="https://rickhw.github.io/tags/K8s/"/>
    
    <category term="Macbook Pro M1" scheme="https://rickhw.github.io/tags/Macbook-Pro-M1/"/>
    
    <category term="Apple Silicon" scheme="https://rickhw.github.io/tags/Apple-Silicon/"/>
    
    <category term="multipass" scheme="https://rickhw.github.io/tags/multipass/"/>
    
    <category term="docker" scheme="https://rickhw.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>AWS Career Exploration Day 2022</title>
    <link href="https://rickhw.github.io/2022/12/21/About/2022-AWS-Career-Exploration-Day/"/>
    <id>https://rickhw.github.io/2022/12/21/About/2022-AWS-Career-Exploration-Day/</id>
    <published>2022-12-21T13:42:30.000Z</published>
    <updated>2023-05-27T05:00:22.169Z</updated>
    
    <content type="html"><![CDATA[<p>這是一場很特別的活動：<a href="https://pages.awscloud.com/20221121-tw-career-day.html">雲端職涯探索日</a> (<a href="https://events.104.com.tw/aws/20221201/">104專區</a>)，第一時間 AWS 的邀請我就毫不猶豫的答應了 XDD</p><span id="more"></span><h2 id="Slide-與錄影"><a href="#Slide-與錄影" class="headerlink" title="Slide 與錄影"></a>Slide 與錄影</h2><p>沒有來現場的朋友，可以透過以下的 Slide 與錄影回看內容：</p><iframe src="//www.slideshare.net/slideshow/embed_code/key/3Aqb5R8P5ZJTTN" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/rickhwang/aws-career-exploration-day" title="AWS Career Exploration Day" target="_blank">AWS Career Exploration Day</a> </strong> from <strong><a href="//www.slideshare.net/rickhwang" target="_blank">Rick Hwang</a></strong> </div><p>錄影 (iPad 直接錄影，收音)</p><iframe width="560" height="315" src="https://www.youtube.com/embed/q-58KOHbGSY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><hr><h2 id="重點摘要"><a href="#重點摘要" class="headerlink" title="重點摘要"></a>重點摘要</h2><ol><li>從問題中出發，解決問題、探索需要的技能</li><li>為自己的技能抓一個目標：考證照</li></ol><p><img src="/images/About/2022-AWSCareerExplorationDay/Slide1.png"><br><img src="/images/About/2022-AWSCareerExplorationDay/Slide2.png"><br><img src="/images/About/2022-AWSCareerExplorationDay/Slide3.png"><br><img src="/images/About/2022-AWSCareerExplorationDay/Slide4.png"></p><h3 id="現場問答-一-：問問題，找答案"><a href="#現場問答-一-：問問題，找答案" class="headerlink" title="現場問答 (一)：問問題，找答案"></a>現場問答 (一)：問問題，找答案</h3><p>在現場攤位有一些朋友來問準備考試的方向，類似問題我統一把當下講的東西，重點敲下來，關鍵就是：</p><blockquote><p>問問題，找答案。</p></blockquote><p>這個過程，才是從不會、到會的學習過程。</p><p>現場我給了我的標準面試考題：<code>短網址</code>、<code>縮網址</code>，關鍵字是 <code>Short URL</code>。這個題目可以從開發 (寫程式) 角度、從架構設計角度、從維運角度，都可以切入；可以用 AWS 服務組出來，也可以完全自幹。</p><p>依照我要用人的職務、角色不一樣，我會有不同問法。例如要找 Cloud Engineer，就會看看如何用 AWS 服務做出來，而且考慮可靠度、效能、成本、資安 … 等因素。如果是面試開發工程師，如果他也懂 AWS，那我就會說：設計不能用 AWS Lambda (Serverless)，要怎麼做架構設計？怎麼做系統設計？</p><p>同樣，會真實情境去思考問題，例如短網址最常拿來用什麼？Line 廣告推播，例如某個商品特價了、新商品上架優惠 … 通常會有瞬間巨量 (或叫高併發)，怎麼利用 AWS 的服務，組出一個滿足這樣需求的設計？</p><p>養分來自於問題，問題的深度與廣度，會決定學習的方向。</p><p>現場很多朋友是剛出社會、或者尚未出社會，我的建議就是：</p><blockquote><p>先做出來再說。</p></blockquote><p>不管啥方式，先把短網址這個功能做出來，先能用了，再來開始挑戰。如果不知道短網址是啥，那就趕快去 google ~</p><h3 id="現場問答-二-：探索自己"><a href="#現場問答-二-：探索自己" class="headerlink" title="現場問答 (二)：探索自己"></a>現場問答 (二)：探索自己</h3><p>現場另一類的問題是，不知道自己下一步要做什麼？要繼續做開發？還是碰 AWS？要做資料分析？還是做維運？</p><p>更多看這篇： <a href="/2021/09/10/About/Self-Exploration/">職涯、探索、退休</a></p><h2 id="相關文章"><a href="#相關文章" class="headerlink" title="相關文章"></a>相關文章</h2><p>這場主軸是職涯 (Career)，構思內容的出發點是從 “<a href="/2021/09/10/About/Self-Exploration/">職涯、探索、退休</a>“、”<a href="/2018/08/20/Management/Overview-Hiring/">聊聊人力招募</a>“ 這兩篇出發，然後再扣回主辦單位想要的考證照，以 “<a href="/2019/08/14/About/About-Certificate/">證照有無用論？</a>“ 為主軸，真實案例是 “<a href="/2016/10/10/AWS/Migrate-to-AWS-NAT-Gateway/">Migrate to AWS NAT Gateway</a>“ 這篇。其他更多還有以下：</p><ul><li><a href="/2020/06/21/Management/Interview-Problems/">面試常見的問題</a></li><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2016/10/01/AWS-Study-Roadmap/">AWS Study Roadmap</a></li><li><a href="/2016/08/20/AWS/AWS-Certified-Developer/">AWS Certified Developer - Associate 準備心得</a></li><li><a href="/2016/07/29/AWS/AWS-Certified-SysOps-Administrator/">AWS Certified SysOps Administrator - Associate 準備心得</a></li><li><a href="/2016/04/22/AWS/AWS-Certified-Solutions-Architect_Associate/">AWS Certified Solutions Architect - Associate 準備心得</a></li><li><a href="/2019/01/12/About/Talent-And-Effort/">天賦與努力</a></li></ul><h2 id="照片-by-主辦單位-AWS"><a href="#照片-by-主辦單位-AWS" class="headerlink" title="照片 by 主辦單位 (AWS)"></a>照片 by 主辦單位 (AWS)</h2><p>這次活動 AWS 籌辦很久，其中最辛苦的莫過於負責活動的 Pamela，過程中很有耐心跟我討論內容，很慎重的 rehearsal 活動 rundown 流程 (這些過程我真的都滿熟的 XD) ～</p><p>感謝推坑的老朋友 Cliff、認識的新朋友 - 另一位 Scott (Data)、Carol，很久沒碰面的 Roy、來攤位詢問職涯的朋友、SRE 社群的朋友、前同事 Viola … (認親大會嗎 XDD)</p><p><img src="/images/About/2022-AWSCareerExplorationDay/IMG_6549.JPG"></p><p><img src="/images/About/2022-AWSCareerExplorationDay/IMG_6553.JPG"></p><h2 id="相關連結"><a href="#相關連結" class="headerlink" title="相關連結"></a>相關連結</h2><ul><li><a href="https://pages.awscloud.com/20221121-tw-career-day.html">雲端職涯探索日</a></li><li><a href="https://events.104.com.tw/aws/20221201/">104專區</a></li><li><a href="https://buzzorange.com/techorange/2023/03/01/aws-people-3/">雲端大鬧人才荒！如何加速職涯跳轉、成為搶破頭的雲端人才？</a> - Updated: 2023&#x2F;03&#x2F;06</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;這是一場很特別的活動：&lt;a href=&quot;https://pages.awscloud.com/20221121-tw-career-day.html&quot;&gt;雲端職涯探索日&lt;/a&gt; (&lt;a href=&quot;https://events.104.com.tw/aws/20221201/&quot;&gt;104專區&lt;/a&gt;)，第一時間 AWS 的邀請我就毫不猶豫的答應了 XDD&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="AWS" scheme="https://rickhw.github.io/tags/AWS/"/>
    
    <category term="Career" scheme="https://rickhw.github.io/tags/Career/"/>
    
    <category term="Certiciation" scheme="https://rickhw.github.io/tags/Certiciation/"/>
    
  </entry>
  
  <entry>
    <title>和艦長一起 30 天玩轉 GitLab【第二版】- 推薦序完整版</title>
    <link href="https://rickhw.github.io/2022/11/19/About/Gitlab-Recommand/"/>
    <id>https://rickhw.github.io/2022/11/19/About/Gitlab-Recommand/</id>
    <published>2022-11-19T13:42:30.000Z</published>
    <updated>2023-05-01T04:17:19.423Z</updated>
    
    <content type="html"><![CDATA[<p>只要是軟體開發，不管 Web Services、還是 Mobile 或 Desktop Application，都會需要建置 (Build) 與交付 (Delivery) 兩個核心過程。Web Services 的交付稱為部署 (Deployment)，應用程式稱為發佈 (Publish)。而這些過程，也伴隨著一些衍生的任務 (Task)，組成一連串的行為，隨著時間的推進，架構的改變，這些任務的組合，往往是工程師們的夢靨的開始。</p><span id="more"></span><h2 id="走過的路"><a href="#走過的路" class="headerlink" title="走過的路"></a>走過的路</h2><p>在 git 還沒開始流行之前，我早期在 IBM 工作時使用的 <a href="https://en.wikipedia.org/wiki/IBM_Configuration_Management_Version_Control_(CMVC)">CMVC</a> 這套 IBM 自行開發的整合性 SCM <sup>註</sup>，它整合了 Issue Tracking System (ITS)、Build Procedure、Unit Test、Integration Test、Source Control 等 … 完美整合，分支策略以 Trunk Based 為主，每個 Commit 都一定根據 Issue Number。通常 Commit 一定要基於 Feature Ticket 或者 Defect &#x2F; Bug Number。</p><blockquote><p>註： SCM: Source Code Mangement, 早期稱 VSC, Version Control System</p></blockquote><p>除了 CMVC，後來常用的 SCM 則是 CVS、SVN、Perforce (p4)，但這些 SCM 如果要處理開發流程，以 SVN 來說，是透過 pre-commit 以及 post-commit hook 去管理。透過這些機制，配合像是 Redmine 這種 ITS 就可以做到 commit 語意化，以達到流程管理的目的。</p><p>以下是我在新創事業的工作經歷時，當時配合 <a href="/2016/09/17/Redmine/Integrate-GIT-in-Redmine/">Redmine 設計的 commit 規則</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ref <span class="comment">#1235 part 1 for this functional set.</span></span><br><span class="line">fix <span class="comment">#9527 This is a defect fix, the root cause is invalid assignment.</span></span><br><span class="line"><span class="keyword">done</span> <span class="comment">#6741 complete functional implementation.</span></span><br><span class="line">build <span class="comment">#9420 trigger build</span></span><br></pre></td></tr></table></figure><p>每次 commit 都必須符合這樣的規則：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">command</span>] [issue-number] [comments]</span><br></pre></td></tr></table></figure><p>透過這樣的機制，自己做出完整的 CI &#x2F; CD 流程。</p><h2 id="必要的機制"><a href="#必要的機制" class="headerlink" title="必要的機制"></a>必要的機制</h2><p>CI &#x2F; CD 加上 Pipeline 最核心的有三件事情： <strong>Build</strong> 、 <strong>Delivery</strong> 、以及把這兩件事連接起來的 <strong>Pipeline (Workflow)</strong> 。衍伸的任務，其他 CI 還有的像是串接 Unit Test、Integration Test、Code Scan、Code Review，CD 則有環境建置 (Provisioning)、配置管理、部署策略 (發布策略) … 等，是讓整件事情更完善的下一步。</p><p>除了上述任務，另外影響整個 Pipeline 的則是分支策略這種流程 (Workflow) 帶來的複雜度，不管是 Git Flow、GitHub Flow、還是 Trunk Based，都會讓團隊有更一致的開發流程體驗，當然隨之而來的就是 Pipeline 的複雜度，進而衍伸的架構議題。</p><p>從技術本質來看，要滿足上述任務需要包含這些條件： <strong>(1) 任務 (Task)</strong> 、 <strong>(2) 流程控制 (Flow Control)</strong> 、與 <strong>(3) 事件驅動 (Event Driven)</strong> 。任務指的是像 Build、Deploy、Unit Test、Code Scan … 這些事情，這些事情通常是透過 Script、寫程式、第三方工具串接做整合；流程控制則是把 Task 接起來的控制，包含先後次序，甚至是條件控制；事件驅動則是怎樣發動一個流程或者任務，透過人為觸發 (Approve &#x2F; Bug Report)、還是 commit 觸發、還是 tag &#x2F; branch 觸發、還是 Slack 觸發 … 等。</p><p>當系統架構變大、變複雜，為了加速 Pipeline 執行的效率，通常會考慮增加運算資源，隨之而來的是第四個條件：<strong>分散式運算 (Distributed Computing)</strong> ，但也因此會帶來 <strong>分散式架構</strong> 議題 <sup><a href="/2019/05/21/AWS/Study-Notes-Step-Functions/">1</a>, <a href="https://github.com/rickhw/thinking-in-code/tree/master/task-placement-controller">2</a></sup>。</p><p>撇除工具提供的功能，寫一個好的 Task、做好基本的 Flow Control，需要基本軟體工程能力，還有寫程式的紀律。如果純手工，沒有工具支援，要做好這兩件事情還可以，這也是普遍人在談的自動化程式範圍。但如果要做到事件驅動、分散式運算的需求，那麼就不是普通工程師能做好的了。而 Gitlab 本身的架構透過分散式運行機制：Gitlab Runner 與 Tag，完美的解決這個問題。</p><h2 id="推薦"><a href="#推薦" class="headerlink" title="推薦"></a>推薦</h2><p><img src="/images/About/GitLab-2022/gitlab-2022.jpg"></p><p>一本書如果要說那些最重要的，我會用上述的觀點來作為衡量指標，觀念要正確，實踐方法與思路要清晰、可用、有效率。這本 Gitlab 實戰，作者除了把 GitLab 整體概念有完整的介紹，CI &#x2F; CD &#x2F; Pipeline 該怎麼設計與實踐，有著更實務的介紹，特別在第五章，把我心裡的想法，變成如何透過 Gitlab 實踐出來。</p><p>Pipeline 的複雜度是跟著架構，通常系統架構越複雜、依賴性越多，整個 Pipeline 就會越長且複雜。這時候問題通常不是工具的問題，而是結構問題，計算機科學處理複雜度最常用的方法： <strong>分而治之 (Divide and Conquer)</strong></p><p>例如有五個系統要部署，彼此有先後依賴關係，Pipeline 的長度有數十個 Stages，這時候可以利用 GitLab Pipeline 提供的變數 (Variables)、流程控制 (Workflow)、樣板 (Templates) 等類似於 DSL (Domain-Specific Language) 的功能，搭配分而治之的概念，降低複雜度、提高 Pipeline 重用性，在軟體工程裡就是重構 (Refactoring)。這些在書本都有詳細說明概念與應用。</p><p>如果再加上 Cloud Native 的流行，從傳統的地端機房，變成各種雲提供者 (AWS、GCP、Azure)，乃至於 Kubernates (K8s)，這麼複雜的條件，如何搭配 GitLab 的 Auto DevOps，也是本書會給予讀者方向與概念的。這麼複雜的條件，其實核心概念依舊脫離不了前面提到的本質： <strong>任務、流程控制、事件驅動、以及分散式運算</strong> ，也就是各種雲或者 K8s。</p><p>如果你有個朋友，他是初出茅廬的工程師，如果你想毀了他，那就叫他去寫自動化吧；但是如果你又想讓他覺得，你是世界上對他最好的人，那麼就介紹他 Gitlab 吧！同樣的條件之下，如果他是你的好朋友，為了拯救他於水深火熱，沒日沒夜的加班，那還是介紹他 Gitlab 吧！他上車了，但卻沒有人教他怎麼讓順利做好 Pipeline，那就介紹他這本書，讓艦長帶他一步一步走向更好生活的路上！</p><blockquote><p>技術部落格《<a href="https://rickhw.github.io/">Complete Think</a>》 作者 <a href="/2017/12/29/About/About-Author/">Rick Hwang</a>, 2022&#x2F;10 台北</p></blockquote><p> ☛ 天瓏書局：<a href="https://www.tenlong.com.tw/products/9786263332966?list_name=i-r-zh_tw">和艦長一起 30 天玩轉 GitLab【第二版】（iT邦幫忙鐵人賽系列書）</a></p><h2 id="上市後"><a href="#上市後" class="headerlink" title="上市後"></a>上市後</h2><blockquote><p>updated 2022&#x2F;12&#x2F;16</p></blockquote><p>感謝艦長贈書留念～</p><p><img src="/images/About/GitLab-2022/Chen-Wei2.jpg"><br><img src="/images/About/GitLab-2022/Chen-Wei1.jpg"><br><img src="/images/About/GitLab-2022/Chen-Wei3.jpg"><br><img src="/images/About/GitLab-2022/Chen-Wei4.jpg"></p><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ol><li><a href="/2019/04/04/DevOps/Four-Pillars-of-Software-Delivery/">軟體交付的四大支柱 (Four Pillars of Software Delivery)</a></li><li><a href="/2018/12/16/DevOps/Hire-a-Release-Engineer/">需要專職的 Release Engineer？</a></li><li><a href="/2018/04/01/DevOps/How-To-Make-CICD-Quality/">怎樣的 CI&#x2F;CD 才夠 Quality?</a></li><li><a href="/2019/03/28/DevOps/DevOpsTaiwan-Meetup-Beginning-in-Artifacts-Management/">聊聊軟體交付的濫觴 談產出物管理</a></li><li><a href="/2019/05/21/AWS/Study-Notes-Step-Functions/">Study Notes - Step Functions</a></li><li><a href="/2016/09/17/Redmine/Integrate-GIT-in-Redmine/">系統整合：Integrate GIT in Redmine</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;只要是軟體開發，不管 Web Services、還是 Mobile 或 Desktop Application，都會需要建置 (Build) 與交付 (Delivery) 兩個核心過程。Web Services 的交付稱為部署 (Deployment)，應用程式稱為發佈 (Publish)。而這些過程，也伴隨著一些衍生的任務 (Task)，組成一連串的行為，隨著時間的推進，架構的改變，這些任務的組合，往往是工程師們的夢靨的開始。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Published-SRE1" scheme="https://rickhw.github.io/tags/Published-SRE1/"/>
    
    <category term="Gitlab" scheme="https://rickhw.github.io/tags/Gitlab/"/>
    
    <category term="Continuous Delivery" scheme="https://rickhw.github.io/tags/Continuous-Delivery/"/>
    
    <category term="Continuous Integration" scheme="https://rickhw.github.io/tags/Continuous-Integration/"/>
    
  </entry>
  
  <entry>
    <title>Problem Behind Question</title>
    <link href="https://rickhw.github.io/2022/10/15/Management/Problem-Behind-Question/"/>
    <id>https://rickhw.github.io/2022/10/15/Management/Problem-Behind-Question/</id>
    <published>2022-10-15T10:21:00.000Z</published>
    <updated>2022-12-19T11:47:28.865Z</updated>
    
    <content type="html"><![CDATA[<p>工作上經常問題還沒被看清楚，只求快，要有成果，往往都只是做表面工作。</p><p>這篇整理自 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02kCCdZu2ztmzmYRA8i44qDVA1JYVPfgcn3BaEukmgBerJdRrL3ebojGnJTk2oaDkml">2022&#x2F;09&#x2F;08</a>、<a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0fSDnHyqy4oCN1e1dT6uHR72dGXY4wfHgqcQEimpvJRLGAdDAioDzjsnRznqWuMrMl">2022&#x2F;07&#x2F;22</a> 我自己的思考的筆記，延伸 <code>QBQ (問題背後的問題)</code> 以及 <a href="/2019/12/28/Management/Awareness-and-Deep-Thinking/">如何意識到問題的存在</a>，我自己深度體悟與昇華後的心得。</p><span id="more"></span><h2 id="表象、議題、問題"><a href="#表象、議題、問題" class="headerlink" title="表象、議題、問題"></a>表象、議題、問題</h2><p>普遍的 <code>表象</code> 都只是些 <code>現象</code>，還在 <code>議題 (Issue)</code> 階段，真正的 <code>問題 (Problem)</code> 還沒顯現。</p><p>需透過眾人的 <code>提問 (Question)</code>，經過 <code>思 (Thinking)</code>、<code>辨 (Discussion)</code>、<code>分析 (Analyze)</code>、<code>總結 (Conclusion)</code>，然後真正問題背後的問題：</p><blockquote><p>Problem Behind Question (PBQ)</p></blockquote><p>真正核心問題才會出現，接下來的行動才有機會是提出 <code>解決方案 (Solution)</code>、討論各個 <code>執行計畫 (Plan)</code> 的優缺、進行 <code>執行策略 (Strategy)</code> 謀劃，<code>問題 (Problems)</code> 才能真正的 <code>被解決 (Resolved)</code>。</p><h2 id="定義用詞"><a href="#定義用詞" class="headerlink" title="定義用詞"></a>定義用詞</h2><p>定義前面提到幾個用詞：</p><ul><li><code>Issue</code>: 翻譯成 <code>議題</code>，抽象名詞，泛指事件的統稱，包含已確立的、尚未釐清的、混沌不明的 …<ul><li>這個詞源源自於 Redmine，任何需要被處理的事情都抽象成 Issue。更多參閱 <a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">協同合作系統建制與導入 - 以 Redmine 為例</a></li></ul></li><li><code>Question</code>: 這裡我翻譯成 <code>提問</code>，而不是問題，指的是針對事件的現象進行提問，大部分背後動機都是收集事件的資訊、上下文 (Context)</li><li><code>Context</code>: 背景資訊、上下文、前後文。提問過程，蒐集到的資訊，例如人事時地物等，以及因果關係。</li><li><code>Problem</code>: 問題，已經確立根本的因素，包含實際影響 (Impact)、關鍵觸發者 (Event Source)、範圍 (Scope)，有具體的 <code>問題根源 (Root Cause)</code></li><li><code>Solution</code>: 解決方案，針對問題 (Problem) 的因素而設計的處理方法。留意，是針對性地。</li><li><code>Resolved</code>: 已經解決，是個狀態。透過 Solution，把問題根源排除。</li><li><code>Strategy</code>: 執行策略，當問題被定義好了，通常不會只有一個 Solution，而是會有多個，然後衍生出各個執行計畫，這時候可以比較 Plan A &#x2F; B &#x2F; C 的優缺點 (Pros &#x2F; Cons)，然後往下執行才有策略可言。</li></ul><hr><h2 id="Problem-Behind-Question"><a href="#Problem-Behind-Question" class="headerlink" title="Problem Behind Question"></a>Problem Behind Question</h2><p>改一下很常用的</p><blockquote><p>QBQ: Question Behind Question</p></blockquote><p><a href="https://www.books.com.tw/products/0010245329">問題背後的問題</a>，這是本很有名的書。</p><p>我把這段話改成這樣：</p><blockquote><p>Problem Behind Question, PBQ</p></blockquote><p>可以翻譯成：<code>提問背後的問題</code></p><p>我想要強調的重點是：</p><blockquote><p>在還沒把 <code>議題 (Issue)</code> 的 <code>背景資訊 (Context)</code> 搞清楚之前，<code>問題 (Problem)</code> 是無法定義。</p></blockquote><p>我常常看到這樣的狀況：</p><p>在一些關鍵的問題，像是系統架構、商業決策，很常看到還沒確認問題，就開始急著討論解決方案、什麼時間完成，往往核心問題、核心需求都還沒搞清楚。所以最後解決的往往不是根本因素 (Root Cause)。</p><p>大部分 議題 (Issue) 剛開始看的現象，在背景資料 Ccontext) 不足的情況、情報不足，都還不足以確認、或者定義問題 (Problem)，貿然出手處理，如果經驗又不足，往往處理的，只是表面的東西。</p><blockquote><p>註：<code>緊急事件</code> 的止血行為不在此範圍。</p></blockquote><p>解決方案 (Solution) 處理的是 Problem 的根本因素 (Root Cause)，而提問 (Question) 是探索 Problem 的 Context，搜集情報的過程、疏理 Context、進而找到 Root Cause，然後才定義問題。</p><p>越是關鍵的問題，越是要嚴正以待，提問是很關鍵的一關。</p><h2 id="開會是在浪費時間？"><a href="#開會是在浪費時間？" class="headerlink" title="開會是在浪費時間？"></a>開會是在浪費時間？</h2><p>其實很常聽到同事說，開會是在浪費時間，因為沒有像寫程式一樣有具體產出。</p><p>開會的重點在於，問題 (Question) 提出來，經過思辨、搜集各種角度的想法、最後需要一個人 (最好是 PO)，去整理這些討論與問題，然後分析、總結脈絡，最後做策略性選擇。</p><p>通常問題就在於，沒有針對狀況提問，問題本身沒有經過精煉或者討論。</p><p>最慘的是，時間花了，卻沒有去 <code>整理</code>、<code>分析</code>、<code>總結</code>，所以開會當然會變浪費時間。</p><p>知道問題點在哪，就針對問題用技術能力去改善，而且是一針見血的執行，這樣的開會自然就會有意義，而且是非常有意義。</p><blockquote><p>開會的方法請參閱：<a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></p></blockquote><h2 id="未完-…"><a href="#未完-…" class="headerlink" title="未完 …"></a>未完 …</h2><p>我先整理這段核心想法，延伸 <code>QBQ (問題背後的問題)</code> 以及 <a href="/2019/12/28/Management/Awareness-and-Deep-Thinking/">如何意識到問題的存在</a>，未來再整理完整版。</p><h2 id="相關的書"><a href="#相關的書" class="headerlink" title="相關的書"></a>相關的書</h2><ul><li><a href="https://www.books.com.tw/products/0010245329">問題背後的問題</a></li><li><a href="https://www.books.com.tw/products/0010478689">你會問問題嗎：問對問題是成功領導的第一步</a></li></ul><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></li><li><a href="/2019/12/28/Management/Awareness-and-Deep-Thinking/">如何意識到問題的存在</a></li><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">協同合作系統建制與導入 - 以 Redmine 為例</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作上經常問題還沒被看清楚，只求快，要有成果，往往都只是做表面工作。&lt;/p&gt;
&lt;p&gt;這篇整理自 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02kCCdZu2ztmzmYRA8i44qDVA1JYVPfgcn3BaEukmgBerJdRrL3ebojGnJTk2oaDkml&quot;&gt;2022&amp;#x2F;09&amp;#x2F;08&lt;/a&gt;、&lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0fSDnHyqy4oCN1e1dT6uHR72dGXY4wfHgqcQEimpvJRLGAdDAioDzjsnRznqWuMrMl&quot;&gt;2022&amp;#x2F;07&amp;#x2F;22&lt;/a&gt; 我自己的思考的筆記，延伸 &lt;code&gt;QBQ (問題背後的問題)&lt;/code&gt; 以及 &lt;a href=&quot;/2019/12/28/Management/Awareness-and-Deep-Thinking/&quot;&gt;如何意識到問題的存在&lt;/a&gt;，我自己深度體悟與昇華後的心得。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Design" scheme="https://rickhw.github.io/tags/Design/"/>
    
    <category term="QBQ" scheme="https://rickhw.github.io/tags/QBQ/"/>
    
    <category term="PBQ" scheme="https://rickhw.github.io/tags/PBQ/"/>
    
    <category term="Thinking" scheme="https://rickhw.github.io/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>架構師的使命</title>
    <link href="https://rickhw.github.io/2022/10/07/About/As-Architect/"/>
    <id>https://rickhw.github.io/2022/10/07/About/As-Architect/</id>
    <published>2022-10-07T04:39:00.000Z</published>
    <updated>2023-06-02T13:21:25.313Z</updated>
    
    <content type="html"><![CDATA[<p>架構師的工作到底是做啥？用一張十年前 (2012) 我自己在 <a href="https://www.plurk.com/p/hp91r2">Plurk</a> 寫下的定義，然後再真實經歷之後，重新回顧這段話。</p><p><img src="/images/About/201211_as-Architect.jpg"><br><a href="https://www.plurk.com/p/hp91r2">Plurk Permalink</a></p><p>這篇是我在粉專寫下的 <a href="https://www.facebook.com/completethink/posts/pfbid02kxY7WJLh6aWnpVNuSeK8z6WQm26kEVqPuzrcYKVyEjAFhPjwzF6pau1Y2uyKPx9rl">隨筆文</a>，放在 blog 做個紀錄。</p><span id="more"></span><hr><h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>截圖是我 2012 年在 <code>噗浪</code> (Plurk, 還有人在用？) 上自己對於 <code>架構師</code> 寫下的定義:</p><blockquote><p>讓所有團隊的 <code>關係人</code>，對於 <code>產品</code> 有 <code>一致性</code> 的 <code>整體觀</code></p></blockquote><p>我的部落格文章裡，有很高的比例都在整理溝通表達的想法，像是：</p><ul><li><a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li><li><a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/">開會原則</a> 及 系列文</li><li><a href="/2021/12/19/Management/Protocol-to-Communication/">團隊溝通的通訊協議</a></li></ul><p>除了這些軟性的，在 “<a href="/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">一致性問題與共識演算法</a>“ 這篇整理，把 <code>一致性問題</code>、<code>共識演算法</code> 兩個 分散式系統的核心議題，直接用到組織溝通。計算機科學裡的 <code>通訊協議</code> 概念，應用在人與人溝通。</p><h2 id="使命"><a href="#使命" class="headerlink" title="使命"></a>使命</h2><p>最近跟朋友聊到架構師工作內容是做啥？研究最新的最炫砲的技術？還是去扛別人留下來的坑、把坑變黃金？研究下一代的技術？ …. 聽起來好像是，也好像都不是。</p><p>最近剛好有機會，有在學學生來公司參訪，我負責介紹架構師在做啥，準備的時候我直覺的就用了十年前的這段話當開場，定義了架構師的使命。</p><p>這句話其實換成其他角色，也可以？其實不然，換成總監、經理層級，絕對不行；VP 以上層級，也不對，大部分的 VP、總監、經裡 還是 Functional Base 的角色，也就是具備本位主義。所以只有架構師、產品長、PO，或者 C-Level 這種全局觀的角色，才是做這種工作。</p><p>普遍人對於架構師還是以技術角度出發，例如就是在導 MicroServices、DDD、Clean Code &#x2F; Architect、搞 K8s、弄 Cloud、弄 vSphere、Service Mesh、資訊安全 … 我也的確在當場回答了一些概念，我的 Blog 也有一半以上都在寫技術類的東西。</p><h2 id="各種-XXX-Architect-updated-2023-x2F-05-x2F-31"><a href="#各種-XXX-Architect-updated-2023-x2F-05-x2F-31" class="headerlink" title="各種 XXX Architect (updated: 2023&#x2F;05&#x2F;31)"></a>各種 XXX Architect (updated: 2023&#x2F;05&#x2F;31)</h2><p>我的 <a href="/2017/12/29/About/About-Author/">個人介紹</a> 有寫到這些 <code>XXX Architect</code>，突然想到 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid026vWwDuNdFRrLheKbN9fDAYhumSJpuLfumxLwSgCUsBdQZam4w38YjYnkrRGHEHYVl">紀錄</a> 這件事。。。</p><p>這些名稱背後我有自己的解釋，記錄這些定義，以及背後的想法。好友 Kim 也有類似的 <a href="https://www.facebook.com/kimkao.solid/posts/pfbid0yuVSwo7h4GYtnLS3eP14JkhR5mWMdcuNj6CAzDbE9NRYdjPrtggfg3nrNpjfEuRKl">紀錄</a>，也可以參考看看～～</p><h3 id="Software-Architect"><a href="#Software-Architect" class="headerlink" title="Software Architect"></a>Software Architect</h3><p>有些公司稱 <code>Application Architect</code>, 本質是處理 Code Level 的各種 <code>資料結構</code> 與 <code>資料流</code>. System Design 談的 Design Patterns, DI, AoP, SOLID, Algorithm, Protocol, Framework, API, UI, … 等要處理的. 也就是一個應用程式裡面所有的東西, 與他對外的關係. </p><p>最近我用 Process 概念來闡述這種概念, App 跑起來在作業系統裡就是一條 Process …. Process 以外的就是 Infra, 有怨念 … 但真實世界就是這樣運作的 QQ</p><h3 id="Infra-Architect"><a href="#Infra-Architect" class="headerlink" title="Infra Architect"></a>Infra Architect</h3><p>處理 Application 以外的東西. 跳出 Process 以外的事情, 都是 Infra 的事 (也很符合事實) … </p><p>K8s 核心概念的 Pod 表述的是一個應用程式 (Process &#x2F; container) 與其他 Process (Container) 之間的關係. 實務上, 應用程式 (Process) 之外的 Processes (ex: DB, storage, networking …), 真的都是 Infra Team 在管的. </p><p>大概就是你媽在家裡做的是，老爸只負責賺錢 …</p><h3 id="Tech-Architect"><a href="#Tech-Architect" class="headerlink" title="Tech Architect"></a>Tech Architect</h3><p>做 <code>技術決策</code> 與 <code>技術管理</code>. </p><p>舉凡各種 Design Principle &#x2F; Methodology &#x2F; Guideline, 技術選擇, Evaluation &#x2F; Tradeoff &#x2F; Tuning &#x2F; Optimizition …. </p><p>該用 REST or GraphQL? 該用 NATS or Kafka? 該用 RDB or NoSQL or NewSQL? 該用 Block or Object Storage? </p><p>所以 Tech Architect 會往下繼續展開各種專業, 像是 DB &#x2F; Data &#x2F; Network &#x2F; Security &#x2F; Storage &#x2F; Test … 等更深度領域的. </p><p>這也是大多數人認為 architect 的主要工作.</p><h3 id="Solution-Architect"><a href="#Solution-Architect" class="headerlink" title="Solution Architect"></a>Solution Architect</h3><p>解決問題的那個人, 需要懂上面一堆東西 …. 技能很硬、身段卻要很軟的角色 (到處跪🧎)。</p><p>一些人會以為導入 OOXX 技術就是 “Solution”, 所以常常系統裡就多了很多不知道為啥存在的東西 …. Solution Architect 的重點是要解決問題, 這才是最難的.</p><p>通常問我, 你都用什麼 Solution ? 通常我都會反問: </p><blockquote><p>你說的問題是什麼？怎樣才叫解決？</p></blockquote><p>通常被我這樣反問的人, 有一半會當機 ….</p><blockquote><p>問題背後的問題：<a href="/2022/10/15/Management/Problem-Behind-Question/">Problem Behind Question</a></p></blockquote><h3 id="Enterprice-Architect"><a href="#Enterprice-Architect" class="headerlink" title="Enterprice Architect"></a>Enterprice Architect</h3><p>跟業務 ($$) 有關的, 上面沒列到的, 簡稱 Others …. (有點像 PMO .. XDD</p><p>詳細可以參閱 <a href="https://en.wikipedia.org/wiki/Enterprise_architecture">Wikipedia</a> 的整理.</p><h2 id="武、俠與俠之大者"><a href="#武、俠與俠之大者" class="headerlink" title="武、俠與俠之大者"></a>武、俠與俠之大者</h2><p>我很喜歡讀金庸武俠，其中最喜歡討論的就是 <code>武俠</code>，喜歡郭靖的 <code>俠之大者，為國為民</code>。江湖上喜歡討論誰武功高、誰的武功有多厲害、喜歡討論之最、最高、爭奪武功秘笈 ….. (這年代的武功秘笈都在 ACM 論文 …. 只要有心，人人都可以練成葵花寶典、超級賽雅人)。</p><p>而我個人，更多喜歡討論的是俠者為何？直接引用金庸自己在小說序中提到的概念：</p><blockquote><p>『武功』只是用來解決問題的手段，特別是在過去朝代律法規範不健全之下，人們只能用『武功』來取得正義，或者利益。『武俠』小說要討論的核心，應該是人跟人之間的俠與義，更近一步的是人性。只是在說故事的時候，需要透過武功來陳述過程衝突，解決的手段，甚至誇大武功的力量（所以乾坤大挪移、降龍十八掌），藉此吸引讀者目光。</p></blockquote><p>同樣的概念，也可以套用在科幻小說上。藉由幻想的科學 (科幻)，探討『哲學』議題，包含生命、烏托邦 … 等。</p><p>回到架構師的職責，架構師要凝聚的是 <code>關係人 (Stakeholder)</code> 的 <code>共識 (Consensus)</code> ，讓團隊對於展品有整體 <code>一致性 (Consistency)</code> 的 <code>整體觀</code>。</p><blockquote><p>Consensus vs Consistency 的差異，參閱 “<a href="/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">一致性問題與共識演算法</a>“ 有實際舉例說明其差異。</p></blockquote><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li><li><a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/">開會原則</a> 及 系列文</li><li><a href="/2021/12/19/Management/Protocol-to-Communication/">團隊溝通的通訊協議</a></li><li><a href="/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">一致性問題與共識演算法</a></li><li><a href="/2022/10/15/Management/Problem-Behind-Question/">Problem Behind Question</a></li></ul><h2 id="Facebook-隨筆"><a href="#Facebook-隨筆" class="headerlink" title="Facebook 隨筆"></a>Facebook 隨筆</h2><ul><li>2022&#x2F;10&#x2F;07: <a href="https://www.facebook.com/completethink/posts/pfbid02kxY7WJLh6aWnpVNuSeK8z6WQm26kEVqPuzrcYKVyEjAFhPjwzF6pau1Y2uyKPx9rl">架構師的使命</a></li><li>2023&#x2F;05&#x2F;31: <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid026vWwDuNdFRrLheKbN9fDAYhumSJpuLfumxLwSgCUsBdQZam4w38YjYnkrRGHEHYVl">各種 XXX Architect</a></li><li>2022&#x2F;11&#x2F;10: <a href="/2017/12/29/About/About-Author/">Kim Kao 的架構師解釋</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;架構師的工作到底是做啥？用一張十年前 (2012) 我自己在 &lt;a href=&quot;https://www.plurk.com/p/hp91r2&quot;&gt;Plurk&lt;/a&gt; 寫下的定義，然後再真實經歷之後，重新回顧這段話。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/About/201211_as-Architect.jpg&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://www.plurk.com/p/hp91r2&quot;&gt;Plurk Permalink&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這篇是我在粉專寫下的 &lt;a href=&quot;https://www.facebook.com/completethink/posts/pfbid02kxY7WJLh6aWnpVNuSeK8z6WQm26kEVqPuzrcYKVyEjAFhPjwzF6pau1Y2uyKPx9rl&quot;&gt;隨筆文&lt;/a&gt;，放在 blog 做個紀錄。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Career" scheme="https://rickhw.github.io/tags/Career/"/>
    
    <category term="Architect" scheme="https://rickhw.github.io/tags/Architect/"/>
    
  </entry>
  
  <entry>
    <title>蓋環境很難？是這樣的嗎？QA 需要自己蓋環境？</title>
    <link href="https://rickhw.github.io/2022/09/25/SQA/QA4QA-Provisioning-is-Difficult/"/>
    <id>https://rickhw.github.io/2022/09/25/SQA/QA4QA-Provisioning-is-Difficult/</id>
    <published>2022-09-25T03:08:00.000Z</published>
    <updated>2022-12-19T11:47:28.869Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2022/08/13/SQA/Path-to-Software-Testing/">上一次的分享</a> 之後，開始有 QA 的朋友找我聊很多他正在面對的問題。其中一個問題是：</p><blockquote><p>Backend 開發人員說建立環境很難？是這樣嗎？</p></blockquote><p>本文針對這個問題，整理背後可能的問題，以及實際可行的方法。全文整理自 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tC7UQ4JMVfUf7bXng3o4wM6FfTZc6HzzW1NujnZgZ6p8cRJznMHkBXWBmHZKXLjcl">09&#x2F;18 在 FB 寫的草稿</a>。</p><span id="more"></span><hr><h1 id="Backend-開發人員說建立環境很難？是這樣嗎？"><a href="#Backend-開發人員說建立環境很難？是這樣嗎？" class="headerlink" title="Backend 開發人員說建立環境很難？是這樣嗎？"></a>Backend 開發人員說建立環境很難？是這樣嗎？</h1><p>標題簡化了一些訊息，重現原本的提問：</p><blockquote><p>我是一個 QA，我曾經找 Backend 開發人員問，我想自己建環境測試，他們說很難，Config 很雜亂、DB Schema 很複雜、Infra 很複雜，真的是這樣？</p></blockquote><p>重新整理提問，整個問題是從 <a href="/2017/02/11/DevOps/Resource-Provisioning-and-DevOps/">蓋環境 (專有名詞 Provisioning)</a> 出發，對於測試人員來看，背後 <code>動機</code> 與 <code>目的</code> 有以下：</p><ol><li>因為執行測試過程會被自動觸發的 CI 部署打斷，希望不被干擾執行</li><li>想要透過了解環境，更確立問題的正確性</li><li>想要透過 Log 找問題，目前環境無法看到 Log</li><li>測試過程，想進去 DB 增加資料，查問題</li></ol><p>從開發人員的回覆，可以看出背後有以下問題：</p><ol><li>Config 很雜亂</li><li>DB Schema 很複雜</li><li>Infra 很複雜</li></ol><h2 id="1-現象：Config-很雜亂"><a href="#1-現象：Config-很雜亂" class="headerlink" title="1. 現象：Config 很雜亂"></a>1. 現象：Config 很雜亂</h2><p>Config 指的是應用程式在啟動階段透過外界指定的配置資訊，應該在 <code>系統設計 (System Design)</code> 過程就要確立的結構，這屬於 <code>Application Interface</code> 的範疇，也是 System Design 階段要確立的東西。</p><blockquote><p><code>Application Interface</code> 是我自己定義的名詞，用來描述一個應用程式的外顯介面。只要是使用者會接觸到的資訊，都屬於外顯介面，像是 Config &#x2F; Environment Variables &#x2F; Secret &#x2F; API &#x2F; Documentation … etc.</p></blockquote><p>常見的 Config 大概可以分成以下幾個部分：</p><ol><li>系統依賴：<ol><li>會有 connection string 的，包含 ip &#x2F; host、protocol、id &#x2F; password 、parameters 等。</li><li>服務自己的基礎設施，像是對 Database &#x2F; Cacche &#x2F; Queue .. 等依賴</li><li>公司內部與第三方系統的依賴：<ol><li>公司內部：像是依賴於內部的 簡訊服務、另一個服務的 API … 等。</li><li>第三方服務：像是依賴於 Google SSO、AWS S3 服務、Twillo 的簡訊服務、Paypal 的金流服務 … 等。</li></ol></li></ol></li><li>業務邏輯功能的初始與預設參數：<ol><li>通常是 Feature Toggle 以及其參數</li><li>每頁商品數量的預設數量</li><li>其他 … etc</li></ol></li><li>非功能的參數：<ol><li>Logging: Rotation 的規則、擋名規則、輸出模式 (File or Stdout) ..</li><li>DI 框架的參數，像是 Autowire 掃描的規則</li><li>框架的設定</li></ol></li></ol><p>這些依照實際案例，會有所差異，不過我個人大概是這樣分。</p><p>Config 需要有經驗的人、經過有設計的過程，持續精煉與重構。因為沒有這個循環，隨著時間的推進 (通常是 &gt;2y)，會越來越複雜，隨之而來的是管理複雜度。如果再加上多環境部署 (不管 Test or Prod)，管理問題就會浮上檯面。</p><blockquote><p>Config 的設計概念參閱 <a href="/2022/05/06/Coding/Designing-Configuration-Loading-Strategies/">Designing Configuration Loading Strategies</a></p></blockquote><h3 id="問題背後的問題-QBQ"><a href="#問題背後的問題-QBQ" class="headerlink" title="問題背後的問題 (QBQ)"></a>問題背後的問題 (QBQ)</h3><ol><li><code>開發過程沒有設計與管理</code>：在新需求開發過程中，Config 很常會因為新需求而增加，這時候沒有適度的設計與管理，時間久了，一定開花。<ol><li>不管用 K&#x2F;V 結構 (.properies) 或者 object (XML &#x2F; JSON &#x2F; YAML)，只要沒有配套的 <code>技術管理機制</code>，最後就是整串葡萄串大亂鬥</li><li>機制：透過統一個 ConfigLoader 限制，包含命名規則、資料結構驗證等</li><li>規範：要有設計與 Review 流程</li></ol></li><li><code>沒有持續收斂設計</code>：如果沒有適度的技術管理機制持續收斂，時間越久越亂是正常的<ol><li>各種亂象出現在 Config 裡，像是在一個 JSON element 裡面塞入一個 XML string</li><li>在一個 XML 的 attribute 裡塞入整個 JSON payload</li></ol></li><li><code>部署管理機制不踏實</code>：<ol><li>不管有沒設計或收斂，都需要面對管理問題，因為只要有部署的需求，部署的環境越多，就要有管理流程。</li><li>實際上 APP 的部署第一關應該是 QA 要把關，這概念在 “<a href="/2018/12/15/DevOps/TheProblem-In-DevOps-8-Cycle/">DevOps 8 字環的誤區：左環問題</a>“ 有深入說明。</li></ol></li></ol><p>理想 Config 實踐流程有以下的循環：</p><ol><li><code>設計優先 (Design First)</code>: 系統設計的時候，#TechLead 必須把關規格</li><li><code>持續迭代 (Continuous Iteration)</code>: 每次更版都要做適度的調整與迭代</li><li><code>管理政策 (Management Policy)</code>: 也就是每次的更版要遵守的規範，例如 Key 的 增刪改 各自需要應對的措施<ul><li>這些規範背後需要技術支撐，像是 Config Migration 機制與流程</li></ul></li></ol><h2 id="2-現象：DB-Schema-很複雜"><a href="#2-現象：DB-Schema-很複雜" class="headerlink" title="2. 現象：DB Schema 很複雜"></a>2. 現象：DB Schema 很複雜</h2><p>DB Schema 很複雜 (或者很亂)，其實背後本質是跟 Config 一樣的問題。</p><p>DB Schema (這裡指的是 Ralation DB, 不是 NoSQL) 一樣是要經過設計與收斂，透過迭代 <code>去蕪存菁</code>、<code>精煉</code>。資料結構的設計難的是在初期 <code>判斷</code> 與 <code>預測</code> <strong>判斷資料溫度在未來的變化性</strong>，因為很難一次到位，所以通常都要透過以下方法：</p><ol><li>設計階段 Tech Leader 需要把關 DDL 的設計</li><li>持續小部分的迭代與改進，調整資料溫度的配置，例如：<ol><li>原本判定是 <code>熱資料</code>，後期變成冷資料，那應該就要設計 Archive 機制，轉入 <code>OLAP</code></li><li>原本是以為是 <code>冷資料</code>，變成溫資料，那就要透過快取緩存改善</li><li>原本是以為是 <code>熱資料</code>，上線後發現根本沒有存取，所以要改成冷資料，或者一次快取。</li></ol></li><li>規劃每次更版 DDL &#x2F; DML Migration 機制與流程</li></ol><p>這些都是透過 <code>持續迭代</code> 改善出來的，會越來越亂，都是因為 <code>沒有持續迭代</code>、或者 <code>經驗不足</code> 與 <code>能力不夠</code> 造成的。經驗與能力我覺得找到適當的人就可以了，難的是專案管理過程中，沒有持續迭代，這也是普遍公司的問題。</p><p>看到這裡，不難發現， Config &#x2F; DB Schema 的處理與管理手段是一樣的。</p><h2 id="3-現象：Infra-很複雜"><a href="#3-現象：Infra-很複雜" class="headerlink" title="3. 現象：Infra 很複雜"></a>3. 現象：Infra 很複雜</h2><p>再來談談 Infra 的部分，其實也是一樣的。</p><p>通常一個應用程式起來，都會有相應的依賴，常見的有:</p><ol><li>Database (RDB &#x2F; NoSQL): MySQL &#x2F; PostgreSQL &#x2F; MongoDB &#x2F; DDB … etc</li><li>Cache: Redis &#x2F; Memcached</li><li>Queue: RabbitMQ &#x2F; SQS</li><li>Storage: File System &#x2F; Object Storage (S3, GCS)</li></ol><blockquote><p>上述的排序：Structure to Non-Structure</p></blockquote><p>這些東西，通常難的都不是建立 (Provisioning) 起來這件事情，因為這年代有 docker &#x2F; container 這個技術，通常只要 config 講清楚，不會太難。上面列的最難的大概只有 RDB (Relation Database)，因為他有 DDL 需要做 Migration，這個會稍微難一點。現在很多 ORM 都有對應的方法與策略，概念從 RoR (Ruby on Rails, 2008) 年代就有了，基本概念就是可以做到持續更迭 DDL。所以最難的沒了。</p><p>其他不管是 NoSQL &#x2F; Cache &#x2F; Queue &#x2F; Storage …. 都談不上難。</p><ul><li>NoSQL 本身就是沒有 DDL Migration 的問題，因為這東西本身就是 Non-Schema 的。</li><li>Cache 通常就是一些 Key &#x2F; Value 的操作，所以只要知道 Key 的定義與結構即可</li><li>Queue 是通道的概念，大部分只要把通道規則弄好就好，一次性的。</li><li>Storage 目錄結構，不管是 Object Storage or Block Storage，搞懂目錄結構即可。</li></ul><p>很多人想問，像那些 Replication &#x2F; HA &#x2F; Cluster 不是很難嗎？</p><p>這時候我會先分清楚目的性：<code>Functional Test</code> or <code>NonFunctional Test</code></p><p>如果前者，基本上，不用考慮這些是。如果是測後者，才需要考慮這些事情，看你自己的 R&amp;R。後者通常跟 <code>架構</code> 很有關係，因為 前述的 (HA, Cluster … ) 很多都跟 <a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">Reliability</a> 有關係，可靠度本質就是工程 &#x2F; 架構 要面對的問題，這才是真正的難。</p><p>相關概念參閱以下的文章：</p><ul><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li><a href="/2022/09/18/SQA/Integration-Test-and-Execution-Strategy/">整合測試與執行策略</a></li><li><a href="https://rickhw.github.io/2018/03/18/SQA/Gossip-System-Testing/">輕鬆聊：系統測試 (SVT) 的三兩事</a></li><li><a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性工程 (Reliability Engineering)</a></li></ul><p>除了這些，可能還有其他像是 Networking, Platform (K8s) 的依賴。</p><hr><h1 id="問題背後的問題-Problem-Behind-Question-PBQ"><a href="#問題背後的問題-Problem-Behind-Question-PBQ" class="headerlink" title="問題背後的問題 (Problem Behind Question, PBQ)"></a>問題背後的問題 (Problem Behind Question, PBQ)</h1><h2 id="很雜亂？很難？"><a href="#很雜亂？很難？" class="headerlink" title="很雜亂？很難？"></a>很雜亂？很難？</h2><p>上述的東西，都很雜，談不上難，但是時間只要越來越久，就會由雜變成難。更多參閱： “<a href="/2022/09/10/About/Difficult-and-Complicate/">問題的難與雜</a>“</p><p>只要有遵循前述的設計原則，持續迭代，給一台 Linux，足夠的 CPU &#x2F; Memory &#x2F; Disk，應該沒什麼做不到的。</p><p>去看看外面 Open Source ，我沒看過有哪個說一定要 K8s &#x2F; AWS &#x2F; GCP 才能安裝的？</p><p>我把問題歸類為：</p><ol><li>設計問題</li><li>能力問題</li><li>執行力</li></ol><p>對於 QA 而言，我自己親身經驗，裝軟體這件事情，只要上述條件具備，剩下的都是指日可待的問題。所以這問題，最後我的回答都是一樣的：</p><blockquote><p>如果你覺得很複雜，那表示不夠熟悉；如果覺得很難，那代表基本功不夠紮實；如果覺得很亂，那大多都是管理問題。</p></blockquote><!--RD 要會裝自己的環境就是基本功RD 自己都搞不定那 QA 就更遠了窮和尚富和尚# 議題：QA 需要自己蓋環境嗎？# 延續問題：如果公司開發團隊無法做到像你說的那樣，那我應該繼續待下去？--><h2 id="團隊的問題"><a href="#團隊的問題" class="headerlink" title="團隊的問題"></a>團隊的問題</h2><p>而蓋環境背後也可以看出整個開發團隊的問題：</p><ol><li>Backend 開發人員都覺得蓋環境難，表示不了解整體架構與對外依賴配置<ol><li>有很多依賴問題：<ol><li>例如強依賴於 Cloud Services，像是 AWS S3 &#x2F; Secret Management，卻沒有做適度的設計。</li><li>像是用了 EKS 的 IRSA，或者 AWS IAM Role，就以為一定要 AWS 應用程式才能跑，其實這些都是不了解運作原理，以及沒有適度設 Config 造成的。</li></ol></li><li>時間久了，導致連開發人員自己都蓋不起來，就連一些 Sr. Engineer 都搞不定。</li><li>沒有適度切割顆粒度，導致 Config 隨時間增長，複雜度過高。<ol><li>切割顆粒度背後代表著要重構，一個 Method 有一千行，通常就要拆分職責。</li></ol></li></ol></li><li>太過依賴於所謂的 <code>自動化</code>，而自動化的程式本身的品質堪憂，導致部署難度越來越高。<ol><li>只有寫自動化的人大概知道整個架構是怎麼一回事</li></ol></li><li>Config 的資訊只有開發人員知道，其他 (QA &#x2F; Ops) 都不知道</li><li>蓋環境這件事情，在團隊裡是一個天方夜譚的 #能力</li></ol><p>所以，得到結論：</p><blockquote><p>蓋環境這件事情不可能<br>需要動用很多團隊</p></blockquote><p>上述問題，在越有歷史、越有規模，但不注重軟體工程的公司，越容易發生。</p><blockquote><p>翻譯：很多 (九成九) 公司都有這樣的問題。</p></blockquote><h2 id="怎麼解？"><a href="#怎麼解？" class="headerlink" title="怎麼解？"></a>怎麼解？</h2><p>做好該做的基本功，只要想省略、或者用自動化掩蓋的念頭，時間越久會越雜。 OOP 之所以會出現，是因為 早期程式發展到複雜度而產生，而 OOP 背後的本質就是持續的分類與重構。</p><p>問題提到的 Config &#x2F; DB Schema &#x2F; Infra 其實都是要持續設計與改善的。不是只有自動化就天下太平，自動化只會粉飾太平。</p><p>公司已經 Run 一段時間 (&gt;3y) 了，怎麼辦？這時候只能請 <a href="/2019/09/13/DevOps/Scrum-for-SRE-Team/">扁鵲</a> 出場開刀了，不用懷疑，任何想要走捷徑的方法，最後一定死路一條。該開刀，就要開刀，沒有特效藥。</p><h2 id="QA-需要自己蓋環境嗎？"><a href="#QA-需要自己蓋環境嗎？" class="headerlink" title="QA 需要自己蓋環境嗎？"></a>QA 需要自己蓋環境嗎？</h2><p>QA 的職責之一是發現問題。</p><p>發現問題這個過程，背後代表要能證明 <code>症狀 (Symptom)</code> 真的是一個 <code>問題 (Problem)</code>。如果已經是問題了，那麼一定能夠提供完整的重現步驟 (Reproducable)，有相關的證據，像是 Log、Config、Data …. 等。這個過程本身是非常講究科學方法的，</p><p>當掌握環境建置的時候，上述的過程才能夠有效地掌握，也才能找出有意義的 Defect。</p><p>對我來講，蓋環境，是 QA 的第一個條件，這段在 “<a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a>“ 的技能段落排第一位。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2022/09/05/About/Blog-Practice/">聊聊寫 Blog 的想法</a></li><li><a href="/2022/05/06/Coding/Designing-Configuration-Loading-Strategies/">Designing Configuration Loading Strategies</a></li><li><a href="/2022/09/10/About/Difficult-and-Complicate/">問題的難與雜</a></li><li><a href="/2018/12/15/DevOps/TheProblem-In-DevOps-8-Cycle/">DevOps 8 字環的誤區：左環問題</a></li><li><a href="/2017/02/11/DevOps/Resource-Provisioning-and-DevOps/">Resource Provisioning and DevOps</a></li><li><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題 (How to Report Problems Effectively)</a></li><li><a href="/2018/04/01/DevOps/How-To-Make-CICD-Quality/">怎樣的 CI&#x2F;CD 才夠 Quality?</a></li><li><a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性工程 (Reliability Engineering)</a></li><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li></ul><h2 id="Facebook-隨筆"><a href="#Facebook-隨筆" class="headerlink" title="Facebook 隨筆"></a>Facebook 隨筆</h2><ul><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tC7UQ4JMVfUf7bXng3o4wM6FfTZc6HzzW1NujnZgZ6p8cRJznMHkBXWBmHZKXLjcl">Backend 開發人員說建立環境很難？是這樣嗎？</a></li><li><a href="https://www.facebook.com/completethink/posts/pfbid09UTWvYbHLnKKixJyWiinmXQGCc7tuTkuoZ9Gna7W8KPzZxSp7vQL6jkhdaZVRthXl">軟體工程師需要會蓋環境？</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid024b4F5Q9xngNAV6NsqGi7wMZs4WVQPpohjCmGkomcGGCAYqirYeEjV2hDhW8LE2Eql">Container vs VM</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0he6RNijEgMFY4pUcfWcUbJqRqZMmqw9pzHfCtw6gWQoG12b9YhZhZ2smMgJKEB7Jl">難與雜</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/2022/08/13/SQA/Path-to-Software-Testing/&quot;&gt;上一次的分享&lt;/a&gt; 之後，開始有 QA 的朋友找我聊很多他正在面對的問題。其中一個問題是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Backend 開發人員說建立環境很難？是這樣嗎？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文針對這個問題，整理背後可能的問題，以及實際可行的方法。全文整理自 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0tC7UQ4JMVfUf7bXng3o4wM6FfTZc6HzzW1NujnZgZ6p8cRJznMHkBXWBmHZKXLjcl&quot;&gt;09&amp;#x2F;18 在 FB 寫的草稿&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體測試" scheme="https://rickhw.github.io/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
    
    <category term="Software Test" scheme="https://rickhw.github.io/tags/Software-Test/"/>
    
    <category term="Software Quality Assurance" scheme="https://rickhw.github.io/tags/Software-Quality-Assurance/"/>
    
  </entry>
  
  <entry>
    <title>整合測試與執行策略</title>
    <link href="https://rickhw.github.io/2022/09/18/SQA/Integration-Test-and-Execution-Strategy/"/>
    <id>https://rickhw.github.io/2022/09/18/SQA/Integration-Test-and-Execution-Strategy/</id>
    <published>2022-09-18T03:08:00.000Z</published>
    <updated>2023-05-27T04:54:32.125Z</updated>
    
    <content type="html"><![CDATA[<p>在 “<a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a>“ 整理了各種測試的 “階段”，其中 #整合測試 (Integration Test) 是常見的階段之一，針對 “整合” 我的脈絡有以下：</p><ol><li><code>功能對功能</code> 的整合</li><li><code>系統對系統</code> 的整合</li><li><code>功能對系統</code> 的整合</li></ol><p>引用我 <a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">上次分享</a> 整理的文字描述，如下圖：</p><p><img src="/images/SQA/Integration-Test_Service-Test.png"></p><p>Source: <a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></p><blockquote><p><code>20230523 更新</code>: 本文部分收錄在 <a href="/2023/05/23/About/2023-Software-Test-Practice/">共同著作《軟體測試實務》</a> 第一冊 第五章之中，歡迎大家彭場指導。</p></blockquote><span id="more"></span><h2 id="整合功能的案例"><a href="#整合功能的案例" class="headerlink" title="整合功能的案例"></a>整合功能的案例</h2><p>整合功能其實生活中很多，大家平常在用的產品都很常出現。</p><h3 id="案例：功能對系統的整合"><a href="#案例：功能對系統的整合" class="headerlink" title="案例：功能對系統的整合"></a>案例：功能對系統的整合</h3><p><a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">上次分享</a> 中我用 PCHome 的訂單快照 + 訂單快照的 SLA 來當整合的例子，這是個 <code>功能對系統</code> 整合測試的案例。</p><p><img src="/images/SQA/Integration-Test/PChome-OrderCapture-and-SLA.png"></p><h3 id="案例：功能對系統的整合-1"><a href="#案例：功能對系統的整合-1" class="headerlink" title="案例：功能對系統的整合"></a>案例：功能對系統的整合</h3><p>另外一篇 “<a href="https://rickhw.github.io/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">有效回報問題</a>“ 則舉例很久以前我自己遇過的例子：<code>時間跟充電</code> 兩個整合造成的問題。這也算是 <code>功能對系統</code> 的整合問題。當時的錄影如下：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/o0q2DJPnb1Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>文中針對問題現象做以下紀錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Environment</span></span><br><span class="line"></span><br><span class="line">- iOS 11.4.1</span><br><span class="line">- iPad Air 128Gb.</span><br><span class="line"></span><br><span class="line"><span class="comment">## How to reproduce?</span></span><br><span class="line"></span><br><span class="line">1. connect the power adapter to iPad</span><br><span class="line">2. open Click app, tap Timer, <span class="built_in">set</span> a countdown <span class="keyword">in</span> 5s</span><br><span class="line">3. start the countdown</span><br><span class="line">4-1: stop the sound by tab Home button,</span><br><span class="line">4-2: stop the sound by swiping up notification</span><br><span class="line"></span><br><span class="line"><span class="comment">## Expected Result</span></span><br><span class="line"></span><br><span class="line">Sound should be stopped.</span><br><span class="line"></span><br><span class="line"><span class="comment">## Acturl Result</span></span><br><span class="line"></span><br><span class="line">Sound keeps playbacking, unstoppable.</span><br><span class="line"></span><br><span class="line"><span class="comment">## Notes</span></span><br><span class="line">- Remove power adapter to fix the issue.</span><br><span class="line">- No issue on iPhone6</span><br></pre></td></tr></table></figure><h3 id="案例：功能對功能的整合"><a href="#案例：功能對功能的整合" class="headerlink" title="案例：功能對功能的整合"></a>案例：功能對功能的整合</h3><p>最近 iPhone 14 上市了，新的功能 <code>動態島 (Dynamic Island)</code> 成為大家讚不絕的設計。這樣的功能改善了視覺上的體驗。但很快的鄉民就發現這個功能和 <code>既有的功能 (橫向螢幕)</code> 一整合問題就出來了，這也典型的 <code>功能對功能</code> 整合的案例。</p><p><img src="/images/SQA/Integration-Test/iPhone14-Dynamic-Island.JPG"></p><h2 id="整合測試的-理論範圍"><a href="#整合測試的-理論範圍" class="headerlink" title="整合測試的 理論範圍"></a>整合測試的 <code>理論範圍</code></h2><p><code>整合</code> 的基本定義：</p><ol><li>平面二維，也就是<code>(A + B)</code> 的概念，兩個功能的整合</li><li>三維或以上：A + B + C 或者 A + B + C + D … 三個或以上的功能混合。</li></ol><p>在軟體設計時，如果沒有針對功能與功能之間作討論與規劃，整合功能會出現 <code>Defect</code> or <code>新功能</code>，是無法預測的。</p><p>舉例來說，iOS 的設定列表上假設有 5 個功能 (A, B, C, D, E)，這 5 功能彼此之間有沒有關係？先不管有沒關係，先假設都有關係，而且是一對一的組合，那麼這五個功能之間有多少排列組合？用二維的概念來列舉排列組合如下：</p><ol><li>A: A + B, A + C, A + D, A + E &#x3D; 4</li><li>B: B + C, B + D, B + E &#x3D; 3</li><li>C: C + D, C + E &#x3D; 2</li><li>D: D + E &#x3D; 1</li><li>E: 0</li></ol><p>以上共有 4 + 3 + 2 + 1 &#x3D; 10 個組合，簡單列個公式：</p><blockquote><p>n (n-1) &#x2F; 2</p></blockquote><p>有 10 個功能，組合有 45 個、20 功能組合有 190 個。這是二維的整合，如果是三維的整合功能，那複雜度就更高了。</p><p>這段描述不管是二維、還是三維以上的前提是：功能彼此之間是攤平的，不是巢狀結構，沒有上下依存關係。功能的關係是立體的，數量的公式就不是這麼單純的了。</p><p>排列組合的好處是可以看到理論的最大範圍，也就是如果出問題，應該都在排列組合之內。缺點則是排列組合會包含很多不合使用邏輯、不會真實存在的情境。</p><blockquote><p><a href="https://zh.wikipedia.org/zh-tw/%E5%8F%AF%E8%A7%80%E6%B8%AC%E5%AE%87%E5%AE%99">宇宙可觀測範圍</a> 是天文學家推論的理論值範圍，實務上人類可能到地球毀滅都還是走不出銀河系。</p></blockquote><hr><h2 id="整合測試的-可執行策略"><a href="#整合測試的-可執行策略" class="headerlink" title="整合測試的 可執行策略"></a>整合測試的 <code>可執行策略</code></h2><p>在軟體測試的過程，首先會依照上述的理論範圍規劃測試計畫？實務上不會，所以執行測試也就不會這樣做，因為勞民傷財。</p><p>實務上的 <code>執行策略</code> 都是根據核心情境，和 <code>核心功能 (Happy Path)</code> 展開，以此列出有關的排列組合，列出來的就是要放入測試計畫中執行的，這樣大概就可以扣除排列組合 70% 以上的範圍。這時候所謂的自動化進場才有實務上的價值。</p><p>以這次 iPhone 14 動態島來看，理論上測試計畫必須依照這個新的關鍵功能展開，列舉可能有關的功能組合。只要是跟畫面位置、動畫有關係的功能，應該都要列入測試範圍。所以以結果論來看，我會覺得蘋果的測試管理應該要加強。 XDD</p><p>那剩下的 70% 的組合怎麼辦？這時候所謂的 <code>探索性測試 (Exploratory Testing)</code> 或 <code>田野/現場測試 (Field Testing)</code> 就是扮演著重要的階段。實務上這兩種差異前者是 <code>Release 前 (In-House)</code>，後者是 <code>Run on Production</code>。我比較常用的是後者 Field Test，也就是 As a End User 的角度，直接像是鄉民那樣，試各種極端值，各種不合邏輯的排列組合。以前測 IoT 產品就是團隊全都人都發一套帶回家用，有問題直接回報。同時在辦公室也把了全部的產品，實際上在辦公室也在用。</p><p>現在很多公司其實是直接把探索性測試外包給 Youtuber &#x2F; KOL 處理，在產品 Release 前就先收回饋，避免到田野之後鄉民的反饋更大。因為 Youtuber &#x2F; KOL 可以幫忙擋 XDD</p><p>這概念跟 Unit Test 的邊界測試是一樣的。</p><hr><h2 id="說說測試管理"><a href="#說說測試管理" class="headerlink" title="說說測試管理"></a>說說測試管理</h2><p>軟體測試 的 Lead 有個很重要的任務：</p><blockquote><p>測試管理</p></blockquote><p>測試管理的工作範圍很大，其中之一是要定義：</p><ol><li>測試理論範圍</li><li>可執行的範圍</li><li>探索與現場測試策略</li></ol><p>定義這些範圍，才會有效地往下展開測試計畫、資源調度、有效執行、有效建議。<br>因為只有這樣，才能回答那句：</p><blockquote><p>為什麼這個沒有測到？</p></blockquote><hr><h1 id="延伸閱讀-站內"><a href="#延伸閱讀-站內" class="headerlink" title="延伸閱讀 (站內)"></a>延伸閱讀 (站內)</h1><ul><li><a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li><a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="https://rickhw.github.io/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></li><li><a href="/2023/05/23/About/2023-Software-Test-Practice/">新書上市 - 共同著作《軟體測試實務 I、II》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 “&lt;a href=&quot;https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/&quot;&gt;淺談軟體測試的階段與策略&lt;/a&gt;“ 整理了各種測試的 “階段”，其中 #整合測試 (Integration Test) 是常見的階段之一，針對 “整合” 我的脈絡有以下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;功能對功能&lt;/code&gt; 的整合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;系統對系統&lt;/code&gt; 的整合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;功能對系統&lt;/code&gt; 的整合&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;引用我 &lt;a href=&quot;https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/&quot;&gt;上次分享&lt;/a&gt; 整理的文字描述，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SQA/Integration-Test_Service-Test.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/&quot;&gt;演講：從理想、到現實的距離，開啟品味軟體測試之路&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;20230523 更新&lt;/code&gt;: 本文部分收錄在 &lt;a href=&quot;/2023/05/23/About/2023-Software-Test-Practice/&quot;&gt;共同著作《軟體測試實務》&lt;/a&gt; 第一冊 第五章之中，歡迎大家彭場指導。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="軟體測試" scheme="https://rickhw.github.io/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
    
    <category term="Software Test" scheme="https://rickhw.github.io/tags/Software-Test/"/>
    
    <category term="Published-SQA1" scheme="https://rickhw.github.io/tags/Published-SQA1/"/>
    
    <category term="Integration Test" scheme="https://rickhw.github.io/tags/Integration-Test/"/>
    
    <category term="Strategy" scheme="https://rickhw.github.io/tags/Strategy/"/>
    
  </entry>
  
  <entry>
    <title>Development Experience for Team</title>
    <link href="https://rickhw.github.io/2022/09/17/Management/Development-Experience-For-Team/"/>
    <id>https://rickhw.github.io/2022/09/17/Management/Development-Experience-For-Team/</id>
    <published>2022-09-17T02:30:00.000Z</published>
    <updated>2022-12-19T11:47:28.863Z</updated>
    
    <content type="html"><![CDATA[<p>整理對 Development Experience (DX) 的看法，原文草稿發表於 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02oAjkjeVHVcUTyiSeJzB1FutD6me2rBveFMVz9tpeASrXcvQfcCMbqpMDT64A49fel">Facebook</a>。</p><span id="more"></span><hr><h2 id="一、海賊王-D-之一族的傳說：定義-Developer-or-Development"><a href="#一、海賊王-D-之一族的傳說：定義-Developer-or-Development" class="headerlink" title="一、海賊王 D 之一族的傳說：定義 Developer or Development"></a>一、海賊王 D 之一族的傳說：定義 Developer or Development</h2><p>首先是 DX 這個詞 D 的定義，很容易被理解成 <code>Developer Experience (DX)</code>，而 Developers 通常指的是 <code>寫 Function / Feature 的人</code>。所以有各式各樣的想法、做法、工具，讓開發人員更順暢的工作、提升產能，像是 工程師喜歡 找了一堆工具來增加產能、或者讓工作更流暢，像是 VSCode 的 Extensions。</p><blockquote><ul><li>註一：<code>寫 Function / Feature 的人</code> 更精準的詞應該叫做 <code>Programmers</code>，而社群的鄉民會用 <code>Coders</code> 這個詞來調侃自己，而外界更普遍的用詞稱他們為 <code>Engineers</code>，但實際上 Engineers 其實包含其他像 QA &#x2F; Ops 等角色。</li><li>註二：關於 Developer vs Engineer 的差異，我個人的定義參閱 “<a href="/2017/07/01/Management/Developer-or-Engineer/">Developer vs. Engineer</a>“。</li><li>註三：啥是 Function &#x2F; Feature 以後再說。。。再歪樓下去我會收不了筆。。。</li></ul></blockquote><p>不過比起 Developer Experience，我覺得 <code>Development Experience</code> 更適當。Development 代表參與這個產品開發的團隊所有成員 (Team)，我在 “<a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a>“ 一文定義常見的角色有以下四大類：</p><ol><li><code>Planner</code>: PO &#x2F; PM &#x2F; UI&#x2F;UX &#x2F; SA &#x2F; Architect &#x2F; Developer</li><li><code>Executor</code>: SWE &#x2F; Programmer &#x2F; Coder</li><li><code>Accepter</code>: <a href="/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/">STE &#x2F; QA &#x2F; Tester &#x2F; SDET &#x2F; QE &#x2F; QoO</a></li><li><code>LiveKeeper</code>: Ops &#x2F; Infra &#x2F; <a href="/2018/08/03/DevOps/An-Introduction-to-SRE/">SRE</a> &#x2F; <a href="/categories/DevOps/">DevOps</a> &#x2F; SE &#x2F; IT &#x2F; MIS &#x2F; …</li></ol><blockquote><ul><li>其中 2), 3), 4) 統稱 Engineers。</li><li>中文很麻煩，當我寫 工程師 實際上想表達的是 Programmer，而對我來說，大部分的 <code>工程師</code> 都不能算是 <a href="/2017/07/01/Management/Developer-or-Engineer/">開發者</a></li><li><a href="https://software-engineering-at-google.gh.miniasp.com/#/">Software Engineering at Google</a> 這本書一開始提到 <code>工程 (Engineering)</code> 的定義，我自己的定義有兩個面向：<code>已知規模 (Known Scale)</code>、<code>可以擴展的規模 (Scalable)</code>。<ol><li>已知規模例，如 … 要建立捷運板南線、三峽大壩、台電輸配電工程、蓋 101 大樓  … 等已知的巨觀規模。</li><li>另外一種則是未知規模、但可以擴展成巨觀的能力，稱為可擴展 (Scalable)，軟體工程大多就是這種。</li><li>不管是已知規模、還是可擴展的規模，工程都必須具備的關鍵特性：<a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性 (Reliability)</a>。前述兩個定義，都要具備可靠性，才能稱之工程。</li></ol></li></ul></blockquote><p>這些成員，都是 Development Team 的一員。Programmer 有太多 DX 的方法、工具，但我覺得，整個團隊不是只有 Programmer 才是人，也應該關心一下，開發團隊其他成員的開發體驗。</p><ol><li>大家知道我們的 QA 是怎麼測試的？開始測試前應該具備哪些條件 (先不用談測試左移)？</li><li>大家知道 上線前、中 Ops &#x2F; DevOps 怎麼處理 Infra &#x2F; Build &#x2F; Deploy 的事情？上線後 Ops &#x2F; SRE 是怎麼處理線上異常與事件？應該怎樣改善這些體驗？</li><li>還有辛苦的 Planner (PO &#x2F; PM …) 是如何把需求收斂成可執行的規格的？</li></ol><p>這 <code>整個過程</code> 有體驗可言？怎麼改善這個過程的體驗，讓大家開發的協作有更順暢的體驗？</p><blockquote><p>Again, <a href="/2022/08/13/SQA/Path-to-Software-Testing/">品質是整個開發過程</a></p></blockquote><h3 id="DevOps？"><a href="#DevOps？" class="headerlink" title="DevOps？"></a>DevOps？</h3><p>歪個樓，大家常聽到的 <code>DevOps</code> 這個 BuzzWords，通常理解的都是狹義的 Development、或者一些文化之類的，也就是前一段提到的 “2), 4)” 的關係。</p><p>廣義的 DevOps 的 Dev 也不是單純講 Programmer，而是以公司角度來看的產品開發 (Product Development)，而 Ops 比較像是業務與營運單位。這個角度來看，我前面提到的四個角色都屬於 Development Team，而 Operation Team 則是把業務帶進來、讓客戶留下來的管理單位，像是業務、行銷、營運單位 … 等。</p><p>類似概念可以看我幾年前分享的演講 “<a href="/2019/04/27/DevOps/Introduce-to-Continuous-Delivery-2/">導讀持續交付 2.0 - 談當代軟體交付之虛實融合</a>“，有提到廣義 DevOps 的看法，如下圖：</p><p><img src="/images/DevOps/Introduce-to-CD20/p4-01.png"><br><img src="/images/DevOps/Introduce-to-CD20/p4-02.png"></p><hr><h2 id="二、Are-You-Experienced：是-誰-的體驗-Experience"><a href="#二、Are-You-Experienced：是-誰-的體驗-Experience" class="headerlink" title="二、Are You Experienced：是 誰 的體驗 (Experience)"></a>二、Are You Experienced：是 <code>誰</code> 的體驗 (Experience)</h2><p>標題引用 傳奇音樂家 Jimi Hendrix 最有名的專輯：<a href="https://en.wikipedia.org/wiki/Are_You_Experienced">Are You Experienced</a>，是音樂史的里程碑，重新定義了如何體驗音樂。AWS 2015 的 <a href="https://aws.amazon.com/blogs/aws/are-you-well-architected/">Well-Architected Framework</a> 介紹也引用這個概念。</p><p>談完 D 的定義，再來談談體驗 (Experience)，我想專注的是 “誰” 的體驗？</p><p>關於體驗，大家最常見的就是 <code>User Experience (UX)</code>，這個 User 指的是終端使用者 (End User)。最經典了例子就是 <code>開箱</code>，源自於 Apple 產品的體驗感，讓廣大鄉民都可以藉此寫寫廢文、找理由當 Youtuber、無腦下單 … etc。</p><p>承接上一段 Development 對象的定義，而對於 Programmer 而言，最常見的開箱就是：</p><ul><li>到 GitHub 找到一個 Open Source，透過 Quick Start &#x2F; Getting Started 快速體驗怎麼用，能否解決問題、或者有炫砲的感受。。。。</li><li>這十幾年全世界開發的份圍，體驗就是：一堆花花綠綠的 terminal、emoji、powerline … 等炫砲 …</li></ul><p>如果不容易讓人理解怎麼用，就會被跳過去，因為開箱體驗不好。</p><p>上述我覺得都是普遍的第一觀感，其實這些也滿重要的，雖然有時候覺得有點膚淺，但確實是會讓人更容易入門。</p><p>我覺得真正的開發體驗應該是這種，舉例以下幾種：</p><ul><li>第一個是 <a href="https://specflow.org/">SpecFlow</a>： 改善橫跨 PO &#x2F; Programmer &#x2F; Tester 針對規格的理解，與落地執行測試的方法。有了這個方法與概念，才有後面的工具產生。</li><li>第二個是 Containzied (Docker)：這個技術的出現，改善了交付的定義，讓所有角色 (四大) 都可以用統一個方法輕易的交付，終結 <code>在我的電腦可以跑，你的電腦不能跑</code> 的交付體驗。</li></ul><p>這兩個例子，都是軟體開發劃時代的體驗，我相信還有其他很多概念、方法、技術改善了團隊協作，增加效率。</p><p>另外語言層級的改善，像是 .NET6 從 v3.1 ~ v6 的改善，也是個不錯的案例。.NET Developer 如果 .NET 3.1 到 6 一路體驗下來，就可以感受到在 Language 層次的體驗，越來越精簡、越來越多語法糖，啟動 Startup.cs &amp; Program.cs 兩個變成只有一個 Program.cs，更簡單了，更容易理解了。類似的 DX 改善 node.js 生態系的就跑得更前面了。只是直接受惠者只有 Programmer。</p><p>以前哪些體驗不好，或者不好入門的工具，像是 vi &#x2F; git，則是因為本質夠強大，就有人會主動去改善它的體驗。</p><hr><h2 id="三、體驗，使用者的體驗"><a href="#三、體驗，使用者的體驗" class="headerlink" title="三、體驗，使用者的體驗"></a>三、體驗，使用者的體驗</h2><p>前面定義的四大角色，以及針對體驗的描述都是內在的東西。也就是每個角色，自己在開發過程的體驗如何，都是角色自己的角度出發。</p><p>體驗是動詞。</p><p>真正的體驗是以客戶的角度，體驗自己的產品，以電商為例：</p><ol><li>應該要去驗自己的產品，像是走完一家店的流程、到後台過商品、從 End User 角度下單、然後客戶角度去後台完成訂單流程</li><li>給客戶前，應該去用自己開發的 API，吃自己的狗食</li></ol><p>怎麼落實這種體驗感？什麼時候開始？上 Production 體驗？我的答案是：</p><blockquote><p>Containzied 技術的出現，已經滿足這種體驗的需求。</p></blockquote><blockquote><p>在上 Production 之前，不管是怎樣的應用程式、怎樣的架構，都要可以在一台電腦裡 (Linux)、用 Container 跑起來，走完所有業務邏輯。</p></blockquote><p>從設計與規劃階段，就要想這件事情，以終為始。還沒出貨之前，就已經完全可以從客戶角度，體驗整個產品。”<a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a>“ 一文最後談到這整個想法與脈絡。</p><p>體驗會讓我們產生行動與認同感。除了薪水，這是凝聚員工向心力與認同感最實際的方法。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>寫這篇背後是因為：</p><ol><li>資訊發達的時代，太多單一觀點，在決定所有角色的方向，忽略個別角色的角度。</li><li>單一觀點寫出來的東西，在網路流傳，如果那個人又有點名氣，整個世界就是被帶風向</li><li>團隊有好的開發體驗的同時，也要同步提升自我的<a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02oAjkjeVHVcUTyiSeJzB1FutD6me2rBveFMVz9tpeASrXcvQfcCMbqpMDT64A49fel">專業知識</a></li></ol><p>而我是少數經歷 經歷 Software Develpoer (國際外商)、SQA Manager &#x2F; SDET Lead (IoT 新創)、Operation &#x2F; Infrastructure Manager (電商新創)、Architect (電商新創) 等角色，而且每個角色都是全職的、經歷從零到一個過程，對於軟體開發體驗的觀點，有別於單一角色的觀點。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2017/07/01/Management/Developer-or-Engineer/">Developer vs. Engineer</a></li><li><a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性工程 (Reliability Engineering)</a></li><li><a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li><a href="/2019/04/27/DevOps/Introduce-to-Continuous-Delivery-2/">導讀持續交付 2.0 - 談當代軟體交付之虛實融合</a></li><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理對 Development Experience (DX) 的看法，原文草稿發表於 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02oAjkjeVHVcUTyiSeJzB1FutD6me2rBveFMVz9tpeASrXcvQfcCMbqpMDT64A49fel&quot;&gt;Facebook&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="DevOps" scheme="https://rickhw.github.io/tags/DevOps/"/>
    
    <category term="Developer Experience" scheme="https://rickhw.github.io/tags/Developer-Experience/"/>
    
    <category term="Development Experience" scheme="https://rickhw.github.io/tags/Development-Experience/"/>
    
    <category term="DX" scheme="https://rickhw.github.io/tags/DX/"/>
    
  </entry>
  
  <entry>
    <title>問題的難與雜</title>
    <link href="https://rickhw.github.io/2022/09/10/About/Difficult-and-Complicate/"/>
    <id>https://rickhw.github.io/2022/09/10/About/Difficult-and-Complicate/</id>
    <published>2022-09-10T13:42:30.000Z</published>
    <updated>2022-12-19T11:47:28.851Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0he6RNijEgMFY4pUcfWcUbJqRqZMmqw9pzHfCtw6gWQoG12b9YhZhZ2smMgJKEB7Jl">之前</a> 很常跟朋友分享這段想法，底下把想法記錄下來。</p><p>我把工作上遇到的問題分兩大類：</p><ol><li>雜 (Complicate)</li><li>難 (Defficult)</li></ol><span id="more"></span><h2 id="雜-Complicate"><a href="#雜-Complicate" class="headerlink" title="雜 (Complicate)"></a>雜 (Complicate)</h2><p>大部分的事一開始都是雜，大概有八七成都沒有章法、結構、組織。</p><p>雜的特性：</p><ol><li>沒有章法</li><li>沒有輕重</li><li>沒有邊界</li><li>沒有整理的資訊</li></ol><p>如果這種事需要快速決策、執行、驗收、上線，衍伸的現象就是亂、緊急、苦力、壓力，產生問題像債、負面情緒、導亂結構、破壞章法，最後是增加 <code>熵值</code>。</p><p>認識我久一點的人，會知道我是很龜毛的人，特別是一些章法、分類、組織 … 我看到亂的東西，就會想去<a href="https://rickhw.github.io/2014/10/26/Management/Classified-Philosophy/">整理、排序、類比、分類</a>。所以我自認為還滿擅長處理這種雜、亂的事情，只要一段時間之後，就會想用規則收斂，讓事情變成穩定狀態。只要雜的事經過這樣的程序 (有點像 ETL) 之後，大部分就可以變成規範。</p><p>所以在組織裡，用規範來約束不斷發散的亂 (或稱 <code>熵值</code> )，少量範圍這樣是有效的，可以有效的約束以及管控。但隨著時間的推演，實際上是不太可能做完的，因為規範是死的，人是活的，規範怎麼訂也訂不完，也無法完全落地，人則會來來去去、組織則會變來變去、業務方向會飛來飛去。</p><p>我也不可能、也沒時間跳下去全然協助，大多能給的是引導、啟發，讓大家發酵，或者是起孝。。。。XDD</p><p>雜事的特徵：</p><ul><li>發散，不知道邊界、需要理清全貌</li><li>會越做越亂、或莫名其妙就會變亂</li><li>做起來沒成就感</li><li>要整天賣笑 (我起笑比較多 XDD</li><li>慢了點就被幹樵</li><li>沒有歸屬感</li></ul><p>解法：</p><ol><li>divide and conquer (分而治之)</li><li>有核心規範、邊界的自組織 (中央政府、地方自治)</li></ol><!--#複雜 的層次圍不清楚、邊界模糊、關係紊亂、沒章法的執行、沒有層次的架構，這種複雜稱為 #亂  ...格局大、邊界清晰、依賴明確，有章法的專案管理，我稱為有組織、結構、架構性的 複雜 層次找出 #熵源 ... 讓他有章法、有原則的進行 .. 白話文：把樓歪回來--><h2 id="難-Defficult"><a href="#難-Defficult" class="headerlink" title="難 (Defficult)"></a>難 (Defficult)</h2><p>另外一種事，叫做難。</p><p>難的事分幾種:</p><ol><li><code>極致雜亂的難</code>: 當複雜到一定的極致, 我常會說: 這是 <code>n * m * q</code> 的問題 … 表達這是 <code>雜變亂、亂變難</code> …. 最後會變成棘手的問題 …. 要花十倍、甚至百倍以上的時間與資源，甚至根本就解不了。</li><li><code>工程的難</code>: 真正的難，需要有 <code>聰明才智</code> 才能解決的，像是想複雜的演算法.<ul><li>這種問題需要專家, 需要科學方法，需要科學家與工程師，也就是 <code>STEM</code> 領域專長的人才。</li></ul></li><li><code>棘手的難</code>: 通常是 1) + 2) + 人產生的問題，簡稱<code>政治</code>，需要智慧與手段。</li></ol><!--喜歡 = 熟悉 + 意外--><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇原文是我 <a href="https://rickhw.github.io/2014/10/26/Management/Classified-Philosophy/">2019&#x2F;10 交通時間</a> 敲下的想法，想表達生活中問題的普遍現象，工作上遇到大多的問題都是雜，少數是難。</p><p>而很多人覺得很難，通常有幾種：</p><ol><li>自身：能力不足、程度不夠</li><li>外在：管理問題，讓 <code>雜變亂、亂變難</code></li></ol><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://rickhw.github.io/2014/10/26/Management/Classified-Philosophy/">分類哲學</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0he6RNijEgMFY4pUcfWcUbJqRqZMmqw9pzHfCtw6gWQoG12b9YhZhZ2smMgJKEB7Jl&quot;&gt;之前&lt;/a&gt; 很常跟朋友分享這段想法，底下把想法記錄下來。&lt;/p&gt;
&lt;p&gt;我把工作上遇到的問題分兩大類：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;雜 (Complicate)&lt;/li&gt;
&lt;li&gt;難 (Defficult)&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Bus Memo" scheme="https://rickhw.github.io/tags/Bus-Memo/"/>
    
  </entry>
  
  <entry>
    <title>聊聊寫 Blog 的想法</title>
    <link href="https://rickhw.github.io/2022/09/05/About/Blog-Practice/"/>
    <id>https://rickhw.github.io/2022/09/05/About/Blog-Practice/</id>
    <published>2022-09-05T14:39:00.000Z</published>
    <updated>2023-06-19T13:10:06.211Z</updated>
    
    <content type="html"><![CDATA[<p>每個人對於寫 Blog 這件事情，都有自己背後的動機，我的初衷跟寫程式一樣，透過不斷的重構精練，這個過程是我學到最多的。</p><span id="more"></span><h2 id="動機"><a href="#動機" class="headerlink" title="動機"></a>動機</h2><p>最近跟朋友聊到寫 Blog 這件事情，每個人寫 Blog 的動機不一樣，我自己一直以來都是這個原則：</p><blockquote><p>Blog 的主要讀者是自己，反覆讀自己的文章，有錯就改，直到沒啥好改為止</p></blockquote><p>跟很多人寫 Blog 不一樣的就是：</p><blockquote><p>同一篇文章會反覆修正，不斷調整文章整體結構 (ToC)，紀錄修正歷程</p></blockquote><p>會回去反覆更新、調整文章，持續精練文章內容這是我自己跟很多人不一樣的。</p><p>大部分的人寫 Blog 比較像流水帳，只是記錄一些步驟、或者資訊，流過去的就過去了。但是每天都可以出一篇，甚至好幾篇，然後自己可能不會再閱讀、再修改。</p><p>少數的人一開始就會有目標的規劃整體目錄，像是寫微服務架構設計這樣的系列主題，然後一篇一篇的攻克，每一篇都是很長、有完整的結構與大綱 (ToC)，但是可能是半年寫一篇。</p><hr><h2 id="我的寫作方法"><a href="#我的寫作方法" class="headerlink" title="我的寫作方法"></a>我的寫作方法</h2><h3 id="第一種：拼圖式"><a href="#第一種：拼圖式" class="headerlink" title="第一種：拼圖式"></a>第一種：拼圖式</h3><p>隨時把一些片段的想法留下來，漸漸的拼出貼出完整的。</p><p>這個作法是以前我在做音樂創作時留下的習慣，那時候常常為了留下靈感，身邊隨時會帶著錄音筆，然後隨時會把想到的靈感，不管是旋律、還是詞句，隨時錄下來。後來手機普及了，臉書流行了，這個習慣就換了個媒介。</p><p>每個片段的想法都是在瑣碎時間寫下的，通常是交通時間、一些等待的時間，在 FB 留下的想法。</p><p>片段想法累積數個之後，一段時間我就會開始重組這些東西，過程就是把寫得很散的東西，不斷的重新組織、安排段落、調整文章的 <code>Table of Context (ToC)</code>，補充不足的地方，最後集結成文。像是 <a href="/tags/Bus-Memo/">公車隨筆</a> 、<a href="/tags/Learning-Approaches/">寫作與閱讀系列文</a>、<a href="/tags/%E6%BA%9D%E9%80%9A/">溝通</a>、<a href="/tags/Meetings/">會議效率</a> … 等。</p><p>舉例 <code>學習、寫作、閱讀系列文章</code> 累積的比較多篇，如下：</p><ol><li><a href="/2019/01/20/About/Reading/">閱讀能力的重要性</a></li><li><a href="/2017/06/29/Management/Why-Document/">為什麼寫文件？</a></li><li><a href="/2019/04/03/Management/Write-Document/">再談『為什麼寫文件？』</a></li><li><a href="/2019/03/10/DevOps/Continuous-Delivery-Docs/">文件的持續交付</a></li><li><a href="/2020/05/09/Management/Problems-in-Documentation/">寫文件常見的問題</a></li><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2019/06/08/About/Spotlight-Phenomenon/">Spotlight 現象</a></li><li><a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></li><li><a href="/2019/10/24/Management/Learning-From-Amazon/">從 Jeff Bezos 與 Werner Vogels 學到的</a></li></ol><h3 id="第二種：一口氣"><a href="#第二種：一口氣" class="headerlink" title="第二種：一口氣"></a>第二種：一口氣</h3><p>這種寫法大多有一個很明確的問題、動機，像是聽完某些人分享心得的共鳴、或者朋友提問，好問題就很想把想法留下來、跟朋友討論想法後的心得 … 等。這類型通常就是一口氣寫下完整的文章。</p><p>這類型的文章，在討論的過程，大部分我腦袋就會逐漸組成文章的 ToC 了，過程通常會留下關鍵字，如果身邊有電腦，則會順手敲下關鍵字，以利事後整理。如果是在線上用 IM 聊天，通常會告訴對方，我會記錄這段過程在 Blog 分享。</p><p>像是這篇 <a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a> 就是完全把在 Messager 的對話記錄下來的。現在這篇 <code>聊聊寫 Blog 的想法</code> 本身也是同樣的案例，<a href="https://www.facebook.com/completethink/posts/pfbid02WmQLU9gCZ5MyMSWu2aJuVhZyU782DQjc3oo5ici21us2Cb9j2fHAJKQvBuNMCv4Bl">初稿</a> 寫在部落格粉專上，後續持續整理與改善。</p><p>更多則是 <a href="/categories/DevOps/">DevOps &#x2F; SRE 相關文章</a> 裡面的每一篇，大多都是這樣背景下寫的東西。</p><h3 id="第三種：有計劃"><a href="#第三種：有計劃" class="headerlink" title="第三種：有計劃"></a>第三種：有計劃</h3><p>我比較少一次寫很長的文章，通常看到很長的文章，都是經過不斷修正、精煉、累積後整理出來的，像是這幾篇：</p><ol><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a></li><li><a href="/2016/04/07/AWS/Study-Notes-S3/">AWS S3</a></li></ol><p>可以看看文章右上角的 Table of Context，大概就可以知道這幾篇都有花不少時間調整的，舉例學習法則的 ToC：</p><p><img src="/images/About/ToC-2022.png"></p><p>整個結構是有先後續、有脈絡的在整理。</p><p>也有刻意為之的系列文，像是 <a href="/2018/08/20/Management/Overview-Hiring/">人力招募系列</a>、<a href="/2021/04/07/DistributedSystems/Dapr-Concepts-and-Designing/">Dapr 系列</a>、<a href="/2016/10/01/AWS-Study-Roadmap/">AWS</a> 很多都是。</p><h3 id="從點變成面：組織成系列文"><a href="#從點變成面：組織成系列文" class="headerlink" title="從點變成面：組織成系列文"></a>從點變成面：組織成系列文</h3><p>當同一個類型的文章寫了好幾篇之後，就可以 Grouping 成有系統、有組織的系列文，有些數量多到一定程度，會需要透過 mindmap 整理全貌，我這裡的例子就是 <a href="/2016/10/01/AWS-Study-Roadmap/">AWS 全系列</a> 整個文章，是過去幾年我花最多心思的。</p><p>另外也越來越多的 <a href="/categories/DevOps/">DevOps &#x2F; SRE</a>、 <a href="/2017/07/01/Index-Management/">經營管理</a>、<a href="/2017/07/01/Index-Software-Engineering-In-Practice/">軟體工程實踐</a>、<a href="/categories/Distributed-Systems/">分散式系統</a> 也是整個套系列，就差還沒畫成甘特圖。每一篇都是一個點，點跟點之間都可以連結起來，就像 <a href="https://twitter.com/hughcards/status/423952995240648704">Hugh MacLeod</a> 這張圖：</p><p><img src="/images/About/Learning-Approaches/Knowledge_Experience.png"></p><p>這個過程，會回去不斷調整每篇文章的 ToC，調整系列的目錄，從目錄就可以看出全貌，也就是知道自己還缺什麼。</p><h2 id="精煉"><a href="#精煉" class="headerlink" title="精煉"></a>精煉</h2><p><code>精煉</code> 是一個去蕪存菁的過程，以前在寫音樂部落格的時候，我真的精煉過不少東西，舉例來說：</p><ol><li><a href="https://rickmidi.blogspot.com/2008/08/minor-scale.html">小調音階 (Minor Scale)</a>、<a href="https://rickmidi.blogspot.com/2010/10/major-scale.html">大調音階 (Major Scale)</a>: 這兩篇大概是我精煉過深度最深的內容，文中提到的專有名詞、用詞、定義，都有花過很多時間查閱專門書籍，像是音樂系的教科書、論文、Wikipedia … 等，但是裡面也描述了我自己個人很深刻的體悟。</li><li><a href="https://rickmidi.blogspot.com/2010/04/chord-voicing.html">吉他的和弦聲位基本概念 (Chord Voicing)</a>、<a href="https://rickmidi.blogspot.com/2010/06/blog-post.html">升降記號</a>、<a href="https://rickmidi.blogspot.com/2010/03/canon-chord-progression.html">卡農進行 (Canon Chord Progression)</a>、 <a href="https://rickmidi.blogspot.com/2009/08/blog-post_16.html">吉他的基本功</a>: 這幾篇則是我自己不斷反覆淬鍊出來的心法，完全是我自己的想法經過不斷打磨，最後系統化出來的</li></ol><p>精煉就是要挑惕，挑惕每個用詞、每一句話，整體結構，深入了解每個名詞背後的意涵，深入體驗每一句話的感受。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這個 Blog 取名 <a href="/2017/12/29/About/About-This-Blog/">Complete Think</a>，我在文中描述到兩個字背後的意涵，其中 <code>Complete</code> 背後意味著：</p><blockquote><p>代表目標，持續往完整走。</p></blockquote><p>也就持續往完整的方向前進，寫 Blog 動機是記錄自己的想法，過程中不斷組織、重構他們，讓想法越來越具體、越來越系統的過程 … 而核心想法就是持續的、精煉想法，讓這些東西最後可以經的起時間的考驗。</p><p>最後用 <a href="https://www.youtube.com/watch?v=WUUjU4Om0KI">Steve Jobs 在 2005 在 Stanford 演講</a> 的名句：</p><blockquote><p>You can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.</p><p>你無法預先把現在所發生的點點滴滴串聯起來，只有在未來回顧今日時，你才會明白這些點點滴滴是如何串在一起的。</p></blockquote><p>我把這句話改成這樣：</p><blockquote><p>每一篇文章都是一個點，只要回頭反覆閱讀、改善並連結他們，未來的今日，這些點點滴滴會串起不一樣的自己。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;每個人對於寫 Blog 這件事情，都有自己背後的動機，我的初衷跟寫程式一樣，透過不斷的重構精練，這個過程是我學到最多的。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Career" scheme="https://rickhw.github.io/tags/Career/"/>
    
    <category term="Blog" scheme="https://rickhw.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>演講：從理想、到現實的距離，開啟品味軟體測試之路</title>
    <link href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/"/>
    <id>https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/</id>
    <published>2022-08-13T05:33:00.000Z</published>
    <updated>2023-05-27T04:54:32.125Z</updated>
    
    <content type="html"><![CDATA[<p>今天很高興在 <a href="https://www.seat.org.tw/event/2022testing">台灣軟體工程協會</a>，成功大學 <a href="https://www.facebook.com/shinjielee">李信杰</a> 老師的邀請之下，讓我第一次分享關於軟體測試的想法與心得。</p><p>在投入 <code>軟體測試 (Software Testing)</code> 與 <code>軟體品質 (Software Quality Assurance, SQA)</code> 之前，我主要的工作角色是 <code>軟體開發</code> 為主，程式語言以 PHP &#x2F; Java &#x2F; Python、開發大型 Jave Enterprise Application 應用程式與 Eclipse Plugins 為主。過程中因為協助測試團隊改善 Application UI &#x2F; WebUI 測試，因而踩入測試領域。</p><p>因為本身是具備開發背景，踩入軟體測試有別於一般人經歷，因此開啟不一樣的路。實際軟體測試的經歷，包含 WebUI &#x2F; Desktop UI &#x2F; Unit Test &#x2F; E2E … 等自動化測試，設計與開發大型 “<a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Test Framework and Architect for Regression Test</a>“ 實務經驗。</p><p>這段經歷讓我對軟體測試的 <code>技術與工程面</code> 有很完整的歷鍊，所以後來也挑戰 在新創事業 (IoT 領域) 從零開始 <code>建立軟體測試團隊</code>，從團隊建立、制度、流程、工程、協作，建立完整的開發流程，其中領悟出最重要的 <a href="/2017/12/02/About/Epiphany/">心法</a> 就是 <code>品質</code> 的想法，因此寫下以下領悟：</p><blockquote><p>品質不只有測試，而是整個 (開發) 過程。<br>品質從需求開始，測試只是種手段<br>用品質建立數量，由數量產生速度。</p></blockquote><span id="more"></span><h2 id="簡報與錄影"><a href="#簡報與錄影" class="headerlink" title="簡報與錄影"></a>簡報與錄影</h2><iframe src="//www.slideshare.net/slideshow/embed_code/key/8WoBPlHEiHbCk1" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/rickhwang/the-path-in-software-testing" title="從理想、到現實的距離，開啟品味軟體測試之路 - 台灣軟體工程協會 (20220813)" target="_blank">從理想、到現實的距離，開啟品味軟體測試之路 - 台灣軟體工程協會 (20220813)</a> </strong> from <strong><a href="//www.slideshare.net/rickhwang" target="_blank">Rick Hwang</a></strong> </div><iframe width="560" height="315" src="https://www.youtube.com/embed/WAK-kMzi8wc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="現場問答"><a href="#現場問答" class="headerlink" title="現場問答"></a>現場問答</h2><p><img src="/images/SQA/Path-in-Software-Testing/Q01.png"></p><blockquote><p>答: 從了解產品角度切入，了解產品帶給使用者有什麼價值切入。加上 DevOps &#x2F; SRE 對於系統有了解，所以可以從整合測試切入。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q02.png"></p><blockquote><p>答：我覺得測試工作本質上就要敏捷，也就是主動跟協作對象 (PM &#x2F; Dev &#x2F; Ops) 建立溝通的循環。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q03.png"></p><blockquote><p>答：<a href="https://www.books.com.tw/products/0010623556">Google軟體測試之道：進行Google級的軟體測試</a>, <a href="https://www.books.com.tw/products/CN11052516">簡中</a></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q04.png"></p><blockquote><p>答：請參閱這篇 <a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？</a></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q05.png"></p><blockquote><p>答：請參閱這篇 <a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q06.png"></p><blockquote><p>答：如果已經有開發經驗，可以參考我的經歷，從幫忙測試團隊開始，協助改善自動化測試的流程，從過程中取得成就感，真的有興趣再轉。如果是針對 “自動化” 這個技能相關的職能就不只是 QA，DevOps &#x2F; SRE 也都是大量需要自動化的工作。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q07.png"></p><blockquote><p>答：JMeter、K6、ddosify、apache ab、stress-ng，請參閱這篇 “<a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？</a>“</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q08.png"></p><blockquote><p>答：</p><ul><li><ol><li>如果可以的話，在訪談過程中，讓 QA &#x2F; Dev 都參與討論，理解需求是需要時間的，所以可以建議一起參與。</li></ol></li><li><ol start="2"><li>敏捷開發 有很多框架，像是 Scrum &#x2F; 看板 &#x2F; LeSS … etc。其實 QA 要維持的原則沒有變：前期了解需求、針對需求提出想法與疑問、橫向跟 PM &#x2F; Dev 討論需求。這點其實跟用什麼開發方法沒啥關係。</li></ol></li><li><ol start="3"><li>不會寫程式比較吃虧的是對於非功能測試比較難切入，長期來看，對於培養產品靈敏度，可以延伸發展的方向則是 PM &#x2F; PO 的方向。如果會寫程式，發展方向則會更廣，像是 SDET &#x2F; SRE &#x2F; DevOps 甚至 Architect。</li></ol></li></ul></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q09.png"></p><blockquote><p>答：我在前期算是很幸運，有掌握整個開發流程的核心，前半年算順利。接下來就是團隊磨合期，像是 Dev &#x2F; QA 雙方對於問題看法的磨合，漸漸模出默契，大家都理解 Spec 很重要，從爭議 &#x2F; 爭論轉化成討論 &#x2F; 找到共識，過程大概有半年的長度。</p><p>後期 (約第三年的時候) 最大的 bottleneck 就是找到會寫 Code 的 QA，也就是 SDET，隨著產品功能越多，需要 Regression 的範圍就變大，所以有效的保護就重要了，但是實際上要追需要有適當的人到位才行，這時候人才就是關鍵了，不然只能自己跳下去賣肝 XD</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q10.png"></p><blockquote><p>答：看公司。不過建議至少要會 shell script、python，能夠寫簡單的自動化測試，像是自動取得 API 資訊，然後篩選資料，丟給下一個 script 處理 … 等。新人我以前面試一定會考三個： <a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">shell script</a> 觀念、Linux、SQL、HTML。例如用這些東西自動安裝 Wordpress、確認 Wordpress 安裝完成。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q11.png"></p><blockquote><p>答：不是很確定 <code>內聚性</code> 的意思是什麼，我猜應該是指軟體設計的 <code>高內聚、低耦合</code> 的概念。這在軟體設計階段就需要分析清楚的，通常在 System Design 就會確立每個系統元件的邊界與依賴關係，用程式碼來說就是 OOP 裡，怎樣定義一個 Class，定義好之後，就可以做單元測試。Class 可以做單元測試代表具備一定的內聚力，以及低耦合。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q12.png"></p><blockquote><p>答：<code>大型重構</code> 我猜你的意思是背後的主要結構已經改變，像是 DB Schema 做 Breaking Change、架構做了很大的改變之類的。依照不同層次改動的比例，三者都要有對應的調整。但如果是架構改變，那問題可能就不是測試三角形可以處理的層次，通常要搞定的是 Migration 策略。因為如果是已經在線上跑的服務，需要安排分階段執行以及 Rollback 計畫。可能不是測試團隊可以單純搞定的。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q13.png"></p><blockquote><p>答：大家對於需求或規格認知不一樣的時候，就會討論這個 Bug or Feature？像這張圖一樣：<br><img src="/images/SQA/Path-in-Software-Testing/Q13-Dev-Tester.JPG"></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q14.png"></p><blockquote><p>答：所有角色。</p></blockquote><h2 id="摘錄簡報重點"><a href="#摘錄簡報重點" class="headerlink" title="摘錄簡報重點"></a>摘錄簡報重點</h2><p><img src="/images/SQA/Path-in-Software-Testing/Strategies-for-Test-Praymid.png"><br><img src="/images/SQA/Path-in-Software-Testing/Strategies-for-Test-Praymid-And-Company-Phase.png"><br><img src="/images/SQA/Path-in-Software-Testing/Strategies-for-Functional-NonFunctional.png"><br><img src="/images/SQA/Path-in-Software-Testing/Functional-and-NonFunctional.png"><br><img src="/images/SQA/Path-in-Software-Testing/About-Quality-by-Rick.png"></p><h2 id="感謝"><a href="#感謝" class="headerlink" title="感謝"></a>感謝</h2><p>兩週前，跟李老師在討論事情，突然說想邀請我分享軟體測試的一些心得。本來想說只有兩週，應該會爆肝，但問了一下 TA 是在學同學，突然一種使命感油然而生，然後就答應了 XDD …. (肝表示 ….)</p><p>雖然 Blog 已經有很多素材可以用，不過還是花了一點時間針對在學同學設計內容。每次演講，我都希望帶給聽眾的，不是怎麼去用什麼工具、步驟是什麼，而是聽完之後，能夠有所啟發，這個啟發是過了幾年之後，都依舊受用，這些觀念也是我在 “<a href="/2017/11/26/Thinking-in-Essence/">思考本質、實踐、抽象、想像力</a>“、”<a href="/2017/09/20/About/Learning-Approaches/">學習法則</a>“ 反覆提及的。</p><p>這場分享主要 TA 是在學同學與社會新鮮人，構思的時候我就在想：</p><blockquote><p>如果我現在可以回到廿年前，那我想要告訴那時候的我，怎麼做選擇。</p></blockquote><p>所以演講的構思以 “<a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a>“ 為主軸，測試金字塔主要藍圖、”<a href="/2018/03/18/SQA/Gossip-System-Testing/">系統測試的三兩事</a>“ 提到的 <code>功能與非功能</code> 為輔助，引導新鮮人啟發探索職涯的可能性。</p><p>這次也認識了另外一位講者：<a href="https://www.facebook.com/loverjersey">Jersey Su</a>，精湛的摘要測試左移的一些脈絡，也告訴同學如何透過探索與刻意練習提升自己，這些想法都讓我非常有感，未來有機會再繼續分享心得～</p><h2 id="20230523-更新"><a href="#20230523-更新" class="headerlink" title="20230523 更新"></a>20230523 更新</h2><p>本次演將內容，部分收錄在 <a href="/2023/05/23/About/2023-Software-Test-Practice/">共同著作《軟體測試實務》</a> 第一冊 第五章之中，歡迎大家彭場指導。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li>軟體測試相關：<ul><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li><li><a href="/2014/05/09/SQA/Problems_In-Software-Autotest/">軟體自動化測試常見的問題</a></li><li><a href="/2017/12/03/SQA/Regression-Test-Is-Tough/">從 iOS 無限黑屏事件，談軟體測試階段 - 回歸測試 Regression Test</a></li><li><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></li><li><a href="/2018/03/18/SQA/Gossip-System-Testing/">輕鬆聊：系統測試 (SVT) 的三兩事</a></li><li><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></li><li><a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？（壓測）</a></li><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li><a href="/2023/05/23/About/2023-Software-Test-Practice/">新書上市 - 共同著作《軟體測試實務 I、II》</a></li></ul></li><li>軟體開發<ul><li><a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li><a href="/2017/09/03/Management/Phases-in-Startup/">不同階段的企業</a></li></ul></li><li>成長<ul><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2017/11/26/Thinking-in-Essence/">思考本質、實踐、抽象、想像力</a></li></ul></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://martinfowler.com/articles/practical-test-pyramid.html">The Practical Test Pyramid</a> - martinfowler.com</li><li><a href="https://www.gushiciku.cn/pl/2FYW/zh-tw">什麼是測試左移（Shift-Left testing）？</a></li><li><a href="https://www.businessweekly.com.tw/management/blog/26187">飛輪效應》如何花更少力氣，推動公司更高速運轉</a> - 商周</li><li><a href="https://www.hexschool.com/2022/06/23/2022-06-23-software-engineer-salary/">軟體工程師薪水</a> - 六角學院</li><li><a href="https://zh.wikipedia.org/zh-tw/PDCA">PDCA</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天很高興在 &lt;a href=&quot;https://www.seat.org.tw/event/2022testing&quot;&gt;台灣軟體工程協會&lt;/a&gt;，成功大學 &lt;a href=&quot;https://www.facebook.com/shinjielee&quot;&gt;李信杰&lt;/a&gt; 老師的邀請之下，讓我第一次分享關於軟體測試的想法與心得。&lt;/p&gt;
&lt;p&gt;在投入 &lt;code&gt;軟體測試 (Software Testing)&lt;/code&gt; 與 &lt;code&gt;軟體品質 (Software Quality Assurance, SQA)&lt;/code&gt; 之前，我主要的工作角色是 &lt;code&gt;軟體開發&lt;/code&gt; 為主，程式語言以 PHP &amp;#x2F; Java &amp;#x2F; Python、開發大型 Jave Enterprise Application 應用程式與 Eclipse Plugins 為主。過程中因為協助測試團隊改善 Application UI &amp;#x2F; WebUI 測試，因而踩入測試領域。&lt;/p&gt;
&lt;p&gt;因為本身是具備開發背景，踩入軟體測試有別於一般人經歷，因此開啟不一樣的路。實際軟體測試的經歷，包含 WebUI &amp;#x2F; Desktop UI &amp;#x2F; Unit Test &amp;#x2F; E2E … 等自動化測試，設計與開發大型 “&lt;a href=&quot;/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/&quot;&gt;Test Framework and Architect for Regression Test&lt;/a&gt;“ 實務經驗。&lt;/p&gt;
&lt;p&gt;這段經歷讓我對軟體測試的 &lt;code&gt;技術與工程面&lt;/code&gt; 有很完整的歷鍊，所以後來也挑戰 在新創事業 (IoT 領域) 從零開始 &lt;code&gt;建立軟體測試團隊&lt;/code&gt;，從團隊建立、制度、流程、工程、協作，建立完整的開發流程，其中領悟出最重要的 &lt;a href=&quot;/2017/12/02/About/Epiphany/&quot;&gt;心法&lt;/a&gt; 就是 &lt;code&gt;品質&lt;/code&gt; 的想法，因此寫下以下領悟：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;品質不只有測試，而是整個 (開發) 過程。&lt;br&gt;品質從需求開始，測試只是種手段&lt;br&gt;用品質建立數量，由數量產生速度。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="軟體測試" scheme="https://rickhw.github.io/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
    
    <category term="Software Test" scheme="https://rickhw.github.io/tags/Software-Test/"/>
    
    <category term="SDLC" scheme="https://rickhw.github.io/tags/SDLC/"/>
    
    <category term="SQA" scheme="https://rickhw.github.io/tags/SQA/"/>
    
    <category term="SVT" scheme="https://rickhw.github.io/tags/SVT/"/>
    
  </entry>
  
  <entry>
    <title>Happy Path and Unit Test</title>
    <link href="https://rickhw.github.io/2022/07/30/SoftwareEngineering/HappyPath-and-UnitTest/"/>
    <id>https://rickhw.github.io/2022/07/30/SoftwareEngineering/HappyPath-and-UnitTest/</id>
    <published>2022-07-30T01:50:30.000Z</published>
    <updated>2022-12-19T11:47:28.870Z</updated>
    
    <content type="html"><![CDATA[<p><code>測試金字塔</code> 是很多書、很多演講都會提的概念，從上到下是 E2E、Integration、Unit Test，佔比也是這個次序。</p><p><img src="/images/SQA/The_Test_Pyramid.png"></p><p>很多大神、知名的軟體教練、傳教士、訪間的訓練機構也都一再強調 Unit Test (以下簡稱 UT) 的重要，經過幾年的宣導與討論，基本上，現在很多軟體工程師都自己會先做 Unit Test，或者在跑 Scrum 時都有出現 Task 內容是要做 Unit Test。對於整個軟體產業而言，是個很好的現象。</p><p>這年代跑 Scrum 也越來越普遍，大家也有意識到一個 Scrum Team 就是在做一個產品，大概就像 <code>天龍特攻隊</code> (A Team) 、或者是阿湯哥 <code>不可能任務</code>、或者一個 <code>搖滾樂團</code> ，都是 Team Work，理論上，要交付的是一個共同的價值。</p><span id="more"></span><h2 id="Unit-Test-不重要？"><a href="#Unit-Test-不重要？" class="headerlink" title="Unit Test 不重要？"></a>Unit Test 不重要？</h2><p>最近我在工作時，反覆的跟同仁講一段事情：</p><blockquote><p>我同意 Unit Test 很重要，<br>但是如果東西交到使用者手上的 Happy Path 不能跑，<br>那做了這麼多 Unit Test 就很可惜。</p></blockquote><p>講的過程，我盡量把用詞修飾的比較不會有太大衝擊，因為普遍工程師已經接受傳教士的說法，避免誤解成：</p><blockquote><ul><li>Rick 說我的 UT 都在做白工 QQ…</li><li>是 Rick 叫我不要寫 UT 啊</li></ul></blockquote><p>而我講的重點就在於 <code>次序</code>、<code>循環</code>：</p><blockquote><ol><li>Happy Path 要 <code>先</code> 能動</li><li><code>然後</code>，把 Unit Test 補齊</li></ol></blockquote><p>如果先把 UT 做到 100% 涵蓋率，但是 Happy Path 一個都不能跑，這表示什麼？這個產品不能用，而且死線就在哪裡。</p><p>但如果一開始先讓 Happy Path 能跑，跑法可能很髒、很醜、很蠢 … 都沒關係，過程中持續補齊 UT、然後持續修補 Happy Path 的跑法。最後 UT 不管有沒補完，Happy Path 依舊可用的，次序與循環都有了。</p><h2 id="案例一：非功能性的-Happy-Path"><a href="#案例一：非功能性的-Happy-Path" class="headerlink" title="案例一：非功能性的 Happy Path"></a>案例一：非功能性的 Happy Path</h2><p>第一個案例是一個專案在即將上線的一前一週，早上站立時，同仁反映應用程式放到 K8s 跑不起來，問題可能是一些 lib 依賴衝突造成的，但是本機跑不會有這樣的問題。</p><p>經過一些討論與嘗試，幾天後問題找到暫解法。姑且不論技術問題，算是暫時把部署到 K8s 的狀況解除。說明過程，我刻意把技術問題淡化，而強調 <code>發現的難度</code> 與 <code>發現的時間點</code>。</p><p>後來我跟同仁說我對這件事情的看法：</p><ol><li>這個技術問題 (依賴 Lib) 本身問題不大，只要給你們時間，很快就能解決</li><li>這個問題如果可以早一點發現會比較好，因為不難發現</li></ol><p>我帶出一個觀念，是我自己想的一段口號：</p><blockquote><p>Deliver Hello World in First Day</p></blockquote><p>在這篇文章 “<a href="https://rickhw.github.io/2022/04/06/SoftwareEngineering/Artifact-Management-and-Version-Control/">Version Control 與 Artifact Management</a>“ 有提到這個觀念。</p><h2 id="案例二：功能性的-Happy-Path"><a href="#案例二：功能性的-Happy-Path" class="headerlink" title="案例二：功能性的 Happy Path"></a>案例二：功能性的 Happy Path</h2><p>延續案例一，好不容易推上 K8s 了，登入系統後，發現功能全部都不能動 … 又是一個同樣的案例：</p><blockquote><p>我的電腦可以跑、你的電腦不能動</p></blockquote><p>這次是 <code>功能性 (Functional)</code> 的，案例一則是 <code>非功能性 (Non-Functinal)</code> 的，然後明天就要上線了。</p><p>背後技術問題是：使用新的前端技術，無法正確讀取 config。同樣的，大家又一起討論，找了一些 Workaround，先把問題處理掉。</p><p>同樣的延續案例一，跟大家分享了我的看法：</p><ol><li>這個技術問題 (前端取得 config) 本身問題不大，只要給你們時間，很快就能解決</li><li>這個問題如果可以早一點發現會比較好，因為不難發現</li></ol><p>(copy and paste … XD)</p><h2 id="案例三：示範給大家看"><a href="#案例三：示範給大家看" class="headerlink" title="案例三：示範給大家看"></a>案例三：示範給大家看</h2><p>案例一、二發生後，我跟大家分享我對整件事情的看法，過程中其實我心裡有點掙扎的事，要不要說這些話。後來我還是覺得應該要講，而且是對全 Team (about 20)</p><p>我說完這段想法之後，不要光說不練，所以親自下去做了幾件事情，我挑了手上六條線的專案中的一項，快速確認 Happy Path 能跑、怎麼跑、有哪些東西缺乏的，不用三十分鐘，開出四、五張 defects</p><p>這些問題差不多：</p><ol><li>你的電腦可以跑，我的電腦不能跑</li><li>最基本的 Path 跑不起來</li></ol><p>(這次就不 c &amp; p 了)</p><h2 id="定義-Happy-Paths-與交付"><a href="#定義-Happy-Paths-與交付" class="headerlink" title="定義 Happy Paths 與交付"></a>定義 Happy Paths 與交付</h2><p>我個人定義的 Happy Path 有幾個 <code>必要的限制</code>，或者說 <code>條件</code>：</p><h3 id="1-一定是透過-Artifact-跑起來"><a href="#1-一定是透過-Artifact-跑起來" class="headerlink" title="1) 一定是透過 Artifact 跑起來"></a>1) 一定是透過 Artifact 跑起來</h3><ol><li>避免你的電腦可以跑、我的電腦不能跑</li><li>Build Process 是正常的</li><li>CI 這段要先做到，後面的程序才有意義。</li></ol><p>這段是我定義的 <code>交付</code> ，不是虛的那種價值交付，而是實體軟體檔案的交付。任何軟體開發、軟體工程，最後都需要把東西叫給下一棒，不管是內部的工程師、還是外部客戶、還是後面的自動化程序。Artifact 就是標準的交付介面。有了這段，才有後使用上的價值可言。</p><h3 id="2-Happy-Path-一定是-黑箱測試，先驗證應用程式的-內聚力"><a href="#2-Happy-Path-一定是-黑箱測試，先驗證應用程式的-內聚力" class="headerlink" title="2) Happy Path 一定是 黑箱測試，先驗證應用程式的 內聚力"></a>2) Happy Path 一定是 <code>黑箱測試</code>，先驗證應用程式的 <code>內聚力</code></h3><ol><li>假設 App 功能還沒好了，重點在於驗證 功能正確性，強調的是 App 的 <code>內聚力</code>。<ul><li>熟悉 UT 的人應該可以感覺到這段話的核心思想，與 UT 是一樣的。</li></ul></li><li>這個階段 <code>不處理</code> 外在環境因素 (非功能)，像是放到 K8s or Cloud &#x2F; DB HA &#x2F; 網路架構 &#x2F; Cache … etc.<ul><li>只要有個標準就好，像是透過 docker 跑起來、或者 binary 跑起來即可。</li></ul></li></ol><blockquote><p><code>測試策略</code> 的 <code>內聚力與耦合性</code> 概念，參閱 <a href="https://rickhw.github.io/2018/03/18/SQA/Gossip-System-Testing/">系統測試的三兩事</a> 介紹。</p></blockquote><h3 id="3-Happy-Path-是-UAT-的其中一環"><a href="#3-Happy-Path-是-UAT-的其中一環" class="headerlink" title="3. Happy Path 是 UAT 的其中一環"></a>3. Happy Path 是 UAT 的其中一環</h3><ol><li>UAT 的目的是出貨前要做的驗證，包含 Happy Paths 與 Regression 的項目</li><li>Happy Path 包含功能與非功能的部分，非功能的就是 Artifact、功能性的就像登入、註冊 … 這些基本功能</li></ol><h2 id="測試金字塔-該怎麼落實？"><a href="#測試金字塔-該怎麼落實？" class="headerlink" title="測試金字塔 該怎麼落實？"></a>測試金字塔 該怎麼落實？</h2><p>回到一開始的金字塔，問題要改成：</p><blockquote><p>怎麼落實、怎麼執行測試金字塔的概念</p></blockquote><p>做軟體開發的公司千百家，但是可以稱得上是 軟體公司 的，可能為數不多，大多都是專案驅動 (死線驅動 DDD)，產品驅動較少，重視軟體工程就更少了。</p><p>我自己待過很大的國際級軟體公司，走過理想的金字塔；也待過從無到有的新創公司，面對過實際的狀況， (故事放在 <a href="https://rickhw.github.io/2019/10/30/SQA/Problems-In-Software-Testing/">這篇文章</a> 的最後一段)，但是這兩種公司在軟體開發最後都有一樣要面對問題：</p><blockquote><ul><li>內部怎麼認定這東西是好了？</li><li>怎麼把東西交到客戶手上？</li><li>客戶怎麼用這個東西？</li><li>產品對客戶真的能夠提供價值？</li></ul></blockquote><p>能動了，利用 Unit Test 有效的保護各個 function &#x2F; module 的邊界，反覆修正 Happy Paths 的執行效能，有了這樣的循環，金字塔自然會成行。</p><p>而這個概念，根 UT 一開始的概念不是一樣？先不寫功能，先寫測試，然後把每次跑測試的錯誤，一一修復，最後修完，也代表功能寫好了。只是 UT 處理的是顆粒度較小的 function，而 Happy Path 處理的是整個 Application。</p><p>所以我認為落實金字塔的方法就是：</p><blockquote><p>建立 UT 與 Happy Path 的循環，<br>驅動這個循環的則是 Happy Path。</p></blockquote><p>起點是 Happy Path，過程則透過 UT 補強。對應到 金字塔，Happy Path 是 E2E 和 Integration Test。</p><p>註： <code>整合測試</code> 的概念請參閱 “<a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a>“ 的摘要</p><h2 id="測試金字塔是萬用的？"><a href="#測試金字塔是萬用的？" class="headerlink" title="測試金字塔是萬用的？"></a>測試金字塔是萬用的？</h2><p>其實實際的問題是這個：</p><blockquote><ul><li>這個金字塔式萬用的嗎？比例是這樣嗎？UT &gt; Integration &gt; E2E？？</li><li>每個 <code>產品</code> 都可以用這個概念套嗎？做 IoT、做電商、做 API Product 、做網通產品、基礎架構產品 需要的層次不一</li><li>產品在不同階段 (Prototype, Early Stage, 驗證階段, 成長期, 成熟階段) 需要的 <code>策略</code> 不一樣。</li></ul></blockquote><p>這是很弔詭的問題，這個問題大家要放在心裡，別掉進：<code>手上打著錘子，看到啥都是釘子</code> 的圈套。</p><!--## 搞定事情的條件：能力、意願、時間處理案例一、二、三的條件有三個：1. 能力:    * 能、不能    * 熟悉、不熟悉2. 意願    * 喜歡、不喜歡    * 想要、不想要3. 時間    * 有時間，才有 “左移” → “預防”    * 沒時間：壓力、加班、上靠北工程師發文 (有時間發廢文？壓力的程度：![](/images/SoftwareEngineering/HappyPath/comfortable-in-time.png)當時間充裕的時候：![](/images/SoftwareEngineering/HappyPath/incomfortable-in-time.png)當時間不足的時候：發現的難度、發現的時間--><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://rickhw.github.io/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></li><li><a href="https://rickhw.github.io/2018/03/18/SQA/Gossip-System-Testing/">系統測試的三兩事</a></li><li><a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li><a href="https://rickhw.github.io/2022/04/06/SoftwareEngineering/Artifact-Management-and-Version-Control/">Version Control 與 Artifact Management</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;測試金字塔&lt;/code&gt; 是很多書、很多演講都會提的概念，從上到下是 E2E、Integration、Unit Test，佔比也是這個次序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SQA/The_Test_Pyramid.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;很多大神、知名的軟體教練、傳教士、訪間的訓練機構也都一再強調 Unit Test (以下簡稱 UT) 的重要，經過幾年的宣導與討論，基本上，現在很多軟體工程師都自己會先做 Unit Test，或者在跑 Scrum 時都有出現 Task 內容是要做 Unit Test。對於整個軟體產業而言，是個很好的現象。&lt;/p&gt;
&lt;p&gt;這年代跑 Scrum 也越來越普遍，大家也有意識到一個 Scrum Team 就是在做一個產品，大概就像 &lt;code&gt;天龍特攻隊&lt;/code&gt; (A Team) 、或者是阿湯哥 &lt;code&gt;不可能任務&lt;/code&gt;、或者一個 &lt;code&gt;搖滾樂團&lt;/code&gt; ，都是 Team Work，理論上，要交付的是一個共同的價值。&lt;/p&gt;</summary>
    
    
    
    <category term="Software Engineering" scheme="https://rickhw.github.io/categories/Software-Engineering/"/>
    
    
    <category term="Unit Test" scheme="https://rickhw.github.io/tags/Unit-Test/"/>
    
    <category term="Artifact" scheme="https://rickhw.github.io/tags/Artifact/"/>
    
    <category term="Happy Paths" scheme="https://rickhw.github.io/tags/Happy-Paths/"/>
    
  </entry>
  
</feed>
