<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Complete Think</title>
  
  <subtitle>Thinking, Coding, and Learning.</subtitle>
  <link href="https://rickhw.github.io/atom.xml" rel="self"/>
  
  <link href="https://rickhw.github.io/"/>
  <updated>2022-12-19T13:01:22.448Z</updated>
  <id>https://rickhw.github.io/</id>
  
  <author>
    <name>Rick Hwang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置頂 - 全站索引</title>
    <link href="https://rickhw.github.io/2035/01/21/Index/"/>
    <id>https://rickhw.github.io/2035/01/21/Index/</id>
    <published>2035-01-21T02:30:00.000Z</published>
    <updated>2022-12-19T13:01:22.448Z</updated>
    
    <content type="html"><![CDATA[<p>這篇是整個 Blog 的全站索引，如果您是第一次來這裡，可以先看看這篇索引，大概知道 Blog 的全貌：</p><ul><li>[理念] <a href="/2017/11/26/Thinking-in-Essence/">思考本質、實踐、抽象、想像力、教育</a></li><li>[目錄] <a href="/2017/07/01/Index-Management/">經營管理</a>: 整理我的管理經驗談、管理哲學、經營、領導、用人之道、學習方法、專案管理</li><li>[目錄] <a href="/2017/07/01/Index-Software-Engineering-In-Practice/">軟體工程實踐</a>: 包含軟體架構、開發、測試、維運等 … 實踐的心得。</li><li>[目錄] <a href="/categories/Distributed-Systems">分散式系統</a>，包含分散式系統理論、Cloud Native - <a href="/tags/Kubernetes/">Kubernetes</a>、<a href="/2016/10/01/AWS-Study-Roadmap/">AWS</a>。</li><li>[參考] <a href="/2017/07/01/Reference/Books/">參考書</a>、<a href="/2017/07/01/Reference/Tech-Terms/">資訊技術與工程專有名詞</a>、<a href="/2017/07/01/Reference/SC-Terms/">計算機科學專有名詞</a>、<a href="/2017/07/01/Reference/Mgmt-Terms/">經營管理專有名詞</a></li><li>[關於] <a href="/2017/12/29/About/About-This-Blog/">這個部落格</a>、<a href="/2017/12/29/About/About-Author/">關於作者</a>、<a href="/2017/09/20/About/Learning-Approaches/">學習法則</a>、<a href="/2014/12/27/Management/%E7%B6%93%E7%87%9F%E4%B9%8B%E9%81%93/">經營之道</a>、<a href="/2017/12/02/About/Epiphany/">一些領悟</a>、<a href="/2014/10/26/Management/Classified-Philosophy/">分類哲學</a></li><li>[系列文] <a href="/tags/Bus-Memo/">公車隨筆</a>、<a href="/tags/Learning-Approaches/">寫作與閱讀系列文</a>、<a href="/tags/%E6%BA%9D%E9%80%9A/">溝通</a>、<a href="/tags/Meetings/">會議效率</a></li></ul><blockquote><p>不管是程式、文章、資料、還是房間，我都會定期重新整理 &#x2F; 重構，核心概念來自於 <a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></p></blockquote><span id="more"></span><hr><h2 id="站內熱門文章"><a href="#站內熱門文章" class="headerlink" title="站內熱門文章"></a>站內熱門文章</h2><p>依據 GA 最近三個月，前二十篇排名：更新 2022&#x2F;11&#x2F;13</p><ol><li>2022&#x2F;08&#x2F;13: <a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li>2016&#x2F;04&#x2F;07: <a href="/2016/04/07/AWS/Study-Notes-S3/">Study Notes - AWS S3</a></li><li>2022&#x2F;10&#x2F;07: <a href="/2022/10/07/About/As-Architect/">架構師的使命</a></li><li>2015&#x2F;08&#x2F;20: <a href="/2015/08/20/SQA/Three-Kinds-Of-QA/">三種 QA (Quality Assurance)</a></li><li>2018&#x2F;08&#x2F;03: <a href="/2018/08/03/DevOps/An-Introduction-to-SRE/">推薦：Site Reliability Engineering (SRE, 網站可靠性工程)</a></li><li>2019&#x2F;03&#x2F;17: <a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></li><li>2016&#x2F;08&#x2F;20: <a href="/2016/08/20/AWS/AWS-Certified-Developer/">AWS Certified Developer - Associate 準備心得</a></li><li>2019&#x2F;07&#x2F;09: <a href="/2019/07/09/Management/Layoff-Fired-Resiging/">管理必經之路：資遣、解僱、辭呈</a></li><li>2017&#x2F;03&#x2F;18: <a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li>2017&#x2F;09&#x2F;20: <a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li>2018&#x2F;10&#x2F;07: <a href="/2018/10/07/Management/Hiring-Step5-Offer/">人力招募 - 五、最後確認：報到時程</a></li><li>2015&#x2F;10&#x2F;11: <a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li>2018&#x2F;03&#x2F;18: <a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></li><li>2019&#x2F;08&#x2F;14: <a href="/2019/08/14/About/About-Certificate/">證照有無用論？</a></li><li>2021&#x2F;08&#x2F;20: <a href="/2021/08/20/ComputerScience/HTTPS-TLS/">簡介 HTTPS &#x2F; TLS 安全通訊協議</a></li><li>2018&#x2F;06&#x2F;14: <a href="/2018/06/14/DevOps/Recap-What-is-Ops/">再談啥是維運？</a></li><li>2018&#x2F;10&#x2F;08: <a href="/2018/10/08/DevOps/Chaos-Engineering/">混沌工程 (Chaos Engineering)</a></li><li>2015&#x2F;01&#x2F;06: <a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">協同合作系統建制與導入 - 以 Redmine 為例</a></li><li>2022&#x2F;09&#x2F;25: <a href="/2022/09/25/SQA/QA4QA-Provisioning-is-Difficult/">蓋環境很難？是這樣的嗎？QA 需要自己蓋環境？</a></li><li>2018&#x2F;03&#x2F;20: <a href="/2018/03/20/DevOps/First-Step-To-CICD/">導入 CI&#x2F;CD 的第一步</a></li></ol><h2 id="站內最多讚的文章"><a href="#站內最多讚的文章" class="headerlink" title="站內最多讚的文章"></a>站內最多讚的文章</h2><ul><li>950+<ol><li>2017&#x2F;09&#x2F;20: <a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li></ol></li><li>650+<ol><li>2019-12-28: <a href="/2019/12/28/Management/Awareness-and-Deep-Thinking/">如何意識到問題的存在</a></li><li>2019-06-05: <a href="/2019/06/05/DevOps/Github-Incident-Analysis/">GitHub Post-Incident Analysis</a></li></ol></li><li>550+<ol><li>2019-03-30: <a href="/2019/03/30/Management/How-do-Manager-Keep-Learning/">管理者如何持續學習技術？</a></li></ol></li><li>500+<ul><li>2018-04-01: <a href="/2018/04/01/DevOps/How-To-Make-CICD-Quality/">怎樣的 CI&#x2F;CD 才夠 Quality?</a></li></ul></li><li>450+<ol><li>2018-08-03: <a href="/2018/08/03/DevOps/An-Introduction-to-SRE/">推薦：Site Reliability Engineering (SRE, 網站可靠性工程)</a></li></ol></li><li>400+<ol><li>2019-05-17: <a href="/2019/05/17/About/DDS-zh_TW/">分散式系統設計 - 正體中文版翻譯記事</a></li><li>2019-04-05: <a href="/2019/04/05/About/Working-Backwards/">一個人的 Working Backwards</a></li><li>2015-08-20: <a href="/2015/08/20/SQA/Three-Kinds-Of-QA/">三種 QA (Quality Assurance)</a></li></ol></li><li>350+<ol><li>2022-08-13: <a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li>2019-01-20: <a href="/2019/01/20/About/Reading/">閱讀能力的重要性</a></li></ol></li><li>300+<ol><li>2018-07-08: <a href="/2018/07/08/DevOps/Artifacts-Management/">Artifacts Management</a></li><li>2018-10-07: <a href="/2018/10/07/Management/Hiring-Step5-Offer/">人力招募 - 五、最後確認：報到時程</a></li><li>2018-07-08: <a href="/2018/07/08/DevOps/Artifacts-Management/">Artifacts Management</a></li><li>2018-03-29: <a href="/2018/03/29/About/2018-Serverless-All-Star/">演講：Serverless All-Star - Ops as Code using Serverless</a></li></ol></li><li>250+<ol><li>2020&#x2F;08&#x2F;01: <a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li>2019-10-30: <a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></li><li>2019-09-20: <a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？（壓測）</a></li><li>2019&#x2F;07&#x2F;09: <a href="/2019/07/09/Management/Layoff-Fired-Resiging/">管理必經之路：資遣、解僱、辭呈</a></li><li>2019-04-04: <a href="/2019/04/04/DevOps/Four-Pillars-of-Software-Delivery/">軟體交付的四大支柱 (Four Pillars of Software Delivery)</a></li><li>2019-02-27: <a href="/2019/02/27/ComputerScience/IO-Models/">Study Notes - I&#x2F;O Models</a></li><li>2018-12-16: <a href="/2018/12/16/DevOps/Hire-a-Release-Engineer/">需要專職的 Release Engineer？</a></li><li>2018-09-22: <a href="/2018/09/22/Management/Hiring-Step3-Interview-Values-Attitude/">人力招募 - 三、深度對話：價值觀</a></li><li>2017-09-14: <a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li>2016&#x2F;04&#x2F;07: <a href="/2016/04/07/AWS/Study-Notes-S3/">Study Notes - AWS S3</a></li></ol></li><li>200+<ol><li>2020-03-24: <a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li><li>2019-03-17: <a href="/2019/03/17/Management/Perspective-in-XYZT/">看見怎樣的全貌 - 軟體開發的三體問題</a></li><li>2019-03-28: <a href="/2019/03/28/DevOps/DevOpsTaiwan-Meetup-Beginning-in-Artifacts-Management/">聊聊軟體交付的濫觴 談產出物管理 (Artifacts Management)</a></li><li>2018-11-14: <a href="/2018/11/14/DevOps/Review-Continuous-Delivery-v2.0/">心得：持續交付 2.0</a></li><li>2018-09-12: <a href="/2018/09/12/DevOps/DevOpsDaysTaipei2018-Emergency-And-Incident-Management/">演講：從緊急事件 談 SRE 應變能力的培養</a></li><li>2018-03-18: <a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題 (How to Report Problems Effectively)</a></li><li>2017-11-12: <a href="/2017/11/12/DevOps/Gossip-Automation/">自動化帶來的問題</a></li></ol></li><li>150+<ol><li>2020-05-09: <a href="/2020/05/09/Management/Problems-in-Documentation/">寫文件常見的問題</a></li><li>2019-10-04: <a href="/2019/10/04/DevOps/How-to-Figure-out-the-RootCause-for-an-AbnormalSystem-In-ZeroTime/">系統發生異常時，第一時間如何快速止血？</a></li><li>2019-09-13: <a href="/2019/09/13/DevOps/Scrum-for-SRE-Team/">Infra 團隊適合 Scrum？</a></li><li>2019&#x2F;03&#x2F;17: <a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></li><li>2018-08-30: <a href="/2018/08/30/Management/Hiring-Step1-Find-the-Candidates/">人力招募 - 一、萬事起頭難：面試名單從哪來？</a></li><li>2017-12-03: <a href="/2017/12/03/SQA/Regression-Test-Is-Tough/">從 iOS 無限黑屏事件，談軟體測試階段 - 回歸測試 Regression Test</a></li><li>2017-03-18: <a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li>2015-10-11: <a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li></ol></li><li>100+<ol><li>2022-05-10: <a href="/2022/05/10/About/2022-SREConf2022/">SRE Conference 2022</a></li><li>2020-10-18: <a href="/2020/10/18/DevOps/Deploy-on-Friday-or-Not/">星期五要不要部署？</a></li><li>2019-04-02: <a href="/2019/04/02/Management/Overall/">將與才之『縱觀全局』</a></li><li>2019-01-21: <a href="/2019/01/21/Management/KM-and-Issue-Tracking/">Issue Tracking 在企業裡的價值 - KM</a></li><li>2018-12-15: <a href="/2018/12/15/DevOps/TheProblem-In-DevOps-8-Cycle/">DevOps 8 字環的誤區：左環問題</a></li><li>2018-09-27: <a href="/2018/09/27/Management/Hiring-Step4-Salary/">人力招募 - 四、客觀談論：薪資</a></li><li>2018-08-20: <a href="/2018/08/20/Management/Overview-Hiring/">聊聊人力招募</a></li></ol></li></ul><!--1. 2016/04/22: [AWS Certified Solutions Architect - Associate 準備心得](/2016/04/22/AWS/AWS-Certified-Solutions-Architect_Associate/)1. 2017/09/14: [Software Development Lifecycle](/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/)1. 2015/01/06: [協同合作系統建制與導入 - 以 Redmine 為例](/2015/01/06/Management/協同合作系統建制與導入-以-Redmine-為例/)1. 2017/11/12: [自動化帶來的問題](/2017/11/12/DevOps/Gossip-Automation/)1. 2018/01/24: [Overview API Gateway](/2018/01/24/DistributedSystems/Overview-API-Gateway/)1. 2018/08/03: [推薦：Site Reliability Engineering (SRE, 網站可靠性工程)](/2018/08/03/DevOps/An-Introduction-to-SRE/)1. 2016/08/17: [Study Notes - DynamoDB 學習筆記](/2016/08/17/AWS/Study-Notes-DynamoDB/)1. 2018/04/01: [怎樣的 CI/CD 才夠 Quality?](/2018/04/01/DevOps/How-To-Make-CICD-Quality/)1. 2018/03/29: [Serverless All-Star - Ops as Code using Serverless](/2018/03/29/About/2018-Serverless-All-Star/)1. 2018/03/20: [導入 CI/CD 的第一步](/2018/03/20/DevOps/First-Step-To-CICD/)1. 2017/12/22: [What is Monitoring?](/2017/12/22/DevOps/What-is-Monitoring/)1. 2017/12/03: [從 iOS 無限黑屏事件，談軟體測試階段 - 回歸測試 Regression Test](/2017/12/03/SQA/Regression-Test-Is-Tough/)1. 2017/09/20: [學習法則](/2017/09/20/About/Learning-Approaches/)1. 2017/03/18: [淺談軟體測試的階段與策略](/2017/03/18/SQA/Stages-In-Software-Testing/)1. 2016/07/29: [AWS Certified SysOps Administrator - Associate 準備心得](/2016/07/29/AWS/AWS-Certified-SysOps-Administrator/)1. 2015/10/11: [Software QA 的職能條件](/2015/10/11/SQA/How-To-Be-An-SQA/)1. 2015/08/20: [三種 QA](/2015/08/20/SQA/Three-Kinds-Of-QA/)1. 2014/05/09: [軟體自動化測試常見的問題](/2014/05/09/SQA/Problems_In-Software-Autotest/)-->]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇是整個 Blog 的全站索引，如果您是第一次來這裡，可以先看看這篇索引，大概知道 Blog 的全貌：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[理念] &lt;a href=&quot;/2017/11/26/Thinking-in-Essence/&quot;&gt;思考本質、實踐、抽象、想像力、教育&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/2017/07/01/Index-Management/&quot;&gt;經營管理&lt;/a&gt;: 整理我的管理經驗談、管理哲學、經營、領導、用人之道、學習方法、專案管理&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/2017/07/01/Index-Software-Engineering-In-Practice/&quot;&gt;軟體工程實踐&lt;/a&gt;: 包含軟體架構、開發、測試、維運等 … 實踐的心得。&lt;/li&gt;
&lt;li&gt;[目錄] &lt;a href=&quot;/categories/Distributed-Systems&quot;&gt;分散式系統&lt;/a&gt;，包含分散式系統理論、Cloud Native - &lt;a href=&quot;/tags/Kubernetes/&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a href=&quot;/2016/10/01/AWS-Study-Roadmap/&quot;&gt;AWS&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;[參考] &lt;a href=&quot;/2017/07/01/Reference/Books/&quot;&gt;參考書&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/Tech-Terms/&quot;&gt;資訊技術與工程專有名詞&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/SC-Terms/&quot;&gt;計算機科學專有名詞&lt;/a&gt;、&lt;a href=&quot;/2017/07/01/Reference/Mgmt-Terms/&quot;&gt;經營管理專有名詞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[關於] &lt;a href=&quot;/2017/12/29/About/About-This-Blog/&quot;&gt;這個部落格&lt;/a&gt;、&lt;a href=&quot;/2017/12/29/About/About-Author/&quot;&gt;關於作者&lt;/a&gt;、&lt;a href=&quot;/2017/09/20/About/Learning-Approaches/&quot;&gt;學習法則&lt;/a&gt;、&lt;a href=&quot;/2014/12/27/Management/%E7%B6%93%E7%87%9F%E4%B9%8B%E9%81%93/&quot;&gt;經營之道&lt;/a&gt;、&lt;a href=&quot;/2017/12/02/About/Epiphany/&quot;&gt;一些領悟&lt;/a&gt;、&lt;a href=&quot;/2014/10/26/Management/Classified-Philosophy/&quot;&gt;分類哲學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[系列文] &lt;a href=&quot;/tags/Bus-Memo/&quot;&gt;公車隨筆&lt;/a&gt;、&lt;a href=&quot;/tags/Learning-Approaches/&quot;&gt;寫作與閱讀系列文&lt;/a&gt;、&lt;a href=&quot;/tags/%E6%BA%9D%E9%80%9A/&quot;&gt;溝通&lt;/a&gt;、&lt;a href=&quot;/tags/Meetings/&quot;&gt;會議效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不管是程式、文章、資料、還是房間，我都會定期重新整理 &amp;#x2F; 重構，核心概念來自於 &lt;a href=&quot;/2014/10/26/Management/Classified-Philosophy/&quot;&gt;分類的哲學&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>和艦長一起 30 天玩轉 GitLab【第二版】- 推薦序完整版</title>
    <link href="https://rickhw.github.io/2022/11/19/About/Gitlab-Recommand/"/>
    <id>https://rickhw.github.io/2022/11/19/About/Gitlab-Recommand/</id>
    <published>2022-11-19T13:42:30.000Z</published>
    <updated>2022-12-19T13:34:17.977Z</updated>
    
    <content type="html"><![CDATA[<p>只要是軟體開發，不管 Web Services、還是 Mobile 或 Desktop Application，都會需要建置 (Build) 與交付 (Delivery) 兩個核心過程。Web Services 的交付稱為部署 (Deployment)，應用程式稱為發佈 (Publish)。而這些過程，也伴隨著一些衍生的任務 (Task)，組成一連串的行為，隨著時間的推進，架構的改變，這些任務的組合，往往是工程師們的夢靨的開始。</p><span id="more"></span><h2 id="走過的路"><a href="#走過的路" class="headerlink" title="走過的路"></a>走過的路</h2><p>在 git 還沒開始流行之前，我早期在 IBM 工作時使用的 <a href="https://en.wikipedia.org/wiki/IBM_Configuration_Management_Version_Control_(CMVC)">CMVC</a> 這套 IBM 自行開發的整合性 SCM <sup>註</sup>，它整合了 Issue Tracking System (ITS)、Build Procedure、Unit Test、Integration Test、Source Control 等 … 完美整合，分支策略以 Trunk Based 為主，每個 Commit 都一定根據 Issue Number。通常 Commit 一定要基於 Feature Ticket 或者 Defect &#x2F; Bug Number。</p><blockquote><p>註： SCM: Source Code Mangement, 早期稱 VSC, Version Control System</p></blockquote><p>除了 CMVC，後來常用的 SCM 則是 CVS、SVN、Perforce (p4)，但這些 SCM 如果要處理開發流程，以 SVN 來說，是透過 pre-commit 以及 post-commit hook 去管理。透過這些機制，配合像是 Redmine 這種 ITS 就可以做到 commit 語意化，以達到流程管理的目的。</p><p>以下是我在新創事業的工作經歷時，當時配合 <a href="/2016/09/17/Redmine/Integrate-GIT-in-Redmine/">Redmine 設計的 commit 規則</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ref <span class="comment">#1235 part 1 for this functional set.</span></span><br><span class="line">fix <span class="comment">#9527 This is a defect fix, the root cause is invalid assignment.</span></span><br><span class="line"><span class="keyword">done</span> <span class="comment">#6741 complete functional implementation.</span></span><br><span class="line">build <span class="comment">#9420 trigger build</span></span><br></pre></td></tr></table></figure><p>每次 commit 都必須符合這樣的規則：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">command</span>] [issue-number] [comments]</span><br></pre></td></tr></table></figure><p>透過這樣的機制，自己做出完整的 CI &#x2F; CD 流程。</p><h2 id="必要的機制"><a href="#必要的機制" class="headerlink" title="必要的機制"></a>必要的機制</h2><p>CI &#x2F; CD 加上 Pipeline 最核心的有三件事情： <strong>Build</strong> 、 <strong>Delivery</strong> 、以及把這兩件事連接起來的 <strong>Pipeline (Workflow)</strong> 。衍伸的任務，其他 CI 還有的像是串接 Unit Test、Integration Test、Code Scan、Code Review，CD 則有環境建置 (Provisioning)、配置管理、部署策略 (發布策略) … 等，是讓整件事情更完善的下一步。</p><p>除了上述任務，另外影響整個 Pipeline 的則是分支策略這種流程 (Workflow) 帶來的複雜度，不管是 Git Flow、GitHub Flow、還是 Trunk Based，都會讓團隊有更一致的開發流程體驗，當然隨之而來的就是 Pipeline 的複雜度，進而衍伸的架構議題。</p><p>從技術本質來看，要滿足上述任務需要包含這些條件： <strong>(1) 任務 (Task)</strong> 、 <strong>(2) 流程控制 (Flow Control)</strong> 、與 <strong>(3) 事件驅動 (Event Driven)</strong> 。任務指的是像 Build、Deploy、Unit Test、Code Scan … 這些事情，這些事情通常是透過 Script、寫程式、第三方工具串接做整合；流程控制則是把 Task 接起來的控制，包含先後次序，甚至是條件控制；事件驅動則是怎樣發動一個流程或者任務，透過人為觸發 (Approve &#x2F; Bug Report)、還是 commit 觸發、還是 tag &#x2F; branch 觸發、還是 Slack 觸發 … 等。</p><p>當系統架構變大、變複雜，為了加速 Pipeline 執行的效率，通常會考慮增加運算資源，隨之而來的是第四個條件：<strong>分散式運算 (Distributed Computing)</strong> ，但也因此會帶來 <strong>分散式架構</strong> 議題 <sup><a href="/2019/05/21/AWS/Study-Notes-Step-Functions/">1</a>, <a href="https://github.com/rickhw/thinking-in-code/tree/master/task-placement-controller">2</a></sup>。</p><p>撇除工具提供的功能，寫一個好的 Task、做好基本的 Flow Control，需要基本軟體工程能力，還有寫程式的紀律。如果純手工，沒有工具支援，要做好這兩件事情還可以，這也是普遍人在談的自動化程式範圍。但如果要做到事件驅動、分散式運算的需求，那麼就不是普通工程師能做好的了。而 Gitlab 本身的架構透過分散式運行機制：Gitlab Runner 與 Tag，完美的解決這個問題。</p><h2 id="推薦"><a href="#推薦" class="headerlink" title="推薦"></a>推薦</h2><p><img src="/images/About/GitLab-2022/gitlab-2022.jpg"></p><p>一本書如果要說那些最重要的，我會用上述的觀點來作為衡量指標，觀念要正確，實踐方法與思路要清晰、可用、有效率。這本 Gitlab 實戰，作者除了把 GitLab 整體概念有完整的介紹，CI &#x2F; CD &#x2F; Pipeline 該怎麼設計與實踐，有著更實務的介紹，特別在第五章，把我心裡的想法，變成如何透過 Gitlab 實踐出來。</p><p>Pipeline 的複雜度是跟著架構，通常系統架構越複雜、依賴性越多，整個 Pipeline 就會越長且複雜。這時候問題通常不是工具的問題，而是結構問題，計算機科學處理複雜度最常用的方法： <strong>分而治之 (Divide and Conquer)</strong></p><p>例如有五個系統要部署，彼此有先後依賴關係，Pipeline 的長度有數十個 Stages，這時候可以利用 GitLab Pipeline 提供的變數 (Variables)、流程控制 (Workflow)、樣板 (Templates) 等類似於 DSL (Domain-Specific Language) 的功能，搭配分而治之的概念，降低複雜度、提高 Pipeline 重用性，在軟體工程裡就是重構 (Refactoring)。這些在書本都有詳細說明概念與應用。</p><p>如果再加上 Cloud Native 的流行，從傳統的地端機房，變成各種雲提供者 (AWS、GCP、Azure)，乃至於 Kubernates (K8s)，這麼複雜的條件，如何搭配 GitLab 的 Auto DevOps，也是本書會給予讀者方向與概念的。這麼複雜的條件，其實核心概念依舊脫離不了前面提到的本質： <strong>任務、流程控制、事件驅動、以及分散式運算</strong> ，也就是各種雲或者 K8s。</p><p>如果你有個朋友，他是初出茅廬的工程師，如果你想毀了他，那就叫他去寫自動化吧；但是如果你又想讓他覺得，你是世界上對他最好的人，那麼就介紹他 Gitlab 吧！同樣的條件之下，如果他是你的好朋友，為了拯救他於水深火熱，沒日沒夜的加班，那還是介紹他 Gitlab 吧！他上車了，但卻沒有人教他怎麼讓順利做好 Pipeline，那就介紹他這本書，讓艦長帶他一步一步走向更好生活的路上！</p><blockquote><p>技術部落格《<a href="https://rickhw.github.io/">Complete Think</a>》 作者 <a href="/2017/12/29/About/About-Author/">Rick Hwang</a>, 2022&#x2F;10 台北</p></blockquote><p> ☛ 天瓏書局：<a href="https://www.tenlong.com.tw/products/9786263332966?list_name=i-r-zh_tw">和艦長一起 30 天玩轉 GitLab【第二版】（iT邦幫忙鐵人賽系列書）</a></p><h2 id="上市後"><a href="#上市後" class="headerlink" title="上市後"></a>上市後</h2><blockquote><p>updated 2022&#x2F;12&#x2F;16</p></blockquote><p>感謝艦長贈書留念～</p><p><img src="/images/About/GitLab-2022/Chen-Wei2.jpg"><br><img src="/images/About/GitLab-2022/Chen-Wei1.jpg"><br><img src="/images/About/GitLab-2022/Chen-Wei3.jpg"><br><img src="/images/About/GitLab-2022/Chen-Wei4.jpg"></p><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ol><li><a href="/2019/04/04/DevOps/Four-Pillars-of-Software-Delivery/">軟體交付的四大支柱 (Four Pillars of Software Delivery)</a></li><li><a href="/2018/12/16/DevOps/Hire-a-Release-Engineer/">需要專職的 Release Engineer？</a></li><li><a href="/2018/04/01/DevOps/How-To-Make-CICD-Quality/">怎樣的 CI&#x2F;CD 才夠 Quality?</a></li><li><a href="/2019/03/28/DevOps/DevOpsTaiwan-Meetup-Beginning-in-Artifacts-Management/">聊聊軟體交付的濫觴 談產出物管理</a></li><li><a href="/2019/05/21/AWS/Study-Notes-Step-Functions/">Study Notes - Step Functions</a></li><li><a href="/2016/09/17/Redmine/Integrate-GIT-in-Redmine/">系統整合：Integrate GIT in Redmine</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;只要是軟體開發，不管 Web Services、還是 Mobile 或 Desktop Application，都會需要建置 (Build) 與交付 (Delivery) 兩個核心過程。Web Services 的交付稱為部署 (Deployment)，應用程式稱為發佈 (Publish)。而這些過程，也伴隨著一些衍生的任務 (Task)，組成一連串的行為，隨著時間的推進，架構的改變，這些任務的組合，往往是工程師們的夢靨的開始。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Gitlab" scheme="https://rickhw.github.io/tags/Gitlab/"/>
    
    <category term="Continuous Delivery" scheme="https://rickhw.github.io/tags/Continuous-Delivery/"/>
    
    <category term="Continuous Integration" scheme="https://rickhw.github.io/tags/Continuous-Integration/"/>
    
  </entry>
  
  <entry>
    <title>Problem Behind Question</title>
    <link href="https://rickhw.github.io/2022/10/15/Management/Problem-Behind-Question/"/>
    <id>https://rickhw.github.io/2022/10/15/Management/Problem-Behind-Question/</id>
    <published>2022-10-15T10:21:00.000Z</published>
    <updated>2022-12-19T11:47:28.865Z</updated>
    
    <content type="html"><![CDATA[<p>工作上經常問題還沒被看清楚，只求快，要有成果，往往都只是做表面工作。</p><p>這篇整理自 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02kCCdZu2ztmzmYRA8i44qDVA1JYVPfgcn3BaEukmgBerJdRrL3ebojGnJTk2oaDkml">2022&#x2F;09&#x2F;08</a>、<a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0fSDnHyqy4oCN1e1dT6uHR72dGXY4wfHgqcQEimpvJRLGAdDAioDzjsnRznqWuMrMl">2022&#x2F;07&#x2F;22</a> 我自己的思考的筆記，延伸 <code>QBQ (問題背後的問題)</code> 以及 <a href="/2019/12/28/Management/Awareness-and-Deep-Thinking/">如何意識到問題的存在</a>，我自己深度體悟與昇華後的心得。</p><span id="more"></span><h2 id="表象、議題、問題"><a href="#表象、議題、問題" class="headerlink" title="表象、議題、問題"></a>表象、議題、問題</h2><p>普遍的 <code>表象</code> 都只是些 <code>現象</code>，還在 <code>議題 (Issue)</code> 階段，真正的 <code>問題 (Problem)</code> 還沒顯現。</p><p>需透過眾人的 <code>提問 (Question)</code>，經過 <code>思 (Thinking)</code>、<code>辨 (Discussion)</code>、<code>分析 (Analyze)</code>、<code>總結 (Conclusion)</code>，然後真正問題背後的問題：</p><blockquote><p>Problem Behind Question (PBQ)</p></blockquote><p>真正核心問題才會出現，接下來的行動才有機會是提出 <code>解決方案 (Solution)</code>、討論各個 <code>執行計畫 (Plan)</code> 的優缺、進行 <code>執行策略 (Strategy)</code> 謀劃，<code>問題 (Problems)</code> 才能真正的 <code>被解決 (Resolved)</code>。</p><h2 id="定義用詞"><a href="#定義用詞" class="headerlink" title="定義用詞"></a>定義用詞</h2><p>定義前面提到幾個用詞：</p><ul><li><code>Issue</code>: 翻譯成 <code>議題</code>，抽象名詞，泛指事件的統稱，包含已確立的、尚未釐清的、混沌不明的 …<ul><li>這個詞源源自於 Redmine，任何需要被處理的事情都抽象成 Issue。更多參閱 <a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">協同合作系統建制與導入 - 以 Redmine 為例</a></li></ul></li><li><code>Question</code>: 這裡我翻譯成 <code>提問</code>，而不是問題，指的是針對事件的現象進行提問，大部分背後動機都是收集事件的資訊、上下文 (Context)</li><li><code>Context</code>: 背景資訊、上下文、前後文。提問過程，蒐集到的資訊，例如人事時地物等，以及因果關係。</li><li><code>Problem</code>: 問題，已經確立根本的因素，包含實際影響 (Impact)、關鍵觸發者 (Event Source)、範圍 (Scope)，有具體的 <code>問題根源 (Root Cause)</code></li><li><code>Solution</code>: 解決方案，針對問題 (Problem) 的因素而設計的處理方法。留意，是針對性地。</li><li><code>Resolved</code>: 已經解決，是個狀態。透過 Solution，把問題根源排除。</li><li><code>Strategy</code>: 執行策略，當問題被定義好了，通常不會只有一個 Solution，而是會有多個，然後衍生出各個執行計畫，這時候可以比較 Plan A &#x2F; B &#x2F; C 的優缺點 (Pros &#x2F; Cons)，然後往下執行才有策略可言。</li></ul><hr><h2 id="Problem-Behind-Question"><a href="#Problem-Behind-Question" class="headerlink" title="Problem Behind Question"></a>Problem Behind Question</h2><p>改一下很常用的</p><blockquote><p>QBQ: Question Behind Question</p></blockquote><p><a href="https://www.books.com.tw/products/0010245329">問題背後的問題</a>，這是本很有名的書。</p><p>我把這段話改成這樣：</p><blockquote><p>Problem Behind Question, PBQ</p></blockquote><p>可以翻譯成：<code>提問背後的問題</code></p><p>我想要強調的重點是：</p><blockquote><p>在還沒把 <code>議題 (Issue)</code> 的 <code>背景資訊 (Context)</code> 搞清楚之前，<code>問題 (Problem)</code> 是無法定義。</p></blockquote><p>我常常看到這樣的狀況：</p><p>在一些關鍵的問題，像是系統架構、商業決策，很常看到還沒確認問題，就開始急著討論解決方案、什麼時間完成，往往核心問題、核心需求都還沒搞清楚。所以最後解決的往往不是根本因素 (Root Cause)。</p><p>大部分 議題 (Issue) 剛開始看的現象，在背景資料 Ccontext) 不足的情況、情報不足，都還不足以確認、或者定義問題 (Problem)，貿然出手處理，如果經驗又不足，往往處理的，只是表面的東西。</p><blockquote><p>註：<code>緊急事件</code> 的止血行為不在此範圍。</p></blockquote><p>解決方案 (Solution) 處理的是 Problem 的根本因素 (Root Cause)，而提問 (Question) 是探索 Problem 的 Context，搜集情報的過程、疏理 Context、進而找到 Root Cause，然後才定義問題。</p><p>越是關鍵的問題，越是要嚴正以待，提問是很關鍵的一關。</p><h2 id="開會是在浪費時間？"><a href="#開會是在浪費時間？" class="headerlink" title="開會是在浪費時間？"></a>開會是在浪費時間？</h2><p>其實很常聽到同事說，開會是在浪費時間，因為沒有像寫程式一樣有具體產出。</p><p>開會的重點在於，問題 (Question) 提出來，經過思辨、搜集各種角度的想法、最後需要一個人 (最好是 PO)，去整理這些討論與問題，然後分析、總結脈絡，最後做策略性選擇。</p><p>通常問題就在於，沒有針對狀況提問，問題本身沒有經過精煉或者討論。</p><p>最慘的是，時間花了，卻沒有去 <code>整理</code>、<code>分析</code>、<code>總結</code>，所以開會當然會變浪費時間。</p><p>知道問題點在哪，就針對問題用技術能力去改善，而且是一針見血的執行，這樣的開會自然就會有意義，而且是非常有意義。</p><blockquote><p>開會的方法請參閱：<a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></p></blockquote><h2 id="未完-…"><a href="#未完-…" class="headerlink" title="未完 …"></a>未完 …</h2><p>我先整理這段核心想法，延伸 <code>QBQ (問題背後的問題)</code> 以及 <a href="/2019/12/28/Management/Awareness-and-Deep-Thinking/">如何意識到問題的存在</a>，未來再整理完整版。</p><h2 id="相關的書"><a href="#相關的書" class="headerlink" title="相關的書"></a>相關的書</h2><ul><li><a href="https://www.books.com.tw/products/0010245329">問題背後的問題</a></li><li><a href="https://www.books.com.tw/products/0010478689">你會問問題嗎：問對問題是成功領導的第一步</a></li></ul><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></li><li><a href="/2019/12/28/Management/Awareness-and-Deep-Thinking/">如何意識到問題的存在</a></li><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">協同合作系統建制與導入 - 以 Redmine 為例</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作上經常問題還沒被看清楚，只求快，要有成果，往往都只是做表面工作。&lt;/p&gt;
&lt;p&gt;這篇整理自 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02kCCdZu2ztmzmYRA8i44qDVA1JYVPfgcn3BaEukmgBerJdRrL3ebojGnJTk2oaDkml&quot;&gt;2022&amp;#x2F;09&amp;#x2F;08&lt;/a&gt;、&lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0fSDnHyqy4oCN1e1dT6uHR72dGXY4wfHgqcQEimpvJRLGAdDAioDzjsnRznqWuMrMl&quot;&gt;2022&amp;#x2F;07&amp;#x2F;22&lt;/a&gt; 我自己的思考的筆記，延伸 &lt;code&gt;QBQ (問題背後的問題)&lt;/code&gt; 以及 &lt;a href=&quot;/2019/12/28/Management/Awareness-and-Deep-Thinking/&quot;&gt;如何意識到問題的存在&lt;/a&gt;，我自己深度體悟與昇華後的心得。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Design" scheme="https://rickhw.github.io/tags/Design/"/>
    
    <category term="QBQ" scheme="https://rickhw.github.io/tags/QBQ/"/>
    
    <category term="PBQ" scheme="https://rickhw.github.io/tags/PBQ/"/>
    
    <category term="Thinking" scheme="https://rickhw.github.io/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>架構師的使命</title>
    <link href="https://rickhw.github.io/2022/10/07/About/As-Architect/"/>
    <id>https://rickhw.github.io/2022/10/07/About/As-Architect/</id>
    <published>2022-10-07T04:39:00.000Z</published>
    <updated>2022-12-19T11:47:28.851Z</updated>
    
    <content type="html"><![CDATA[<p>架構師的工作到底是做啥？用一張十年前 (2012) 我自己在 <a href="https://www.plurk.com/p/hp91r2">Plurk</a> 寫下的定義，然後再真實經歷之後，重新回顧這段話。</p><p><img src="/images/About/201211_as-Architect.jpg"><br><a href="https://www.plurk.com/p/hp91r2">Plurk Permalink</a></p><p>這篇是我在粉專寫下的 <a href="https://www.facebook.com/completethink/posts/pfbid02kxY7WJLh6aWnpVNuSeK8z6WQm26kEVqPuzrcYKVyEjAFhPjwzF6pau1Y2uyKPx9rl">隨筆文</a>，放在 blog 做個紀錄。</p><span id="more"></span><hr><h2 id="定義"><a href="#定義" class="headerlink" title="定義"></a>定義</h2><p>截圖是我 2012 年在 <code>噗浪</code> (Plurk, 還有人在用？) 上自己對於 <code>架構師</code> 寫下的定義:</p><blockquote><p>讓所有團隊的 <code>關係人</code>，對於 <code>產品</code> 有 <code>一致性</code> 的 <code>整體觀</code></p></blockquote><p>我的部落格文章裡，有很高的比例都在整理溝通表達的想法，像是：</p><ul><li><a href="https://rickhw.github.io/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li><li><a href="https://rickhw.github.io/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="https://rickhw.github.io/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/">開會原則</a> 及 系列文</li><li><a href="https://rickhw.github.io/2021/12/19/Management/Protocol-to-Communication/">團隊溝通的通訊協議</a></li></ul><p>除了這些軟性的，在 “<a href="https://rickhw.github.io/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">一致性問題與共識演算法</a>“ 這篇整理，把 <code>一致性問題</code>、<code>共識演算法</code> 兩個 分散式系統的核心議題，直接用到組織溝通。計算機科學裡的 <code>通訊協議</code> 概念，應用在人與人溝通。</p><h2 id="使命"><a href="#使命" class="headerlink" title="使命"></a>使命</h2><p>最近跟朋友聊到架構師工作內容是做啥？研究最新的最炫砲的技術？還是去扛別人留下來的坑、把坑變黃金？研究下一代的技術？ …. 聽起來好像是，也好像都不是。</p><p>最近剛好有機會，有在學學生來公司參訪，我負責介紹架構師在做啥，準備的時候我直覺的就用了十年前的這段話當開場，定義了架構師的使命。</p><p>這句話其實換成其他角色，也可以？其實不然，換成總監、經理層級，絕對不行；VP 以上層級，也不對，大部分的 VP、總監、經裡 還是 Functional Base 的角色，也就是具備本位主義。所以只有架構師、產品長、PO，或者 C-Level 這種全局觀的角色，才是做這種工作。</p><p>普遍人對於架構師還是以技術角度出發，例如就是在導 MicroServices、DDD、Clean Code &#x2F; Architect、搞 K8s、弄 Cloud、弄 vSphere、Service Mesh、資訊安全 … 我也的確在當場回答了一些概念，我的 Blog 也有一半以上都在寫技術類的東西。</p><h2 id="武、俠與俠之大者"><a href="#武、俠與俠之大者" class="headerlink" title="武、俠與俠之大者"></a>武、俠與俠之大者</h2><p>我很喜歡讀金庸武俠，其中最喜歡討論的就是 <code>武俠</code>，喜歡郭靖的 <code>俠之大者，為國為民</code>。江湖上喜歡討論誰武功高、誰的武功有多厲害、喜歡討論之最、最高、爭奪武功秘笈 ….. (這年代的武功秘笈都在 ACM 論文 …. 只要有心，人人都可以練成葵花寶典、超級賽雅人)。</p><p>而我個人，更多喜歡討論的是俠者為何？直接引用金庸自己在小說序中提到的概念：</p><blockquote><p>『武功』只是用來解決問題的手段，特別是在過去朝代律法規範不健全之下，人們只能用『武功』來取得正義，或者利益。『武俠』小說要討論的核心，應該是人跟人之間的俠與義，更近一步的是人性。只是在說故事的時候，需要透過武功來陳述過程衝突，解決的手段，甚至誇大武功的力量（所以乾坤大挪移、降龍十八掌），藉此吸引讀者目光。</p></blockquote><p>同樣的概念，也可以套用在科幻小說上。藉由幻想的科學 (科幻)，探討『哲學』議題，包含生命、烏托邦 … 等。</p><p>回到架構師的職責，架構師要凝聚的是 <code>關係人 (Stakeholder)</code> 的 <code>共識 (Consensus)</code> ，讓團隊對於展品有整體 <code>一致性 (Consistency)</code> 的 <code>整體觀</code>。</p><blockquote><p>Consensus vs Consistency 的差異，參閱 “<a href="https://rickhw.github.io/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">一致性問題與共識演算法</a>“ 有實際舉例說明其差異。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;架構師的工作到底是做啥？用一張十年前 (2012) 我自己在 &lt;a href=&quot;https://www.plurk.com/p/hp91r2&quot;&gt;Plurk&lt;/a&gt; 寫下的定義，然後再真實經歷之後，重新回顧這段話。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/About/201211_as-Architect.jpg&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://www.plurk.com/p/hp91r2&quot;&gt;Plurk Permalink&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這篇是我在粉專寫下的 &lt;a href=&quot;https://www.facebook.com/completethink/posts/pfbid02kxY7WJLh6aWnpVNuSeK8z6WQm26kEVqPuzrcYKVyEjAFhPjwzF6pau1Y2uyKPx9rl&quot;&gt;隨筆文&lt;/a&gt;，放在 blog 做個紀錄。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
  </entry>
  
  <entry>
    <title>蓋環境很難？是這樣的嗎？QA 需要自己蓋環境？</title>
    <link href="https://rickhw.github.io/2022/09/25/SQA/QA4QA-Provisioning-is-Difficult/"/>
    <id>https://rickhw.github.io/2022/09/25/SQA/QA4QA-Provisioning-is-Difficult/</id>
    <published>2022-09-25T03:08:00.000Z</published>
    <updated>2022-12-19T11:47:28.869Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2022/08/13/SQA/Path-to-Software-Testing/">上一次的分享</a> 之後，開始有 QA 的朋友找我聊很多他正在面對的問題。其中一個問題是：</p><blockquote><p>Backend 開發人員說建立環境很難？是這樣嗎？</p></blockquote><p>本文針對這個問題，整理背後可能的問題，以及實際可行的方法。全文整理自 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tC7UQ4JMVfUf7bXng3o4wM6FfTZc6HzzW1NujnZgZ6p8cRJznMHkBXWBmHZKXLjcl">09&#x2F;18 在 FB 寫的草稿</a>。</p><span id="more"></span><hr><h1 id="Backend-開發人員說建立環境很難？是這樣嗎？"><a href="#Backend-開發人員說建立環境很難？是這樣嗎？" class="headerlink" title="Backend 開發人員說建立環境很難？是這樣嗎？"></a>Backend 開發人員說建立環境很難？是這樣嗎？</h1><p>標題簡化了一些訊息，重現原本的提問：</p><blockquote><p>我是一個 QA，我曾經找 Backend 開發人員問，我想自己建環境測試，他們說很難，Config 很雜亂、DB Schema 很複雜、Infra 很複雜，真的是這樣？</p></blockquote><p>重新整理提問，整個問題是從 <a href="/2017/02/11/DevOps/Resource-Provisioning-and-DevOps/">蓋環境 (專有名詞 Provisioning)</a> 出發，對於測試人員來看，背後 <code>動機</code> 與 <code>目的</code> 有以下：</p><ol><li>因為執行測試過程會被自動觸發的 CI 部署打斷，希望不被干擾執行</li><li>想要透過了解環境，更確立問題的正確性</li><li>想要透過 Log 找問題，目前環境無法看到 Log</li><li>測試過程，想進去 DB 增加資料，查問題</li></ol><p>從開發人員的回覆，可以看出背後有以下問題：</p><ol><li>Config 很雜亂</li><li>DB Schema 很複雜</li><li>Infra 很複雜</li></ol><h2 id="1-現象：Config-很雜亂"><a href="#1-現象：Config-很雜亂" class="headerlink" title="1. 現象：Config 很雜亂"></a>1. 現象：Config 很雜亂</h2><p>Config 指的是應用程式在啟動階段透過外界指定的配置資訊，應該在 <code>系統設計 (System Design)</code> 過程就要確立的結構，這屬於 <code>Application Interface</code> 的範疇，也是 System Design 階段要確立的東西。</p><blockquote><p><code>Application Interface</code> 是我自己定義的名詞，用來描述一個應用程式的外顯介面。只要是使用者會接觸到的資訊，都屬於外顯介面，像是 Config &#x2F; Environment Variables &#x2F; Secret &#x2F; API &#x2F; Documentation … etc.</p></blockquote><p>常見的 Config 大概可以分成以下幾個部分：</p><ol><li>系統依賴：<ol><li>會有 connection string 的，包含 ip &#x2F; host、protocol、id &#x2F; password 、parameters 等。</li><li>服務自己的基礎設施，像是對 Database &#x2F; Cacche &#x2F; Queue .. 等依賴</li><li>公司內部與第三方系統的依賴：<ol><li>公司內部：像是依賴於內部的 簡訊服務、另一個服務的 API … 等。</li><li>第三方服務：像是依賴於 Google SSO、AWS S3 服務、Twillo 的簡訊服務、Paypal 的金流服務 … 等。</li></ol></li></ol></li><li>業務邏輯功能的初始與預設參數：<ol><li>通常是 Feature Toggle 以及其參數</li><li>每頁商品數量的預設數量</li><li>其他 … etc</li></ol></li><li>非功能的參數：<ol><li>Logging: Rotation 的規則、擋名規則、輸出模式 (File or Stdout) ..</li><li>DI 框架的參數，像是 Autowire 掃描的規則</li><li>框架的設定</li></ol></li></ol><p>這些依照實際案例，會有所差異，不過我個人大概是這樣分。</p><p>Config 需要有經驗的人、經過有設計的過程，持續精煉與重構。因為沒有這個循環，隨著時間的推進 (通常是 &gt;2y)，會越來越複雜，隨之而來的是管理複雜度。如果再加上多環境部署 (不管 Test or Prod)，管理問題就會浮上檯面。</p><blockquote><p>Config 的設計概念參閱 <a href="/2022/05/06/Coding/Designing-Configuration-Loading-Strategies/">Designing Configuration Loading Strategies</a></p></blockquote><h3 id="問題背後的問題-QBQ"><a href="#問題背後的問題-QBQ" class="headerlink" title="問題背後的問題 (QBQ)"></a>問題背後的問題 (QBQ)</h3><ol><li><code>開發過程沒有設計與管理</code>：在新需求開發過程中，Config 很常會因為新需求而增加，這時候沒有適度的設計與管理，時間久了，一定開花。<ol><li>不管用 K&#x2F;V 結構 (.properies) 或者 object (XML &#x2F; JSON &#x2F; YAML)，只要沒有配套的 <code>技術管理機制</code>，最後就是整串葡萄串大亂鬥</li><li>機制：透過統一個 ConfigLoader 限制，包含命名規則、資料結構驗證等</li><li>規範：要有設計與 Review 流程</li></ol></li><li><code>沒有持續收斂設計</code>：如果沒有適度的技術管理機制持續收斂，時間越久越亂是正常的<ol><li>各種亂象出現在 Config 裡，像是在一個 JSON element 裡面塞入一個 XML string</li><li>在一個 XML 的 attribute 裡塞入整個 JSON payload</li></ol></li><li><code>部署管理機制不踏實</code>：<ol><li>不管有沒設計或收斂，都需要面對管理問題，因為只要有部署的需求，部署的環境越多，就要有管理流程。</li><li>實際上 APP 的部署第一關應該是 QA 要把關，這概念在 “<a href="/2018/12/15/DevOps/TheProblem-In-DevOps-8-Cycle/">DevOps 8 字環的誤區：左環問題</a>“ 有深入說明。</li></ol></li></ol><p>理想 Config 實踐流程有以下的循環：</p><ol><li><code>設計優先 (Design First)</code>: 系統設計的時候，#TechLead 必須把關規格</li><li><code>持續迭代 (Continuous Iteration)</code>: 每次更版都要做適度的調整與迭代</li><li><code>管理政策 (Management Policy)</code>: 也就是每次的更版要遵守的規範，例如 Key 的 增刪改 各自需要應對的措施<ul><li>這些規範背後需要技術支撐，像是 Config Migration 機制與流程</li></ul></li></ol><h2 id="2-現象：DB-Schema-很複雜"><a href="#2-現象：DB-Schema-很複雜" class="headerlink" title="2. 現象：DB Schema 很複雜"></a>2. 現象：DB Schema 很複雜</h2><p>DB Schema 很複雜 (或者很亂)，其實背後本質是跟 Config 一樣的問題。</p><p>DB Schema (這裡指的是 Ralation DB, 不是 NoSQL) 一樣是要經過設計與收斂，透過迭代 <code>去蕪存菁</code>、<code>精煉</code>。資料結構的設計難的是在初期 <code>判斷</code> 與 <code>預測</code> <strong>判斷資料溫度在未來的變化性</strong>，因為很難一次到位，所以通常都要透過以下方法：</p><ol><li>設計階段 Tech Leader 需要把關 DDL 的設計</li><li>持續小部分的迭代與改進，調整資料溫度的配置，例如：<ol><li>原本判定是 <code>熱資料</code>，後期變成冷資料，那應該就要設計 Archive 機制，轉入 <code>OLAP</code></li><li>原本是以為是 <code>冷資料</code>，變成溫資料，那就要透過快取緩存改善</li><li>原本是以為是 <code>熱資料</code>，上線後發現根本沒有存取，所以要改成冷資料，或者一次快取。</li></ol></li><li>規劃每次更版 DDL &#x2F; DML Migration 機制與流程</li></ol><p>這些都是透過 <code>持續迭代</code> 改善出來的，會越來越亂，都是因為 <code>沒有持續迭代</code>、或者 <code>經驗不足</code> 與 <code>能力不夠</code> 造成的。經驗與能力我覺得找到適當的人就可以了，難的是專案管理過程中，沒有持續迭代，這也是普遍公司的問題。</p><p>看到這裡，不難發現， Config &#x2F; DB Schema 的處理與管理手段是一樣的。</p><h2 id="3-現象：Infra-很複雜"><a href="#3-現象：Infra-很複雜" class="headerlink" title="3. 現象：Infra 很複雜"></a>3. 現象：Infra 很複雜</h2><p>再來談談 Infra 的部分，其實也是一樣的。</p><p>通常一個應用程式起來，都會有相應的依賴，常見的有:</p><ol><li>Database (RDB &#x2F; NoSQL): MySQL &#x2F; PostgreSQL &#x2F; MongoDB &#x2F; DDB … etc</li><li>Cache: Redis &#x2F; Memcached</li><li>Queue: RabbitMQ &#x2F; SQS</li><li>Storage: File System &#x2F; Object Storage (S3, GCS)</li></ol><blockquote><p>上述的排序：Structure to Non-Structure</p></blockquote><p>這些東西，通常難的都不是建立 (Provisioning) 起來這件事情，因為這年代有 docker &#x2F; container 這個技術，通常只要 config 講清楚，不會太難。上面列的最難的大概只有 RDB (Relation Database)，因為他有 DDL 需要做 Migration，這個會稍微難一點。現在很多 ORM 都有對應的方法與策略，概念從 RoR (Ruby on Rails, 2008) 年代就有了，基本概念就是可以做到持續更迭 DDL。所以最難的沒了。</p><p>其他不管是 NoSQL &#x2F; Cache &#x2F; Queue &#x2F; Storage …. 都談不上難。</p><ul><li>NoSQL 本身就是沒有 DDL Migration 的問題，因為這東西本身就是 Non-Schema 的。</li><li>Cache 通常就是一些 Key &#x2F; Value 的操作，所以只要知道 Key 的定義與結構即可</li><li>Queue 是通道的概念，大部分只要把通道規則弄好就好，一次性的。</li><li>Storage 目錄結構，不管是 Object Storage or Block Storage，搞懂目錄結構即可。</li></ul><p>很多人想問，像那些 Replication &#x2F; HA &#x2F; Cluster 不是很難嗎？</p><p>這時候我會先分清楚目的性：<code>Functional Test</code> or <code>NonFunctional Test</code></p><p>如果前者，基本上，不用考慮這些是。如果是測後者，才需要考慮這些事情，看你自己的 R&amp;R。後者通常跟 <code>架構</code> 很有關係，因為 前述的 (HA, Cluster … ) 很多都跟 <a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">Reliability</a> 有關係，可靠度本質就是工程 &#x2F; 架構 要面對的問題，這才是真正的難。</p><p>相關概念參閱以下的文章：</p><ul><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li><a href="/2022/09/18/SQA/Integration-Test-and-Execution-Strategy/">整合測試與執行策略</a></li><li><a href="https://rickhw.github.io/2018/03/18/SQA/Gossip-System-Testing/">輕鬆聊：系統測試 (SVT) 的三兩事</a></li><li><a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性工程 (Reliability Engineering)</a></li></ul><p>除了這些，可能還有其他像是 Networking, Platform (K8s) 的依賴。</p><hr><h1 id="問題背後的問題-Problem-Behind-Question-PBQ"><a href="#問題背後的問題-Problem-Behind-Question-PBQ" class="headerlink" title="問題背後的問題 (Problem Behind Question, PBQ)"></a>問題背後的問題 (Problem Behind Question, PBQ)</h1><h2 id="很雜亂？很難？"><a href="#很雜亂？很難？" class="headerlink" title="很雜亂？很難？"></a>很雜亂？很難？</h2><p>上述的東西，都很雜，談不上難，但是時間只要越來越久，就會由雜變成難。更多參閱： “<a href="/2022/09/10/About/Difficult-and-Complicate/">問題的難與雜</a>“</p><p>只要有遵循前述的設計原則，持續迭代，給一台 Linux，足夠的 CPU &#x2F; Memory &#x2F; Disk，應該沒什麼做不到的。</p><p>去看看外面 Open Source ，我沒看過有哪個說一定要 K8s &#x2F; AWS &#x2F; GCP 才能安裝的？</p><p>我把問題歸類為：</p><ol><li>設計問題</li><li>能力問題</li><li>執行力</li></ol><p>對於 QA 而言，我自己親身經驗，裝軟體這件事情，只要上述條件具備，剩下的都是指日可待的問題。所以這問題，最後我的回答都是一樣的：</p><blockquote><p>如果你覺得很複雜，那表示不夠熟悉；如果覺得很難，那代表基本功不夠紮實；如果覺得很亂，那大多都是管理問題。</p></blockquote><!--RD 要會裝自己的環境就是基本功RD 自己都搞不定那 QA 就更遠了窮和尚富和尚# 議題：QA 需要自己蓋環境嗎？# 延續問題：如果公司開發團隊無法做到像你說的那樣，那我應該繼續待下去？--><h2 id="團隊的問題"><a href="#團隊的問題" class="headerlink" title="團隊的問題"></a>團隊的問題</h2><p>而蓋環境背後也可以看出整個開發團隊的問題：</p><ol><li>Backend 開發人員都覺得蓋環境難，表示不了解整體架構與對外依賴配置<ol><li>有很多依賴問題：<ol><li>例如強依賴於 Cloud Services，像是 AWS S3 &#x2F; Secret Management，卻沒有做適度的設計。</li><li>像是用了 EKS 的 IRSA，或者 AWS IAM Role，就以為一定要 AWS 應用程式才能跑，其實這些都是不了解運作原理，以及沒有適度設 Config 造成的。</li></ol></li><li>時間久了，導致連開發人員自己都蓋不起來，就連一些 Sr. Engineer 都搞不定。</li><li>沒有適度切割顆粒度，導致 Config 隨時間增長，複雜度過高。<ol><li>切割顆粒度背後代表著要重構，一個 Method 有一千行，通常就要拆分職責。</li></ol></li></ol></li><li>太過依賴於所謂的 <code>自動化</code>，而自動化的程式本身的品質堪憂，導致部署難度越來越高。<ol><li>只有寫自動化的人大概知道整個架構是怎麼一回事</li></ol></li><li>Config 的資訊只有開發人員知道，其他 (QA &#x2F; Ops) 都不知道</li><li>蓋環境這件事情，在團隊裡是一個天方夜譚的 #能力</li></ol><p>所以，得到結論：</p><blockquote><p>蓋環境這件事情不可能<br>需要動用很多團隊</p></blockquote><p>上述問題，在越有歷史、越有規模，但不注重軟體工程的公司，越容易發生。</p><blockquote><p>翻譯：很多 (九成九) 公司都有這樣的問題。</p></blockquote><h2 id="怎麼解？"><a href="#怎麼解？" class="headerlink" title="怎麼解？"></a>怎麼解？</h2><p>做好該做的基本功，只要想省略、或者用自動化掩蓋的念頭，時間越久會越雜。 OOP 之所以會出現，是因為 早期程式發展到複雜度而產生，而 OOP 背後的本質就是持續的分類與重構。</p><p>問題提到的 Config &#x2F; DB Schema &#x2F; Infra 其實都是要持續設計與改善的。不是只有自動化就天下太平，自動化只會粉飾太平。</p><p>公司已經 Run 一段時間 (&gt;3y) 了，怎麼辦？這時候只能請 <a href="/2019/09/13/DevOps/Scrum-for-SRE-Team/">扁鵲</a> 出場開刀了，不用懷疑，任何想要走捷徑的方法，最後一定死路一條。該開刀，就要開刀，沒有特效藥。</p><h2 id="QA-需要自己蓋環境嗎？"><a href="#QA-需要自己蓋環境嗎？" class="headerlink" title="QA 需要自己蓋環境嗎？"></a>QA 需要自己蓋環境嗎？</h2><p>QA 的職責之一是發現問題。</p><p>發現問題這個過程，背後代表要能證明 <code>症狀 (Symptom)</code> 真的是一個 <code>問題 (Problem)</code>。如果已經是問題了，那麼一定能夠提供完整的重現步驟 (Reproducable)，有相關的證據，像是 Log、Config、Data …. 等。這個過程本身是非常講究科學方法的，</p><p>當掌握環境建置的時候，上述的過程才能夠有效地掌握，也才能找出有意義的 Defect。</p><p>對我來講，蓋環境，是 QA 的第一個條件，這段在 “<a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a>“ 的技能段落排第一位。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2022/09/05/About/Blog-Practice/">聊聊寫 Blog 的想法</a></li><li><a href="/2022/05/06/Coding/Designing-Configuration-Loading-Strategies/">Designing Configuration Loading Strategies</a></li><li><a href="/2022/09/10/About/Difficult-and-Complicate/">問題的難與雜</a></li><li><a href="/2018/12/15/DevOps/TheProblem-In-DevOps-8-Cycle/">DevOps 8 字環的誤區：左環問題</a></li><li><a href="/2017/02/11/DevOps/Resource-Provisioning-and-DevOps/">Resource Provisioning and DevOps</a></li><li><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題 (How to Report Problems Effectively)</a></li><li><a href="/2018/04/01/DevOps/How-To-Make-CICD-Quality/">怎樣的 CI&#x2F;CD 才夠 Quality?</a></li><li><a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性工程 (Reliability Engineering)</a></li><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li></ul><h2 id="Facebook-隨筆"><a href="#Facebook-隨筆" class="headerlink" title="Facebook 隨筆"></a>Facebook 隨筆</h2><ul><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0tC7UQ4JMVfUf7bXng3o4wM6FfTZc6HzzW1NujnZgZ6p8cRJznMHkBXWBmHZKXLjcl">Backend 開發人員說建立環境很難？是這樣嗎？</a></li><li><a href="https://www.facebook.com/completethink/posts/pfbid09UTWvYbHLnKKixJyWiinmXQGCc7tuTkuoZ9Gna7W8KPzZxSp7vQL6jkhdaZVRthXl">軟體工程師需要會蓋環境？</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid024b4F5Q9xngNAV6NsqGi7wMZs4WVQPpohjCmGkomcGGCAYqirYeEjV2hDhW8LE2Eql">Container vs VM</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0he6RNijEgMFY4pUcfWcUbJqRqZMmqw9pzHfCtw6gWQoG12b9YhZhZ2smMgJKEB7Jl">難與雜</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/2022/08/13/SQA/Path-to-Software-Testing/&quot;&gt;上一次的分享&lt;/a&gt; 之後，開始有 QA 的朋友找我聊很多他正在面對的問題。其中一個問題是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Backend 開發人員說建立環境很難？是這樣嗎？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文針對這個問題，整理背後可能的問題，以及實際可行的方法。全文整理自 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0tC7UQ4JMVfUf7bXng3o4wM6FfTZc6HzzW1NujnZgZ6p8cRJznMHkBXWBmHZKXLjcl&quot;&gt;09&amp;#x2F;18 在 FB 寫的草稿&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="軟體測試" scheme="https://rickhw.github.io/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
    
    <category term="Software Test" scheme="https://rickhw.github.io/tags/Software-Test/"/>
    
    <category term="Software Quality Assurance" scheme="https://rickhw.github.io/tags/Software-Quality-Assurance/"/>
    
  </entry>
  
  <entry>
    <title>整合測試與執行策略</title>
    <link href="https://rickhw.github.io/2022/09/18/SQA/Integration-Test-and-Execution-Strategy/"/>
    <id>https://rickhw.github.io/2022/09/18/SQA/Integration-Test-and-Execution-Strategy/</id>
    <published>2022-09-18T03:08:00.000Z</published>
    <updated>2022-12-19T11:47:28.869Z</updated>
    
    <content type="html"><![CDATA[<p>在 “<a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a>“ 整理了各種測試的 “階段”，其中 #整合測試 (Integration Test) 是常見的階段之一，針對 “整合” 我的脈絡有以下：</p><ol><li><code>功能對功能</code> 的整合</li><li><code>系統對系統</code> 的整合</li><li><code>功能對系統</code> 的整合</li></ol><p>引用我 <a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">上次分享</a> 整理的文字描述，如下圖：</p><p><img src="/images/SQA/Integration-Test_Service-Test.png"></p><p>Source: <a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></p><span id="more"></span><h2 id="整合功能的案例"><a href="#整合功能的案例" class="headerlink" title="整合功能的案例"></a>整合功能的案例</h2><p>整合功能其實生活中很多，大家平常在用的產品都很常出現。</p><h3 id="案例：功能對系統的整合"><a href="#案例：功能對系統的整合" class="headerlink" title="案例：功能對系統的整合"></a>案例：功能對系統的整合</h3><p><a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">上次分享</a> 中我用 PCHome 的訂單快照 + 訂單快照的 SLA 來當整合的例子，這是個 <code>功能對系統</code> 整合測試的案例。</p><p><img src="/images/SQA/Integration-Test/PChome-OrderCapture-and-SLA.png"></p><h3 id="案例：功能對系統的整合-1"><a href="#案例：功能對系統的整合-1" class="headerlink" title="案例：功能對系統的整合"></a>案例：功能對系統的整合</h3><p>另外一篇 “<a href="https://rickhw.github.io/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">有效回報問題</a>“ 則舉例很久以前我自己遇過的例子：<code>時間跟充電</code> 兩個整合造成的問題。這也算是 <code>功能對系統</code> 的整合問題。當時的錄影如下：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/o0q2DJPnb1Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>文中針對問題現象做以下紀錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Environment</span></span><br><span class="line"></span><br><span class="line">- iOS 11.4.1</span><br><span class="line">- iPad Air 128Gb.</span><br><span class="line"></span><br><span class="line"><span class="comment">## How to reproduce?</span></span><br><span class="line"></span><br><span class="line">1. connect the power adapter to iPad</span><br><span class="line">2. open Click app, tap Timer, <span class="built_in">set</span> a countdown <span class="keyword">in</span> 5s</span><br><span class="line">3. start the countdown</span><br><span class="line">4-1: stop the sound by tab Home button,</span><br><span class="line">4-2: stop the sound by swiping up notification</span><br><span class="line"></span><br><span class="line"><span class="comment">## Expected Result</span></span><br><span class="line"></span><br><span class="line">Sound should be stopped.</span><br><span class="line"></span><br><span class="line"><span class="comment">## Acturl Result</span></span><br><span class="line"></span><br><span class="line">Sound keeps playbacking, unstoppable.</span><br><span class="line"></span><br><span class="line"><span class="comment">## Notes</span></span><br><span class="line">- Remove power adapter to fix the issue.</span><br><span class="line">- No issue on iPhone6</span><br></pre></td></tr></table></figure><h3 id="案例：功能對功能的整合"><a href="#案例：功能對功能的整合" class="headerlink" title="案例：功能對功能的整合"></a>案例：功能對功能的整合</h3><p>最近 iPhone 14 上市了，新的功能 <code>動態島 (Dynamic Island)</code> 成為大家讚不絕的設計。這樣的功能改善了視覺上的體驗。但很快的鄉民就發現這個功能和 <code>既有的功能 (橫向螢幕)</code> 一整合問題就出來了，這也典型的 <code>功能對功能</code> 整合的案例。</p><p><img src="/images/SQA/Integration-Test/iPhone14-Dynamic-Island.JPG"></p><h2 id="整合測試的-理論範圍"><a href="#整合測試的-理論範圍" class="headerlink" title="整合測試的 理論範圍"></a>整合測試的 <code>理論範圍</code></h2><p><code>整合</code> 的基本定義：</p><ol><li>平面二維，也就是<code>(A + B)</code> 的概念，兩個功能的整合</li><li>三維或以上：A + B + C 或者 A + B + C + D … 三個或以上的功能混合。</li></ol><p>在軟體設計時，如果沒有針對功能與功能之間作討論與規劃，整合功能會出現 <code>Defect</code> or <code>新功能</code>，是無法預測的。</p><p>舉例來說，iOS 的設定列表上假設有 5 個功能 (A, B, C, D, E)，這 5 功能彼此之間有沒有關係？先不管有沒關係，先假設都有關係，而且是一對一的組合，那麼這五個功能之間有多少排列組合？用二維的概念來列舉排列組合如下：</p><ol><li>A: A + B, A + C, A + D, A + E &#x3D; 4</li><li>B: B + C, B + D, B + E &#x3D; 3</li><li>C: C + D, C + E &#x3D; 2</li><li>D: D + E &#x3D; 1</li><li>E: 0</li></ol><p>以上共有 4 + 3 + 2 + 1 &#x3D; 10 個組合，簡單列個公式：</p><blockquote><p>n (n-1) &#x2F; 2</p></blockquote><p>有 10 個功能，組合有 45 個、20 功能組合有 190 個。這是二維的整合，如果是三維的整合功能，那複雜度就更高了。</p><p>這段描述不管是二維、還是三維以上的前提是：功能彼此之間是攤平的，不是巢狀結構，沒有上下依存關係。功能的關係是立體的，數量的公式就不是這麼單純的了。</p><p>排列組合的好處是可以看到理論的最大範圍，也就是如果出問題，應該都在排列組合之內。缺點則是排列組合會包含很多不合使用邏輯、不會真實存在的情境。</p><blockquote><p><a href="https://zh.wikipedia.org/zh-tw/%E5%8F%AF%E8%A7%80%E6%B8%AC%E5%AE%87%E5%AE%99">宇宙可觀測範圍</a> 是天文學家推論的理論值範圍，實務上人類可能到地球毀滅都還是走不出銀河系。</p></blockquote><hr><h2 id="整合測試的-可執行策略"><a href="#整合測試的-可執行策略" class="headerlink" title="整合測試的 可執行策略"></a>整合測試的 <code>可執行策略</code></h2><p>在軟體測試的過程，首先會依照上述的理論範圍規劃測試計畫？實務上不會，所以執行測試也就不會這樣做，因為勞民傷財。</p><p>實務上的 <code>執行策略</code> 都是根據核心情境，和 <code>核心功能 (Happy Path)</code> 展開，以此列出有關的排列組合，列出來的就是要放入測試計畫中執行的，這樣大概就可以扣除排列組合 70% 以上的範圍。這時候所謂的自動化進場才有實務上的價值。</p><p>以這次 iPhone 14 動態島來看，理論上測試計畫必須依照這個新的關鍵功能展開，列舉可能有關的功能組合。只要是跟畫面位置、動畫有關係的功能，應該都要列入測試範圍。所以以結果論來看，我會覺得蘋果的測試管理應該要加強。 XDD</p><p>那剩下的 70% 的組合怎麼辦？這時候所謂的 <code>探索性測試 (Exploratory Testing)</code> 或 <code>田野/現場測試 (Field Testing)</code> 就是扮演著重要的階段。實務上這兩種差異前者是 <code>Release 前 (In-House)</code>，後者是 <code>Run on Production</code>。我比較常用的是後者 Field Test，也就是 As a End User 的角度，直接像是鄉民那樣，試各種極端值，各種不合邏輯的排列組合。以前測 IoT 產品就是團隊全都人都發一套帶回家用，有問題直接回報。同時在辦公室也把了全部的產品，實際上在辦公室也在用。</p><p>現在很多公司其實是直接把探索性測試外包給 Youtuber &#x2F; KOL 處理，在產品 Release 前就先收回饋，避免到田野之後鄉民的反饋更大。因為 Youtuber &#x2F; KOL 可以幫忙擋 XDD</p><p>這概念跟 Unit Test 的邊界測試是一樣的。</p><hr><h2 id="說說測試管理"><a href="#說說測試管理" class="headerlink" title="說說測試管理"></a>說說測試管理</h2><p>軟體測試 的 Lead 有個很重要的任務：</p><blockquote><p>測試管理</p></blockquote><p>測試管理的工作範圍很大，其中之一是要定義：</p><ol><li>測試理論範圍</li><li>可執行的範圍</li><li>探索與現場測試策略</li></ol><p>定義這些範圍，才會有效地往下展開測試計畫、資源調度、有效執行、有效建議。<br>因為只有這樣，才能回答那句：</p><blockquote><p>為什麼這個沒有測到？</p></blockquote><hr><h1 id="延伸閱讀-站內"><a href="#延伸閱讀-站內" class="headerlink" title="延伸閱讀 (站內)"></a>延伸閱讀 (站內)</h1><ul><li><a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li><a href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="https://rickhw.github.io/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 “&lt;a href=&quot;https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/&quot;&gt;淺談軟體測試的階段與策略&lt;/a&gt;“ 整理了各種測試的 “階段”，其中 #整合測試 (Integration Test) 是常見的階段之一，針對 “整合” 我的脈絡有以下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;功能對功能&lt;/code&gt; 的整合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;系統對系統&lt;/code&gt; 的整合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;功能對系統&lt;/code&gt; 的整合&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;引用我 &lt;a href=&quot;https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/&quot;&gt;上次分享&lt;/a&gt; 整理的文字描述，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SQA/Integration-Test_Service-Test.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/&quot;&gt;演講：從理想、到現實的距離，開啟品味軟體測試之路&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="軟體測試" scheme="https://rickhw.github.io/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
    
    <category term="Software Test" scheme="https://rickhw.github.io/tags/Software-Test/"/>
    
    <category term="Integration Test" scheme="https://rickhw.github.io/tags/Integration-Test/"/>
    
    <category term="Strategy" scheme="https://rickhw.github.io/tags/Strategy/"/>
    
  </entry>
  
  <entry>
    <title>Development Experience for Team</title>
    <link href="https://rickhw.github.io/2022/09/17/Management/Development-Experience-For-Team/"/>
    <id>https://rickhw.github.io/2022/09/17/Management/Development-Experience-For-Team/</id>
    <published>2022-09-17T02:30:00.000Z</published>
    <updated>2022-12-19T11:47:28.863Z</updated>
    
    <content type="html"><![CDATA[<p>整理對 Development Experience (DX) 的看法，原文草稿發表於 <a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02oAjkjeVHVcUTyiSeJzB1FutD6me2rBveFMVz9tpeASrXcvQfcCMbqpMDT64A49fel">Facebook</a>。</p><span id="more"></span><hr><h2 id="一、海賊王-D-之一族的傳說：定義-Developer-or-Development"><a href="#一、海賊王-D-之一族的傳說：定義-Developer-or-Development" class="headerlink" title="一、海賊王 D 之一族的傳說：定義 Developer or Development"></a>一、海賊王 D 之一族的傳說：定義 Developer or Development</h2><p>首先是 DX 這個詞 D 的定義，很容易被理解成 <code>Developer Experience (DX)</code>，而 Developers 通常指的是 <code>寫 Function / Feature 的人</code>。所以有各式各樣的想法、做法、工具，讓開發人員更順暢的工作、提升產能，像是 工程師喜歡 找了一堆工具來增加產能、或者讓工作更流暢，像是 VSCode 的 Extensions。</p><blockquote><ul><li>註一：<code>寫 Function / Feature 的人</code> 更精準的詞應該叫做 <code>Programmers</code>，而社群的鄉民會用 <code>Coders</code> 這個詞來調侃自己，而外界更普遍的用詞稱他們為 <code>Engineers</code>，但實際上 Engineers 其實包含其他像 QA &#x2F; Ops 等角色。</li><li>註二：關於 Developer vs Engineer 的差異，我個人的定義參閱 “<a href="/2017/07/01/Management/Developer-or-Engineer/">Developer vs. Engineer</a>“。</li><li>註三：啥是 Function &#x2F; Feature 以後再說。。。再歪樓下去我會收不了筆。。。</li></ul></blockquote><p>不過比起 Developer Experience，我覺得 <code>Development Experience</code> 更適當。Development 代表參與這個產品開發的團隊所有成員 (Team)，我在 “<a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a>“ 一文定義常見的角色有以下四大類：</p><ol><li><code>Planner</code>: PO &#x2F; PM &#x2F; UI&#x2F;UX &#x2F; SA &#x2F; Architect &#x2F; Developer</li><li><code>Executor</code>: SWE &#x2F; Programmer &#x2F; Coder</li><li><code>Accepter</code>: <a href="/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/">STE &#x2F; QA &#x2F; Tester &#x2F; SDET &#x2F; QE &#x2F; QoO</a></li><li><code>LiveKeeper</code>: Ops &#x2F; Infra &#x2F; <a href="/2018/08/03/DevOps/An-Introduction-to-SRE/">SRE</a> &#x2F; <a href="/categories/DevOps/">DevOps</a> &#x2F; SE &#x2F; IT &#x2F; MIS &#x2F; …</li></ol><blockquote><ul><li>其中 2), 3), 4) 統稱 Engineers。</li><li>中文很麻煩，當我寫 工程師 實際上想表達的是 Programmer，而對我來說，大部分的 <code>工程師</code> 都不能算是 <a href="/2017/07/01/Management/Developer-or-Engineer/">開發者</a></li><li><a href="https://software-engineering-at-google.gh.miniasp.com/#/">Software Engineering at Google</a> 這本書一開始提到 <code>工程 (Engineering)</code> 的定義，我自己的定義有兩個面向：<code>已知規模 (Known Scale)</code>、<code>可以擴展的規模 (Scalable)</code>。<ol><li>已知規模例，如 … 要建立捷運板南線、三峽大壩、台電輸配電工程、蓋 101 大樓  … 等已知的巨觀規模。</li><li>另外一種則是未知規模、但可以擴展成巨觀的能力，稱為可擴展 (Scalable)，軟體工程大多就是這種。</li><li>不管是已知規模、還是可擴展的規模，工程都必須具備的關鍵特性：<a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性 (Reliability)</a>。前述兩個定義，都要具備可靠性，才能稱之工程。</li></ol></li></ul></blockquote><p>這些成員，都是 Development Team 的一員。Programmer 有太多 DX 的方法、工具，但我覺得，整個團隊不是只有 Programmer 才是人，也應該關心一下，開發團隊其他成員的開發體驗。</p><ol><li>大家知道我們的 QA 是怎麼測試的？開始測試前應該具備哪些條件 (先不用談測試左移)？</li><li>大家知道 上線前、中 Ops &#x2F; DevOps 怎麼處理 Infra &#x2F; Build &#x2F; Deploy 的事情？上線後 Ops &#x2F; SRE 是怎麼處理線上異常與事件？應該怎樣改善這些體驗？</li><li>還有辛苦的 Planner (PO &#x2F; PM …) 是如何把需求收斂成可執行的規格的？</li></ol><p>這 <code>整個過程</code> 有體驗可言？怎麼改善這個過程的體驗，讓大家開發的協作有更順暢的體驗？</p><blockquote><p>Again, <a href="/2022/08/13/SQA/Path-to-Software-Testing/">品質是整個開發過程</a></p></blockquote><h3 id="DevOps？"><a href="#DevOps？" class="headerlink" title="DevOps？"></a>DevOps？</h3><p>歪個樓，大家常聽到的 <code>DevOps</code> 這個 BuzzWords，通常理解的都是狹義的 Development、或者一些文化之類的，也就是前一段提到的 “2), 4)” 的關係。</p><p>廣義的 DevOps 的 Dev 也不是單純講 Programmer，而是以公司角度來看的產品開發 (Product Development)，而 Ops 比較像是業務與營運單位。這個角度來看，我前面提到的四個角色都屬於 Development Team，而 Operation Team 則是把業務帶進來、讓客戶留下來的管理單位，像是業務、行銷、營運單位 … 等。</p><p>類似概念可以看我幾年前分享的演講 “<a href="/2019/04/27/DevOps/Introduce-to-Continuous-Delivery-2/">導讀持續交付 2.0 - 談當代軟體交付之虛實融合</a>“，有提到廣義 DevOps 的看法，如下圖：</p><p><img src="/images/DevOps/Introduce-to-CD20/p4-01.png"><br><img src="/images/DevOps/Introduce-to-CD20/p4-02.png"></p><hr><h2 id="二、Are-You-Experienced：是-誰-的體驗-Experience"><a href="#二、Are-You-Experienced：是-誰-的體驗-Experience" class="headerlink" title="二、Are You Experienced：是 誰 的體驗 (Experience)"></a>二、Are You Experienced：是 <code>誰</code> 的體驗 (Experience)</h2><p>標題引用 傳奇音樂家 Jimi Hendrix 最有名的專輯：<a href="https://en.wikipedia.org/wiki/Are_You_Experienced">Are You Experienced</a>，是音樂史的里程碑，重新定義了如何體驗音樂。AWS 2015 的 <a href="https://aws.amazon.com/blogs/aws/are-you-well-architected/">Well-Architected Framework</a> 介紹也引用這個概念。</p><p>談完 D 的定義，再來談談體驗 (Experience)，我想專注的是 “誰” 的體驗？</p><p>關於體驗，大家最常見的就是 <code>User Experience (UX)</code>，這個 User 指的是終端使用者 (End User)。最經典了例子就是 <code>開箱</code>，源自於 Apple 產品的體驗感，讓廣大鄉民都可以藉此寫寫廢文、找理由當 Youtuber、無腦下單 … etc。</p><p>承接上一段 Development 對象的定義，而對於 Programmer 而言，最常見的開箱就是：</p><ul><li>到 GitHub 找到一個 Open Source，透過 Quick Start &#x2F; Getting Started 快速體驗怎麼用，能否解決問題、或者有炫砲的感受。。。。</li><li>這十幾年全世界開發的份圍，體驗就是：一堆花花綠綠的 terminal、emoji、powerline … 等炫砲 …</li></ul><p>如果不容易讓人理解怎麼用，就會被跳過去，因為開箱體驗不好。</p><p>上述我覺得都是普遍的第一觀感，其實這些也滿重要的，雖然有時候覺得有點膚淺，但確實是會讓人更容易入門。</p><p>我覺得真正的開發體驗應該是這種，舉例以下幾種：</p><ul><li>第一個是 <a href="https://specflow.org/">SpecFlow</a>： 改善橫跨 PO &#x2F; Programmer &#x2F; Tester 針對規格的理解，與落地執行測試的方法。有了這個方法與概念，才有後面的工具產生。</li><li>第二個是 Containzied (Docker)：這個技術的出現，改善了交付的定義，讓所有角色 (四大) 都可以用統一個方法輕易的交付，終結 <code>在我的電腦可以跑，你的電腦不能跑</code> 的交付體驗。</li></ul><p>這兩個例子，都是軟體開發劃時代的體驗，我相信還有其他很多概念、方法、技術改善了團隊協作，增加效率。</p><p>另外語言層級的改善，像是 .NET6 從 v3.1 ~ v6 的改善，也是個不錯的案例。.NET Developer 如果 .NET 3.1 到 6 一路體驗下來，就可以感受到在 Language 層次的體驗，越來越精簡、越來越多語法糖，啟動 Startup.cs &amp; Program.cs 兩個變成只有一個 Program.cs，更簡單了，更容易理解了。類似的 DX 改善 node.js 生態系的就跑得更前面了。只是直接受惠者只有 Programmer。</p><p>以前哪些體驗不好，或者不好入門的工具，像是 vi &#x2F; git，則是因為本質夠強大，就有人會主動去改善它的體驗。</p><hr><h2 id="三、體驗，使用者的體驗"><a href="#三、體驗，使用者的體驗" class="headerlink" title="三、體驗，使用者的體驗"></a>三、體驗，使用者的體驗</h2><p>前面定義的四大角色，以及針對體驗的描述都是內在的東西。也就是每個角色，自己在開發過程的體驗如何，都是角色自己的角度出發。</p><p>體驗是動詞。</p><p>真正的體驗是以客戶的角度，體驗自己的產品，以電商為例：</p><ol><li>應該要去驗自己的產品，像是走完一家店的流程、到後台過商品、從 End User 角度下單、然後客戶角度去後台完成訂單流程</li><li>給客戶前，應該去用自己開發的 API，吃自己的狗食</li></ol><p>怎麼落實這種體驗感？什麼時候開始？上 Production 體驗？我的答案是：</p><blockquote><p>Containzied 技術的出現，已經滿足這種體驗的需求。</p></blockquote><blockquote><p>在上 Production 之前，不管是怎樣的應用程式、怎樣的架構，都要可以在一台電腦裡 (Linux)、用 Container 跑起來，走完所有業務邏輯。</p></blockquote><p>從設計與規劃階段，就要想這件事情，以終為始。還沒出貨之前，就已經完全可以從客戶角度，體驗整個產品。”<a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a>“ 一文最後談到這整個想法與脈絡。</p><p>體驗會讓我們產生行動與認同感。除了薪水，這是凝聚員工向心力與認同感最實際的方法。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>寫這篇背後是因為：</p><ol><li>資訊發達的時代，太多單一觀點，在決定所有角色的方向，忽略個別角色的角度。</li><li>單一觀點寫出來的東西，在網路流傳，如果那個人又有點名氣，整個世界就是被帶風向</li><li>團隊有好的開發體驗的同時，也要同步提升自我的<a href="https://www.facebook.com/rick.kyhwang/posts/pfbid02oAjkjeVHVcUTyiSeJzB1FutD6me2rBveFMVz9tpeASrXcvQfcCMbqpMDT64A49fel">專業知識</a></li></ol><p>而我是少數經歷 經歷 Software Develpoer (國際外商)、SQA Manager &#x2F; SDET Lead (IoT 新創)、Operation &#x2F; Infrastructure Manager (電商新創)、Architect (電商新創) 等角色，而且每個角色都是全職的、經歷從零到一個過程，對於軟體開發體驗的觀點，有別於單一角色的觀點。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2017/07/01/Management/Developer-or-Engineer/">Developer vs. Engineer</a></li><li><a href="/2020/04/22/SoftwareEngineering/Reliability-Engineering/">可靠性工程 (Reliability Engineering)</a></li><li><a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li><a href="/2019/04/27/DevOps/Introduce-to-Continuous-Delivery-2/">導讀持續交付 2.0 - 談當代軟體交付之虛實融合</a></li><li><a href="/2022/08/13/SQA/Path-to-Software-Testing/">演講：從理想、到現實的距離，開啟品味軟體測試之路</a></li><li><a href="/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理對 Development Experience (DX) 的看法，原文草稿發表於 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid02oAjkjeVHVcUTyiSeJzB1FutD6me2rBveFMVz9tpeASrXcvQfcCMbqpMDT64A49fel&quot;&gt;Facebook&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="DevOps" scheme="https://rickhw.github.io/tags/DevOps/"/>
    
    <category term="Developer Experience" scheme="https://rickhw.github.io/tags/Developer-Experience/"/>
    
    <category term="Development Experience" scheme="https://rickhw.github.io/tags/Development-Experience/"/>
    
    <category term="DX" scheme="https://rickhw.github.io/tags/DX/"/>
    
  </entry>
  
  <entry>
    <title>問題的難與雜</title>
    <link href="https://rickhw.github.io/2022/09/10/About/Difficult-and-Complicate/"/>
    <id>https://rickhw.github.io/2022/09/10/About/Difficult-and-Complicate/</id>
    <published>2022-09-10T13:42:30.000Z</published>
    <updated>2022-12-19T11:47:28.851Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.facebook.com/rick.kyhwang/posts/pfbid0he6RNijEgMFY4pUcfWcUbJqRqZMmqw9pzHfCtw6gWQoG12b9YhZhZ2smMgJKEB7Jl">之前</a> 很常跟朋友分享這段想法，底下把想法記錄下來。</p><p>我把工作上遇到的問題分兩大類：</p><ol><li>雜 (Complicate)</li><li>難 (Defficult)</li></ol><span id="more"></span><h2 id="雜-Complicate"><a href="#雜-Complicate" class="headerlink" title="雜 (Complicate)"></a>雜 (Complicate)</h2><p>大部分的事一開始都是雜，大概有八七成都沒有章法、結構、組織。</p><p>雜的特性：</p><ol><li>沒有章法</li><li>沒有輕重</li><li>沒有邊界</li><li>沒有整理的資訊</li></ol><p>如果這種事需要快速決策、執行、驗收、上線，衍伸的現象就是亂、緊急、苦力、壓力，產生問題像債、負面情緒、導亂結構、破壞章法，最後是增加 <code>熵值</code>。</p><p>認識我久一點的人，會知道我是很龜毛的人，特別是一些章法、分類、組織 … 我看到亂的東西，就會想去<a href="https://rickhw.github.io/2014/10/26/Management/Classified-Philosophy/">整理、排序、類比、分類</a>。所以我自認為還滿擅長處理這種雜、亂的事情，只要一段時間之後，就會想用規則收斂，讓事情變成穩定狀態。只要雜的事經過這樣的程序 (有點像 ETL) 之後，大部分就可以變成規範。</p><p>所以在組織裡，用規範來約束不斷發散的亂 (或稱 <code>熵值</code> )，少量範圍這樣是有效的，可以有效的約束以及管控。但隨著時間的推演，實際上是不太可能做完的，因為規範是死的，人是活的，規範怎麼訂也訂不完，也無法完全落地，人則會來來去去、組織則會變來變去、業務方向會飛來飛去。</p><p>我也不可能、也沒時間跳下去全然協助，大多能給的是引導、啟發，讓大家發酵，或者是起孝。。。。XDD</p><p>雜事的特徵：</p><ul><li>發散，不知道邊界、需要理清全貌</li><li>會越做越亂、或莫名其妙就會變亂</li><li>做起來沒成就感</li><li>要整天賣笑 (我起笑比較多 XDD</li><li>慢了點就被幹樵</li><li>沒有歸屬感</li></ul><p>解法：</p><ol><li>divide and conquer (分而治之)</li><li>有核心規範、邊界的自組織 (中央政府、地方自治)</li></ol><!--#複雜 的層次圍不清楚、邊界模糊、關係紊亂、沒章法的執行、沒有層次的架構，這種複雜稱為 #亂  ...格局大、邊界清晰、依賴明確，有章法的專案管理，我稱為有組織、結構、架構性的 複雜 層次找出 #熵源 ... 讓他有章法、有原則的進行 .. 白話文：把樓歪回來--><h2 id="難-Defficult"><a href="#難-Defficult" class="headerlink" title="難 (Defficult)"></a>難 (Defficult)</h2><p>另外一種事，叫做難。</p><p>難的事分幾種:</p><ol><li><code>極致雜亂的難</code>: 當複雜到一定的極致, 我常會說: 這是 <code>n * m * q</code> 的問題 … 表達這是 <code>雜變亂、亂變難</code> …. 最後會變成棘手的問題 …. 要花十倍、甚至百倍以上的時間與資源，甚至根本就解不了。</li><li><code>工程的難</code>: 真正的難，需要有 <code>聰明才智</code> 才能解決的，像是想複雜的演算法.<ul><li>這種問題需要專家, 需要科學方法，需要科學家與工程師，也就是 <code>STEM</code> 領域專長的人才。</li></ul></li><li><code>棘手的難</code>: 通常是 1) + 2) + 人產生的問題，簡稱<code>政治</code>，需要智慧與手段。</li></ol><!--喜歡 = 熟悉 + 意外--><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇原文是我 <a href="https://rickhw.github.io/2014/10/26/Management/Classified-Philosophy/">2019&#x2F;10 交通時間</a> 敲下的想法，想表達生活中問題的普遍現象，工作上遇到大多的問題都是雜，少數是難。</p><p>而很多人覺得很難，通常有幾種：</p><ol><li>自身：能力不足、程度不夠</li><li>外在：管理問題，讓 <code>雜變亂、亂變難</code></li></ol><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://rickhw.github.io/2014/10/26/Management/Classified-Philosophy/">分類哲學</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/pfbid0he6RNijEgMFY4pUcfWcUbJqRqZMmqw9pzHfCtw6gWQoG12b9YhZhZ2smMgJKEB7Jl&quot;&gt;之前&lt;/a&gt; 很常跟朋友分享這段想法，底下把想法記錄下來。&lt;/p&gt;
&lt;p&gt;我把工作上遇到的問題分兩大類：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;雜 (Complicate)&lt;/li&gt;
&lt;li&gt;難 (Defficult)&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Bus Memo" scheme="https://rickhw.github.io/tags/Bus-Memo/"/>
    
  </entry>
  
  <entry>
    <title>聊聊寫 Blog 的想法</title>
    <link href="https://rickhw.github.io/2022/09/05/About/Blog-Practice/"/>
    <id>https://rickhw.github.io/2022/09/05/About/Blog-Practice/</id>
    <published>2022-09-05T14:39:00.000Z</published>
    <updated>2022-12-19T11:47:28.851Z</updated>
    
    <content type="html"><![CDATA[<p>每個人對於寫 Blog 這件事情，都有自己背後的動機，我的初衷跟寫程式一樣，透過不斷的重構精練，這個過程是我學到最多的。</p><span id="more"></span><h2 id="動機"><a href="#動機" class="headerlink" title="動機"></a>動機</h2><p>最近跟朋友聊到寫 Blog 這件事情，每個人寫 Blog 的動機不一樣，我自己一直以來都是這個原則：</p><blockquote><p>Blog 的主要讀者是自己，反覆讀自己的文章，有錯就改，直到沒啥好改為止</p></blockquote><p>跟很多人寫 Blog 不一樣的就是：</p><blockquote><p>同一篇文章會反覆修正，不斷調整文章整體結構 (ToC)，紀錄修正歷程</p></blockquote><p>會回去反覆更新、調整文章，持續精練文章內容這是我自己跟很多人不一樣的。</p><p>大部分的人寫 Blog 比較像流水帳，只是記錄一些步驟、或者資訊，流過去的就過去了。但是每天都可以出一篇，甚至好幾篇，然後自己可能不會再閱讀、再修改。</p><p>少數的人一開始就會有目標的規劃整體目錄，像是寫微服務架構設計這樣的系列主題，然後一篇一篇的攻克，每一篇都是很長、有完整的結構與大綱 (ToC)，但是可能是半年寫一篇。</p><hr><h2 id="我的寫作方法"><a href="#我的寫作方法" class="headerlink" title="我的寫作方法"></a>我的寫作方法</h2><h3 id="第一種：拼圖式"><a href="#第一種：拼圖式" class="headerlink" title="第一種：拼圖式"></a>第一種：拼圖式</h3><p>隨時把一些片段的想法留下來，漸漸的拼出貼出完整的。</p><p>這個作法是以前我在做音樂創作時留下的習慣，那時候常常為了留下靈感，身邊隨時會帶著錄音筆，然後隨時會把想到的靈感，不管是旋律、還是詞句，隨時錄下來。後來手機普及了，臉書流行了，這個習慣就換了個媒介。</p><p>每個片段的想法都是在瑣碎時間寫下的，通常是交通時間、一些等待的時間，在 FB 留下的想法。</p><p>片段想法累積數個之後，一段時間我就會開始重組這些東西，過程就是把寫得很散的東西，不斷的重新組織、安排段落、調整文章的 <code>Table of Context (ToC)</code>，補充不足的地方，最後集結成文。像是 <a href="/tags/Bus-Memo/">公車隨筆</a> 、<a href="/tags/Learning-Approaches/">寫作與閱讀系列文</a>、<a href="/tags/%E6%BA%9D%E9%80%9A/">溝通</a>、<a href="/tags/Meetings/">會議效率</a> … 等。</p><p>舉例 <code>學習、寫作、閱讀系列文章</code> 累積的比較多篇，如下：</p><ol><li><a href="/2019/01/20/About/Reading/">閱讀能力的重要性</a></li><li><a href="/2017/06/29/Management/Why-Document/">為什麼寫文件？</a></li><li><a href="/2019/04/03/Management/Write-Document/">再談『為什麼寫文件？』</a></li><li><a href="/2019/03/10/DevOps/Continuous-Delivery-Docs/">文件的持續交付</a></li><li><a href="/2020/05/09/Management/Problems-in-Documentation/">寫文件常見的問題</a></li><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2019/06/08/About/Spotlight-Phenomenon/">Spotlight 現象</a></li><li><a href="/2014/10/26/Management/Classified-Philosophy/">分類的哲學</a></li><li><a href="/2019/10/24/Management/Learning-From-Amazon/">從 Jeff Bezos 與 Werner Vogels 學到的</a></li></ol><h3 id="第二種：一口氣"><a href="#第二種：一口氣" class="headerlink" title="第二種：一口氣"></a>第二種：一口氣</h3><p>這種寫法大多有一個很明確的問題、動機，像是聽完某些人分享心得的共鳴、或者朋友提問，好問題就很想把想法留下來、跟朋友討論想法後的心得 … 等。這類型通常就是一口氣寫下完整的文章。</p><p>這類型的文章，在討論的過程，大部分我腦袋就會逐漸組成文章的 ToC 了，過程通常會留下關鍵字，如果身邊有電腦，則會順手敲下關鍵字，以利事後整理。如果是在線上用 IM 聊天，通常會告訴對方，我會記錄這段過程在 Blog 分享。</p><p>像是這篇 <a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a> 就是完全把在 Messager 的對話記錄下來的。現在這篇 <code>聊聊寫 Blog 的想法</code> 本身也是同樣的案例，<a href="https://www.facebook.com/completethink/posts/pfbid02WmQLU9gCZ5MyMSWu2aJuVhZyU782DQjc3oo5ici21us2Cb9j2fHAJKQvBuNMCv4Bl">初稿</a> 寫在部落格粉專上，後續持續整理與改善。</p><p>更多則是 <a href="/categories/DevOps/">DevOps &#x2F; SRE 相關文章</a> 裡面的每一篇，大多都是這樣背景下寫的東西。</p><h3 id="第三種：有計劃"><a href="#第三種：有計劃" class="headerlink" title="第三種：有計劃"></a>第三種：有計劃</h3><p>我比較少一次寫很長的文章，通常看到很長的文章，都是經過不斷修正、精煉、累積後整理出來的，像是這幾篇：</p><ol><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a></li><li><a href="/2016/04/07/AWS/Study-Notes-S3/">AWS S3</a></li></ol><p>可以看看文章右上角的 Table of Context，大概就可以知道這幾篇都有花不少時間調整的，舉例學習法則的 ToC：</p><p><img src="/images/About/ToC-2022.png"></p><p>整個結構是有先後續、有脈絡的在整理。</p><p>也有刻意為之的系列文，像是 <a href="/2018/08/20/Management/Overview-Hiring/">人力招募系列</a>、<a href="/2021/04/07/DistributedSystems/Dapr-Concepts-and-Designing/">Dapr 系列</a>、<a href="/2016/10/01/AWS-Study-Roadmap/">AWS</a> 很多都是。</p><h3 id="從點變成面：組織成系列文"><a href="#從點變成面：組織成系列文" class="headerlink" title="從點變成面：組織成系列文"></a>從點變成面：組織成系列文</h3><p>當同一個類型的文章寫了好幾篇之後，就可以 Grouping 成有系統、有組織的系列文，有些數量多到一定程度，會需要透過 mindmap 整理全貌，我這裡的例子就是 <a href="/2016/10/01/AWS-Study-Roadmap/">AWS 全系列</a> 整個文章，是過去幾年我花最多心思的。</p><p>另外也越來越多的 <a href="/categories/DevOps/">DevOps &#x2F; SRE</a>、 <a href="/2017/07/01/Index-Management/">經營管理</a>、<a href="/2017/07/01/Index-Software-Engineering-In-Practice/">軟體工程實踐</a>、<a href="/categories/Distributed-Systems/">分散式系統</a> 也是整個套系列，就差還沒畫成甘特圖。每一篇都是一個點，點跟點之間都可以連結起來，就像 <a href="https://twitter.com/hughcards/status/423952995240648704">Hugh MacLeod</a> 這張圖：</p><p><img src="/images/About/Learning-Approaches/Knowledge_Experience.png"></p><p>這個過程，會回去不斷調整每篇文章的 ToC，調整系列的目錄，從目錄就可以看出全貌，也就是知道自己還缺什麼。</p><h2 id="精煉"><a href="#精煉" class="headerlink" title="精煉"></a>精煉</h2><p><code>精煉</code> 是一個去蕪存菁的過程，以前在寫音樂部落格的時候，我真的精煉過不少東西，舉例來說：</p><ol><li><a href="https://rickmidi.blogspot.com/2008/08/minor-scale.html">小調音階 (Minor Scale)</a>、<a href="https://rickmidi.blogspot.com/2010/10/major-scale.html">大調音階 (Major Scale)</a>: 這兩篇大概是我精煉過深度最深的內容，文中提到的專有名詞、用詞、定義，都有花過很多時間查閱專門書籍，像是音樂系的教科書、論文、Wikipedia … 等，但是裡面也描述了我自己個人很深刻的體悟。</li><li><a href="https://rickmidi.blogspot.com/2010/04/chord-voicing.html">吉他的和弦聲位基本概念 (Chord Voicing)</a>、<a href="https://rickmidi.blogspot.com/2010/06/blog-post.html">升降記號</a>、<a href="https://rickmidi.blogspot.com/2010/03/canon-chord-progression.html">卡農進行 (Canon Chord Progression)</a>、 <a href="https://rickmidi.blogspot.com/2009/08/blog-post_16.html">吉他的基本功</a></li></ol><p>精煉就是要挑惕，挑惕每個用詞、每一句話，整體結構，深入了解每個名詞背後的意涵，深入體驗每一句話的感受。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這個 Blog 取名 <a href="/2017/12/29/About/About-This-Blog/">Complete Think</a>，我在文中描述到兩個字背後的意涵，其中 <code>Complete</code> 背後意味著：</p><blockquote><p>代表目標，持續往完整走。</p></blockquote><p>也就持續往完整的方向前進，寫 Blog 動機是記錄自己的想法，過程中不斷組織、重構他們，讓想法越來越具體、越來越系統的過程 … 而核心想法就是持續的、精煉想法，讓這些東西最後可以經的起時間的考驗。</p><p>最後用 <a href="https://www.youtube.com/watch?v=WUUjU4Om0KI">Steve Jobs 在 2005 在 Stanford 演講</a> 的名句：</p><blockquote><p>You can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future.</p><p>你無法預先把現在所發生的點點滴滴串聯起來，只有在未來回顧今日時，你才會明白這些點點滴滴是如何串在一起的。</p></blockquote><p>我把這句話改成這樣：</p><blockquote><p>每一篇文章都是一個點，只要回頭反覆閱讀、改善並連結他們，未來的今日，這些點點滴滴會串起不一樣的自己。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;每個人對於寫 Blog 這件事情，都有自己背後的動機，我的初衷跟寫程式一樣，透過不斷的重構精練，這個過程是我學到最多的。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Blog" scheme="https://rickhw.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>演講：從理想、到現實的距離，開啟品味軟體測試之路</title>
    <link href="https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/"/>
    <id>https://rickhw.github.io/2022/08/13/SQA/Path-to-Software-Testing/</id>
    <published>2022-08-13T05:33:00.000Z</published>
    <updated>2022-12-19T11:47:28.869Z</updated>
    
    <content type="html"><![CDATA[<p>今天很高興在 <a href="https://www.seat.org.tw/event/2022testing">台灣軟體工程協會</a>，成功大學 <a href="https://www.facebook.com/shinjielee">李信杰</a> 老師的邀請之下，讓我第一次分享關於軟體測試的想法與心得。</p><p>在投入 <code>軟體測試 (Software Testing)</code> 與 <code>軟體品質 (Software Quality Assurance, SQA)</code> 之前，我主要的工作角色是 <code>軟體開發</code> 為主，程式語言以 PHP &#x2F; Java &#x2F; Python、開發大型 Jave Enterprise Application 應用程式與 Eclipse Plugins 為主。過程中因為協助測試團隊改善 Application UI &#x2F; WebUI 測試，因而踩入測試領域。</p><p>因為本身是具備開發背景，踩入軟體測試有別於一般人經歷，因此開啟不一樣的路。實際軟體測試的經歷，包含 WebUI &#x2F; Desktop UI &#x2F; Unit Test &#x2F; E2E … 等自動化測試，設計與開發大型 “<a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Test Framework and Architect for Regression Test</a>“ 實務經驗。</p><p>這段經歷讓我對軟體測試的 <code>技術與工程面</code> 有很完整的歷鍊，所以後來也挑戰 在新創事業 (IoT 領域) 從零開始 <code>建立軟體測試團隊</code>，從團隊建立、制度、流程、工程、協作，建立完整的開發流程，其中領悟出最重要的 <a href="/2017/12/02/About/Epiphany/">心法</a> 就是 <code>品質</code> 的想法，因此寫下以下領悟：</p><blockquote><p>品質不只有測試，而是整個 (開發) 過程。<br>品質從需求開始，測試只是種手段<br>用品質建立數量，由數量產生速度。</p></blockquote><span id="more"></span><h2 id="簡報與錄影"><a href="#簡報與錄影" class="headerlink" title="簡報與錄影"></a>簡報與錄影</h2><iframe src="//www.slideshare.net/slideshow/embed_code/key/8WoBPlHEiHbCk1" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/rickhwang/the-path-in-software-testing" title="從理想、到現實的距離，開啟品味軟體測試之路 - 台灣軟體工程協會 (20220813)" target="_blank">從理想、到現實的距離，開啟品味軟體測試之路 - 台灣軟體工程協會 (20220813)</a> </strong> from <strong><a href="//www.slideshare.net/rickhwang" target="_blank">Rick Hwang</a></strong> </div><iframe width="560" height="315" src="https://www.youtube.com/embed/WAK-kMzi8wc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="現場問答"><a href="#現場問答" class="headerlink" title="現場問答"></a>現場問答</h2><p><img src="/images/SQA/Path-in-Software-Testing/Q01.png"></p><blockquote><p>答: 從了解產品角度切入，了解產品帶給使用者有什麼價值切入。加上 DevOps &#x2F; SRE 對於系統有了解，所以可以從整合測試切入。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q02.png"></p><blockquote><p>答：我覺得測試工作本質上就要敏捷，也就是主動跟協作對象 (PM &#x2F; Dev &#x2F; Ops) 建立溝通的循環。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q03.png"></p><blockquote><p>答：<a href="https://www.books.com.tw/products/0010623556">Google軟體測試之道：進行Google級的軟體測試</a>, <a href="https://www.books.com.tw/products/CN11052516">簡中</a></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q04.png"></p><blockquote><p>答：請參閱這篇 <a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？</a></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q05.png"></p><blockquote><p>答：請參閱這篇 <a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q06.png"></p><blockquote><p>答：如果已經有開發經驗，可以參考我的經歷，從幫忙測試團隊開始，協助改善自動化測試的流程，從過程中取得成就感，真的有興趣再轉。如果是針對 “自動化” 這個技能相關的職能就不只是 QA，DevOps &#x2F; SRE 也都是大量需要自動化的工作。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q07.png"></p><blockquote><p>答：JMeter、K6、ddosify、apache ab、stress-ng，請參閱這篇 “<a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？</a>“</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q08.png"></p><blockquote><p>答：</p><ul><li><ol><li>如果可以的話，在訪談過程中，讓 QA &#x2F; Dev 都參與討論，理解需求是需要時間的，所以可以建議一起參與。</li></ol></li><li><ol start="2"><li>敏捷開發 有很多框架，像是 Scrum &#x2F; 看板 &#x2F; LeSS … etc。其實 QA 要維持的原則沒有變：前期了解需求、針對需求提出想法與疑問、橫向跟 PM &#x2F; Dev 討論需求。這點其實跟用什麼開發方法沒啥關係。</li></ol></li><li><ol start="3"><li>不會寫程式比較吃虧的是對於非功能測試比較難切入，長期來看，對於培養產品靈敏度，可以延伸發展的方向則是 PM &#x2F; PO 的方向。如果會寫程式，發展方向則會更廣，像是 SDET &#x2F; SRE &#x2F; DevOps 甚至 Architect。</li></ol></li></ul></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q09.png"></p><blockquote><p>答：我在前期算是很幸運，有掌握整個開發流程的核心，前半年算順利。接下來就是團隊磨合期，像是 Dev &#x2F; QA 雙方對於問題看法的磨合，漸漸模出默契，大家都理解 Spec 很重要，從爭議 &#x2F; 爭論轉化成討論 &#x2F; 找到共識，過程大概有半年的長度。</p><p>後期 (約第三年的時候) 最大的 bottleneck 就是找到會寫 Code 的 QA，也就是 SDET，隨著產品功能越多，需要 Regression 的範圍就變大，所以有效的保護就重要了，但是實際上要追需要有適當的人到位才行，這時候人才就是關鍵了，不然只能自己跳下去賣肝 XD</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q10.png"></p><blockquote><p>答：看公司。不過建議至少要會 shell script、python，能夠寫簡單的自動化測試，像是自動取得 API 資訊，然後篩選資料，丟給下一個 script 處理 … 等。新人我以前面試一定會考三個： <a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">shell script</a> 觀念、Linux、SQL、HTML。例如用這些東西自動安裝 Wordpress、確認 Wordpress 安裝完成。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q11.png"></p><blockquote><p>答：不是很確定 <code>內聚性</code> 的意思是什麼，我猜應該是指軟體設計的 <code>高內聚、低耦合</code> 的概念。這在軟體設計階段就需要分析清楚的，通常在 System Design 就會確立每個系統元件的邊界與依賴關係，用程式碼來說就是 OOP 裡，怎樣定義一個 Class，定義好之後，就可以做單元測試。Class 可以做單元測試代表具備一定的內聚力，以及低耦合。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q12.png"></p><blockquote><p>答：<code>大型重構</code> 我猜你的意思是背後的主要結構已經改變，像是 DB Schema 做 Breaking Change、架構做了很大的改變之類的。依照不同層次改動的比例，三者都要有對應的調整。但如果是架構改變，那問題可能就不是測試三角形可以處理的層次，通常要搞定的是 Migration 策略。因為如果是已經在線上跑的服務，需要安排分階段執行以及 Rollback 計畫。可能不是測試團隊可以單純搞定的。</p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q13.png"></p><blockquote><p>答：大家對於需求或規格認知不一樣的時候，就會討論這個 Bug or Feature？像這張圖一樣：<br><img src="/images/SQA/Path-in-Software-Testing/Q13-Dev-Tester.JPG"></p></blockquote><p><img src="/images/SQA/Path-in-Software-Testing/Q14.png"></p><blockquote><p>答：所有角色。</p></blockquote><h2 id="摘錄簡報重點"><a href="#摘錄簡報重點" class="headerlink" title="摘錄簡報重點"></a>摘錄簡報重點</h2><p><img src="/images/SQA/Path-in-Software-Testing/Strategies-for-Test-Praymid.png"><br><img src="/images/SQA/Path-in-Software-Testing/Strategies-for-Test-Praymid-And-Company-Phase.png"><br><img src="/images/SQA/Path-in-Software-Testing/Strategies-for-Functional-NonFunctional.png"><br><img src="/images/SQA/Path-in-Software-Testing/Functional-and-NonFunctional.png"><br><img src="/images/SQA/Path-in-Software-Testing/About-Quality-by-Rick.png"></p><h2 id="感謝"><a href="#感謝" class="headerlink" title="感謝"></a>感謝</h2><p>兩週前，跟李老師在討論事情，突然說想邀請我分享軟體測試的一些心得。本來想說只有兩週，應該會爆肝，但問了一下 TA 是在學同學，突然一種使命感油然而生，然後就答應了 XDD …. (肝表示 ….)</p><p>雖然 Blog 已經有很多素材可以用，不過還是花了一點時間針對在學同學設計內容。每次演講，我都希望帶給聽眾的，不是怎麼去用什麼工具、步驟是什麼，而是聽完之後，能夠有所啟發，這個啟發是過了幾年之後，都依舊受用，這些觀念也是我在 “<a href="/2017/11/26/Thinking-in-Essence/">思考本質、實踐、抽象、想像力</a>“、”<a href="/2017/09/20/About/Learning-Approaches/">學習法則</a>“ 反覆提及的。</p><p>這場分享主要 TA 是在學同學與社會新鮮人，構思的時候我就在想：</p><blockquote><p>如果我現在可以回到廿年前，那我想要告訴那時候的我，怎麼做選擇。</p></blockquote><p>所以演講的構思以 “<a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a>“ 為主軸，測試金字塔主要藍圖、”<a href="/2018/03/18/SQA/Gossip-System-Testing/">系統測試的三兩事</a>“ 提到的 <code>功能與非功能</code> 為輔助，引導新鮮人啟發探索職涯的可能性。</p><p>這次也認識了另外一位講者：<a href="https://www.facebook.com/loverjersey">Jersey Su</a>，精湛的摘要測試左移的一些脈絡，也告訴同學如何透過探索與刻意練習提升自己，這些想法都讓我非常有感，未來有機會再繼續分享心得～</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li>軟體測試相關：<ul><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li><li><a href="/2014/05/09/SQA/Problems_In-Software-Autotest/">軟體自動化測試常見的問題</a></li><li><a href="/2017/12/03/SQA/Regression-Test-Is-Tough/">從 iOS 無限黑屏事件，談軟體測試階段 - 回歸測試 Regression Test</a></li><li><a href="/2018/03/18/SQA/How-To-Report-A-Defect-or-Bug/">如何有效的回報問題</a></li><li><a href="/2018/03/18/SQA/Gossip-System-Testing/">輕鬆聊：系統測試 (SVT) 的三兩事</a></li><li><a href="/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></li><li><a href="/2019/09/20/SQA/How-to-Measure-System-Capacity/">如何量測系統的容量？（壓測）</a></li><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li></ul></li><li>軟體開發<ul><li><a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li><a href="/2017/09/03/Management/Phases-in-Startup/">不同階段的企業</a></li></ul></li><li>成長<ul><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li><li><a href="/2017/11/26/Thinking-in-Essence/">思考本質、實踐、抽象、想像力</a></li></ul></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://martinfowler.com/articles/practical-test-pyramid.html">The Practical Test Pyramid</a> - martinfowler.com</li><li><a href="https://www.gushiciku.cn/pl/2FYW/zh-tw">什麼是測試左移（Shift-Left testing）？</a></li><li><a href="https://www.businessweekly.com.tw/management/blog/26187">飛輪效應》如何花更少力氣，推動公司更高速運轉</a> - 商周</li><li><a href="https://www.hexschool.com/2022/06/23/2022-06-23-software-engineer-salary/">軟體工程師薪水</a> - 六角學院</li><li><a href="https://zh.wikipedia.org/zh-tw/PDCA">PDCA</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天很高興在 &lt;a href=&quot;https://www.seat.org.tw/event/2022testing&quot;&gt;台灣軟體工程協會&lt;/a&gt;，成功大學 &lt;a href=&quot;https://www.facebook.com/shinjielee&quot;&gt;李信杰&lt;/a&gt; 老師的邀請之下，讓我第一次分享關於軟體測試的想法與心得。&lt;/p&gt;
&lt;p&gt;在投入 &lt;code&gt;軟體測試 (Software Testing)&lt;/code&gt; 與 &lt;code&gt;軟體品質 (Software Quality Assurance, SQA)&lt;/code&gt; 之前，我主要的工作角色是 &lt;code&gt;軟體開發&lt;/code&gt; 為主，程式語言以 PHP &amp;#x2F; Java &amp;#x2F; Python、開發大型 Jave Enterprise Application 應用程式與 Eclipse Plugins 為主。過程中因為協助測試團隊改善 Application UI &amp;#x2F; WebUI 測試，因而踩入測試領域。&lt;/p&gt;
&lt;p&gt;因為本身是具備開發背景，踩入軟體測試有別於一般人經歷，因此開啟不一樣的路。實際軟體測試的經歷，包含 WebUI &amp;#x2F; Desktop UI &amp;#x2F; Unit Test &amp;#x2F; E2E … 等自動化測試，設計與開發大型 “&lt;a href=&quot;/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/&quot;&gt;Test Framework and Architect for Regression Test&lt;/a&gt;“ 實務經驗。&lt;/p&gt;
&lt;p&gt;這段經歷讓我對軟體測試的 &lt;code&gt;技術與工程面&lt;/code&gt; 有很完整的歷鍊，所以後來也挑戰 在新創事業 (IoT 領域) 從零開始 &lt;code&gt;建立軟體測試團隊&lt;/code&gt;，從團隊建立、制度、流程、工程、協作，建立完整的開發流程，其中領悟出最重要的 &lt;a href=&quot;/2017/12/02/About/Epiphany/&quot;&gt;心法&lt;/a&gt; 就是 &lt;code&gt;品質&lt;/code&gt; 的想法，因此寫下以下領悟：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;品質不只有測試，而是整個 (開發) 過程。&lt;br&gt;品質從需求開始，測試只是種手段&lt;br&gt;用品質建立數量，由數量產生速度。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="軟體測試" scheme="https://rickhw.github.io/categories/%E8%BB%9F%E9%AB%94%E6%B8%AC%E8%A9%A6/"/>
    
    
    <category term="SDLC" scheme="https://rickhw.github.io/tags/SDLC/"/>
    
    <category term="Software Test" scheme="https://rickhw.github.io/tags/Software-Test/"/>
    
    <category term="SQA" scheme="https://rickhw.github.io/tags/SQA/"/>
    
    <category term="SVT" scheme="https://rickhw.github.io/tags/SVT/"/>
    
  </entry>
  
  <entry>
    <title>Happy Path and Unit Test</title>
    <link href="https://rickhw.github.io/2022/07/30/SoftwareEngineering/HappyPath-and-UnitTest/"/>
    <id>https://rickhw.github.io/2022/07/30/SoftwareEngineering/HappyPath-and-UnitTest/</id>
    <published>2022-07-30T01:50:30.000Z</published>
    <updated>2022-12-19T11:47:28.870Z</updated>
    
    <content type="html"><![CDATA[<p><code>測試金字塔</code> 是很多書、很多演講都會提的概念，從上到下是 E2E、Integration、Unit Test，佔比也是這個次序。</p><p><img src="/images/SQA/The_Test_Pyramid.png"></p><p>很多大神、知名的軟體教練、傳教士、訪間的訓練機構也都一再強調 Unit Test (以下簡稱 UT) 的重要，經過幾年的宣導與討論，基本上，現在很多軟體工程師都自己會先做 Unit Test，或者在跑 Scrum 時都有出現 Task 內容是要做 Unit Test。對於整個軟體產業而言，是個很好的現象。</p><p>這年代跑 Scrum 也越來越普遍，大家也有意識到一個 Scrum Team 就是在做一個產品，大概就像 <code>天龍特攻隊</code> (A Team) 、或者是阿湯哥 <code>不可能任務</code>、或者一個 <code>搖滾樂團</code> ，都是 Team Work，理論上，要交付的是一個共同的價值。</p><span id="more"></span><h2 id="Unit-Test-不重要？"><a href="#Unit-Test-不重要？" class="headerlink" title="Unit Test 不重要？"></a>Unit Test 不重要？</h2><p>最近我在工作時，反覆的跟同仁講一段事情：</p><blockquote><p>我同意 Unit Test 很重要，<br>但是如果東西交到使用者手上的 Happy Path 不能跑，<br>那做了這麼多 Unit Test 就很可惜。</p></blockquote><p>講的過程，我盡量把用詞修飾的比較不會有太大衝擊，因為普遍工程師已經接受傳教士的說法，避免誤解成：</p><blockquote><ul><li>Rick 說我的 UT 都在做白工 QQ…</li><li>是 Rick 叫我不要寫 UT 啊</li></ul></blockquote><p>而我講的重點就在於 <code>次序</code>、<code>循環</code>：</p><blockquote><ol><li>Happy Path 要 <code>先</code> 能動</li><li><code>然後</code>，把 Unit Test 補齊</li></ol></blockquote><p>如果先把 UT 做到 100% 涵蓋率，但是 Happy Path 一個都不能跑，這表示什麼？這個產品不能用，而且死線就在哪裡。</p><p>但如果一開始先讓 Happy Path 能跑，跑法可能很髒、很醜、很蠢 … 都沒關係，過程中持續補齊 UT、然後持續修補 Happy Path 的跑法。最後 UT 不管有沒補完，Happy Path 依舊可用的，次序與循環都有了。</p><h2 id="案例一：非功能性的-Happy-Path"><a href="#案例一：非功能性的-Happy-Path" class="headerlink" title="案例一：非功能性的 Happy Path"></a>案例一：非功能性的 Happy Path</h2><p>第一個案例是一個專案在即將上線的一前一週，早上站立時，同仁反映應用程式放到 K8s 跑不起來，問題可能是一些 lib 依賴衝突造成的，但是本機跑不會有這樣的問題。</p><p>經過一些討論與嘗試，幾天後問題找到暫解法。姑且不論技術問題，算是暫時把部署到 K8s 的狀況解除。說明過程，我刻意把技術問題淡化，而強調 <code>發現的難度</code> 與 <code>發現的時間點</code>。</p><p>後來我跟同仁說我對這件事情的看法：</p><ol><li>這個技術問題 (依賴 Lib) 本身問題不大，只要給你們時間，很快就能解決</li><li>這個問題如果可以早一點發現會比較好，因為不難發現</li></ol><p>我帶出一個觀念，是我自己想的一段口號：</p><blockquote><p>Deliver Hello World in First Day</p></blockquote><p>在這篇文章 “<a href="https://rickhw.github.io/2022/04/06/SoftwareEngineering/Artifact-Management-and-Version-Control/">Version Control 與 Artifact Management</a>“ 有提到這個觀念。</p><h2 id="案例二：功能性的-Happy-Path"><a href="#案例二：功能性的-Happy-Path" class="headerlink" title="案例二：功能性的 Happy Path"></a>案例二：功能性的 Happy Path</h2><p>延續案例一，好不容易推上 K8s 了，登入系統後，發現功能全部都不能動 … 又是一個同樣的案例：</p><blockquote><p>我的電腦可以跑、你的電腦不能動</p></blockquote><p>這次是 <code>功能性 (Functional)</code> 的，案例一則是 <code>非功能性 (Non-Functinal)</code> 的，然後明天就要上線了。</p><p>背後技術問題是：使用新的前端技術，無法正確讀取 config。同樣的，大家又一起討論，找了一些 Workaround，先把問題處理掉。</p><p>同樣的延續案例一，跟大家分享了我的看法：</p><ol><li>這個技術問題 (前端取得 config) 本身問題不大，只要給你們時間，很快就能解決</li><li>這個問題如果可以早一點發現會比較好，因為不難發現</li></ol><p>(copy and paste … XD)</p><h2 id="案例三：示範給大家看"><a href="#案例三：示範給大家看" class="headerlink" title="案例三：示範給大家看"></a>案例三：示範給大家看</h2><p>案例一、二發生後，我跟大家分享我對整件事情的看法，過程中其實我心裡有點掙扎的事，要不要說這些話。後來我還是覺得應該要講，而且是對全 Team (about 20)</p><p>我說完這段想法之後，不要光說不練，所以親自下去做了幾件事情，我挑了手上六條線的專案中的一項，快速確認 Happy Path 能跑、怎麼跑、有哪些東西缺乏的，不用三十分鐘，開出四、五張 defects</p><p>這些問題差不多：</p><ol><li>你的電腦可以跑，我的電腦不能跑</li><li>最基本的 Path 跑不起來</li></ol><p>(這次就不 c &amp; p 了)</p><h2 id="定義-Happy-Paths-與交付"><a href="#定義-Happy-Paths-與交付" class="headerlink" title="定義 Happy Paths 與交付"></a>定義 Happy Paths 與交付</h2><p>我個人定義的 Happy Path 有幾個 <code>必要的限制</code>，或者說 <code>條件</code>：</p><h3 id="1-一定是透過-Artifact-跑起來"><a href="#1-一定是透過-Artifact-跑起來" class="headerlink" title="1) 一定是透過 Artifact 跑起來"></a>1) 一定是透過 Artifact 跑起來</h3><ol><li>避免你的電腦可以跑、我的電腦不能跑</li><li>Build Process 是正常的</li><li>CI 這段要先做到，後面的程序才有意義。</li></ol><p>這段是我定義的 <code>交付</code> ，不是虛的那種價值交付，而是實體軟體檔案的交付。任何軟體開發、軟體工程，最後都需要把東西叫給下一棒，不管是內部的工程師、還是外部客戶、還是後面的自動化程序。Artifact 就是標準的交付介面。有了這段，才有後使用上的價值可言。</p><h3 id="2-Happy-Path-一定是-黑箱測試，先驗證應用程式的-內聚力"><a href="#2-Happy-Path-一定是-黑箱測試，先驗證應用程式的-內聚力" class="headerlink" title="2) Happy Path 一定是 黑箱測試，先驗證應用程式的 內聚力"></a>2) Happy Path 一定是 <code>黑箱測試</code>，先驗證應用程式的 <code>內聚力</code></h3><ol><li>假設 App 功能還沒好了，重點在於驗證 功能正確性，強調的是 App 的 <code>內聚力</code>。<ul><li>熟悉 UT 的人應該可以感覺到這段話的核心思想，與 UT 是一樣的。</li></ul></li><li>這個階段 <code>不處理</code> 外在環境因素 (非功能)，像是放到 K8s or Cloud &#x2F; DB HA &#x2F; 網路架構 &#x2F; Cache … etc.<ul><li>只要有個標準就好，像是透過 docker 跑起來、或者 binary 跑起來即可。</li></ul></li></ol><blockquote><p><code>測試策略</code> 的 <code>內聚力與耦合性</code> 概念，參閱 <a href="https://rickhw.github.io/2018/03/18/SQA/Gossip-System-Testing/">系統測試的三兩事</a> 介紹。</p></blockquote><h3 id="3-Happy-Path-是-UAT-的其中一環"><a href="#3-Happy-Path-是-UAT-的其中一環" class="headerlink" title="3. Happy Path 是 UAT 的其中一環"></a>3. Happy Path 是 UAT 的其中一環</h3><ol><li>UAT 的目的是出貨前要做的驗證，包含 Happy Paths 與 Regression 的項目</li><li>Happy Path 包含功能與非功能的部分，非功能的就是 Artifact、功能性的就像登入、註冊 … 這些基本功能</li></ol><h2 id="測試金字塔-該怎麼落實？"><a href="#測試金字塔-該怎麼落實？" class="headerlink" title="測試金字塔 該怎麼落實？"></a>測試金字塔 該怎麼落實？</h2><p>回到一開始的金字塔，問題要改成：</p><blockquote><p>怎麼落實、怎麼執行測試金字塔的概念</p></blockquote><p>做軟體開發的公司千百家，但是可以稱得上是 軟體公司 的，可能為數不多，大多都是專案驅動 (死線驅動 DDD)，產品驅動較少，重視軟體工程就更少了。</p><p>我自己待過很大的國際級軟體公司，走過理想的金字塔；也待過從無到有的新創公司，面對過實際的狀況， (故事放在 <a href="https://rickhw.github.io/2019/10/30/SQA/Problems-In-Software-Testing/">這篇文章</a> 的最後一段)，但是這兩種公司在軟體開發最後都有一樣要面對問題：</p><blockquote><ul><li>內部怎麼認定這東西是好了？</li><li>怎麼把東西交到客戶手上？</li><li>客戶怎麼用這個東西？</li><li>產品對客戶真的能夠提供價值？</li></ul></blockquote><p>能動了，利用 Unit Test 有效的保護各個 function &#x2F; module 的邊界，反覆修正 Happy Paths 的執行效能，有了這樣的循環，金字塔自然會成行。</p><p>而這個概念，根 UT 一開始的概念不是一樣？先不寫功能，先寫測試，然後把每次跑測試的錯誤，一一修復，最後修完，也代表功能寫好了。只是 UT 處理的是顆粒度較小的 function，而 Happy Path 處理的是整個 Application。</p><p>所以我認為落實金字塔的方法就是：</p><blockquote><p>建立 UT 與 Happy Path 的循環，<br>驅動這個循環的則是 Happy Path。</p></blockquote><p>起點是 Happy Path，過程則透過 UT 補強。對應到 金字塔，Happy Path 是 E2E 和 Integration Test。</p><p>註： <code>整合測試</code> 的概念請參閱 “<a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a>“ 的摘要</p><h2 id="測試金字塔是萬用的？"><a href="#測試金字塔是萬用的？" class="headerlink" title="測試金字塔是萬用的？"></a>測試金字塔是萬用的？</h2><p>其實實際的問題是這個：</p><blockquote><ul><li>這個金字塔式萬用的嗎？比例是這樣嗎？UT &gt; Integration &gt; E2E？？</li><li>每個 <code>產品</code> 都可以用這個概念套嗎？做 IoT、做電商、做 API Product 、做網通產品、基礎架構產品 需要的層次不一</li><li>產品在不同階段 (Prototype, Early Stage, 驗證階段, 成長期, 成熟階段) 需要的 <code>策略</code> 不一樣。</li></ul></blockquote><p>這是很弔詭的問題，這個問題大家要放在心裡，別掉進：<code>手上打著錘子，看到啥都是釘子</code> 的圈套。</p><!--## 搞定事情的條件：能力、意願、時間處理案例一、二、三的條件有三個：1. 能力:    * 能、不能    * 熟悉、不熟悉2. 意願    * 喜歡、不喜歡    * 想要、不想要3. 時間    * 有時間，才有 “左移” → “預防”    * 沒時間：壓力、加班、上靠北工程師發文 (有時間發廢文？壓力的程度：![](/images/SoftwareEngineering/HappyPath/comfortable-in-time.png)當時間充裕的時候：![](/images/SoftwareEngineering/HappyPath/incomfortable-in-time.png)當時間不足的時候：發現的難度、發現的時間--><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://rickhw.github.io/2019/10/30/SQA/Problems-In-Software-Testing/">關於軟體測試，一些觀察到的現象</a></li><li><a href="https://rickhw.github.io/2018/03/18/SQA/Gossip-System-Testing/">系統測試的三兩事</a></li><li><a href="https://rickhw.github.io/2017/03/18/SQA/Stages-In-Software-Testing/">淺談軟體測試的階段與策略</a></li><li><a href="https://rickhw.github.io/2022/04/06/SoftwareEngineering/Artifact-Management-and-Version-Control/">Version Control 與 Artifact Management</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;測試金字塔&lt;/code&gt; 是很多書、很多演講都會提的概念，從上到下是 E2E、Integration、Unit Test，佔比也是這個次序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SQA/The_Test_Pyramid.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;很多大神、知名的軟體教練、傳教士、訪間的訓練機構也都一再強調 Unit Test (以下簡稱 UT) 的重要，經過幾年的宣導與討論，基本上，現在很多軟體工程師都自己會先做 Unit Test，或者在跑 Scrum 時都有出現 Task 內容是要做 Unit Test。對於整個軟體產業而言，是個很好的現象。&lt;/p&gt;
&lt;p&gt;這年代跑 Scrum 也越來越普遍，大家也有意識到一個 Scrum Team 就是在做一個產品，大概就像 &lt;code&gt;天龍特攻隊&lt;/code&gt; (A Team) 、或者是阿湯哥 &lt;code&gt;不可能任務&lt;/code&gt;、或者一個 &lt;code&gt;搖滾樂團&lt;/code&gt; ，都是 Team Work，理論上，要交付的是一個共同的價值。&lt;/p&gt;</summary>
    
    
    
    <category term="Software Engineering" scheme="https://rickhw.github.io/categories/Software-Engineering/"/>
    
    
    <category term="Unit Test" scheme="https://rickhw.github.io/tags/Unit-Test/"/>
    
    <category term="Artifact" scheme="https://rickhw.github.io/tags/Artifact/"/>
    
    <category term="Happy Paths" scheme="https://rickhw.github.io/tags/Happy-Paths/"/>
    
  </entry>
  
  <entry>
    <title>摘要 Eclipse 設計的啟發：當代 SaaS 分散式架構的關鍵設計</title>
    <link href="https://rickhw.github.io/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/"/>
    <id>https://rickhw.github.io/2022/07/04/DistributedSystems/Inspired-Design-From-Eclipse/</id>
    <published>2022-07-04T10:21:00.000Z</published>
    <updated>2022-12-19T11:47:28.860Z</updated>
    
    <content type="html"><![CDATA[<p>整理關於 SaaS 架構設計的想法，部分是來自於 Eclipse 這個著名 Java IED 的設計概念。</p><p>大約從 2018 之後，VSCode 可以算是統一 Open Source 的 IDE 了，之前由 GitHub 開發的 Atom 在微軟收購了 GitHub 之後，已經將在 December 15, 2022 落下了句點，其他 Editors (還不到 IDE) 大多還是屬於輔助性質，像是 Notepad++ 。</p><p>而 VSCode 主要的設計者 <a href="https://en.wikipedia.org/wiki/Erich_Gamma">Erich Gamma</a> 則是著名的 Design Pattern 的共同作者之一 (又稱 GoF)，而這個理論背後源自於他的實作，也是著名的 Java IDE - <a href="https://en.wikipedia.org/wiki/Eclipse_(software)">Eclipse</a>，Erich Gamma 負責最核心的 JDT (Java development Tooling) 的設計。</p><p><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">2004 - 2012 年期間，我在 IBM 駐點開發 Rational 相關產品</a>，其中主要就是 Eclipse Plugins 的開發，產品是給 Web Developer 用的工具，可以說就是在寫 IDE 的概念。過程曾經鑽研了 Eclipse Plugins、RCP (Rich Client Platform, XMind &#x2F; DBeaver 就是這個開發的) &#x2F; Equinox OSGi &#x2F; SWT &#x2F; JFace &#x2F; EMF &#x2F; GEF … 等設計概念，也因此對於 Eclipse 整個架構略有研究，而這些設計概念也不知不覺的用在之後工作上。</p><p>這些年的更迭與代換，我自己的工作環境 <a href="/2013/11/17/OSX/Install-OSX-Mavericks-on-PC/">從 Windows 換到 macOS</a>，開發工具從 Eclipse 換到了 Atom，然後又跳到 VSCode。在使用 VS Code 的過程，處處都聞到 Eclipse 的設計感。開始做分散式架構設計、重讀作業系統、學習 CS 基礎知識、探索 AWS &#x2F; K8s … 等過程，發現這些背後的本質都有高度的雷同。</p><span id="more"></span><hr><h1 id="Eclipse-設計摘要"><a href="#Eclipse-設計摘要" class="headerlink" title="Eclipse 設計摘要"></a>Eclipse 設計摘要</h1><h2 id="SDK-x2F-Platform"><a href="#SDK-x2F-Platform" class="headerlink" title="SDK &#x2F; Platform"></a>SDK &#x2F; Platform</h2><p>下圖是 Eclipse Platform 的架構圖：</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/Platform-Architecture.png"><br>圖檔出處：<a href="https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/class-use/IViewPart.html">Platform architecture</a></p><p>Eclipse SDK 由一組完整的 Platform 元件組成，包含 <a href="https://docs.osgi.org/specification/osgi.core/7.0.0/">Platform Runtime (OSGi)</a>、Workspace、UI 元件 (SWT &#x2F; Workbench &#x2F; JFace)、文件 (Help)、協作 (Team) … 組成。基於這些基元延展的兩個重要應用則是 <code>JDT (Java Development Tooling)</code> 和 <code>PDE (Plug-in Developer Environment)</code>。JDT 是給 Java 開發者用的整合開發環境，後者則是為了讓 Eclipse 具備延伸能力的開發環境。</p><h2 id="Runtime-OSGi"><a href="#Runtime-OSGi" class="headerlink" title="Runtime: OSGi"></a>Runtime: OSGi</h2><p>Eclipse Platform 使用 <a href="https://docs.osgi.org/specification/osgi.core/7.0.0/">OSGi (Open Service Gateway Initiative)</a> 作為主要的 Runtime 標準。OSGi 是一個標準協議組織 (OSGi Alliance)，也是一個標準服務平台 (Service Platform)。規範定義了應用程式生命週期與服務註冊、框架通訊、擴充機制 … 等等，如下圖所示。</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/OSGi-Layering.png"><br>圖檔出處：<a href="https://docs.osgi.org/specification/osgi.core/7.0.0/ch01.html#d0e76">OSGi Framework Overview</a></p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/OSGi-Interaction-between-layers.png"><br>圖檔出處：<a href="https://docs.osgi.org/specification/osgi.core/7.0.0/ch01.html#d0e76">OSGi Framework Overview</a></p><h2 id="Concurrency-Infrastructure"><a href="#Concurrency-Infrastructure" class="headerlink" title="Concurrency Infrastructure"></a>Concurrency Infrastructure</h2><p>整個 Eclipse Platform 同時有很多東西在前景跑 (Frontend)，不管是 Views 還是 Editor，而這些前景的物件會相互傳遞訊息，傳遞的訊息需要被處理，這個處理背後的機制就是 Eclipse 提供的 <a href="https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/runtime_jobs.htm&cp=2_0_3_5">Concurrency Infrastructure</a>，用現代分散式架構來看就是個 Pub&#x2F;Sub 架構概念。</p><p>整個架構背後透過 Jobs、IStatus、IJobManager、IJobChangeListener、IJobChangeEvent、IProgressMonitor … 等介面組成。</p><h2 id="Extension-Point"><a href="#Extension-Point" class="headerlink" title="Extension Point"></a>Extension Point</h2><p>如圖中描述的概念，其中的 PDE 為了讓開發者可以依照 Platform 開發延伸應用程式，Platform 本身要提供一些介面做接點，這個界面稱為 <code>Extension Point</code>，而接入 Eclipse Platform 的動作稱為 <code>Registry</code>。從使用介面 (UI) 來看，有幾個主要的組成概念。</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/Workbench.png"><br>圖檔出處：<a href="https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/class-use/IViewPart.html">Plugging into the workbench</a></p><h3 id="Workbench-Window-x2F-Page"><a href="#Workbench-Window-x2F-Page" class="headerlink" title="Workbench Window &#x2F; Page"></a>Workbench Window &#x2F; Page</h3><p>最上層容器，裡面包涵視窗的 MenuBar &#x2F; ToolBar、多個 Page，每個 Page 裡可以有一個 Editor Window + 多個 Viewer Window。Page 則是第二層的容器，主要是提供不同的 Perspective 用途。</p><h3 id="Editor-and-View"><a href="#Editor-and-View" class="headerlink" title="Editor and View"></a>Editor and View</h3><p>Editor 是使用者輸入的主要 Window，通常是預設的 Focus 地方，使用者會在這裡做主要的輸入。實作上透過 Eclipse Platform 提供的 JFace 以及 EMF (Eclipse Modeling Framework) 處理，讓開發者可以自行開發符合各種語言特性需要的 Editor。</p><p>而 View 則是用來輔助呈現資訊的視窗，預設是檔案結構，在 Eclipse 裡稱為 Navigator View</p><ul><li>Viewer 有多種呈現形式，舉例幾種：<ul><li>Java Package View：基於 Navigator View ，但是以 Java Package 習慣的呈現方式。</li><li>Outline View: 根據 Editor 內容，反映出結構，像是 Java 的 Properties、Methods</li><li>Properties View: 用 Grid 方式呈現 Key &#x2F; Value 的資料結構</li></ul></li><li>Viewer 有個基礎抽象類別 (稱做 <a href="https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.platform.doc.isv/reference/api/org/eclipse/ui/class-use/IViewPart.html">ViewPart</a>)，並且提供事件驅動介面，讓 Viewer 與 Editor 之間可以以主動、被動的方式連動訊息。<ul><li>實務上會用基礎類別實作不一樣的 Viewer，像是 Console、Debug 的 Runtime Variables。</li></ul></li></ul><p>預設的 Eclipse 有很多 View，如下圖看到的 Category 有 Git &#x2F; Gradle &#x2F; Help &#x2F; Java … 等。</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/More-View.png"></p><p>下圖則是 JDT 提供的 Debug 常見的幾個 Views：</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/View-Debug.png"></p><p>預設的 <code>Navigator View</code>，其實就是檔案管理器，把實體檔案的結構具體地呈現出來，如下圖：</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/View-Navigator.png"></p><p><code>Project Explorer</code> 是 Java 的 Viewer，會把 Package 的結構攤平，讓 Java 開發者更容易理解。</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/View-Project-Explorer.png"></p><p>以此為概念，可以開發給不同 語言 (C#, Python) 或者 SQL … etc … 專用的 Viewers。</p><h3 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h3><p>中文翻譯成 <code>視角</code>、<code>觀點</code>，是在 Workbeanch 裡的數個 Views + Editor 與 Layout (BorderLayout) 組成的設定。每個開發者，在不同開發階段，或者做不同任務時會有不同的角度需要。透過 Perspective 就可以把該階段的畫面設定儲存下來，也可以分享設定給其他開發者。</p><p>下圖是 Eclipse 預設提供的幾種 Perspective：</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/Default-Perspective-List.png"></p><p>下圖的則是預設的 Java Perspective，可以看到上面四個 View、從左到右由大到小分別是 Project -&gt; Packages -&gt; Type -&gt; Members，下面則是把偌大的空間留給 Editor。這是很多 Java Developer 最常用的了。</p><p>我有很長一段時間再分析一個龐大的 Code Structure，那個過程很常需要了解整個 Class 的繼承關係、抽象介面的實作、Java Projects 的依賴關係、Plugins 的依賴關係 … 等，這配置很常用。只要切到這個 View 就是要分析程式用的。</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/Perspective-Java-Browsing.png"></p><p>下面這個叫做 <code>Rick&#39;s Perspective</code> 則是我自己以前在寫程式時最常用的 Layout。</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/Ricks-Perspective.png"></p><ul><li>左上除了 Project Explorer，還有 Type Hierarchy，分析程式碼結構用。</li><li>左下方式 Debug 需要的 Expressions 與 Breakpoints &#x2F; Runtime Variables</li><li>右上角則是現在 Content 的 Outline</li><li>下方 (South) 的上方區域，放的則是 Runtime 的控制 View，像是 Servers (Tomcat)、Debug (StepIn&#x2F;Out&#x2F;Over) 等 …</li><li>最下方區域，則是 Console</li></ul><p>這樣的配置其實是很個人習慣的，當年就靠這個配置寫了不少東西。</p><!--## Eclipse Marketplace![](/images/Coding/Inspired-Design-From-Eclipse/Eclipse-Marketplace.png)---# VSCode Extension 的設計簡單摘要了 Eclipse 的設計概念，但對於第一次入手的人，可能會被複雜的結構閃到，然後就退堂了。但如果對於如何開發 VSCode 的 Extension 有興趣，卻能看完上述 Eclipse 的概念，會發現 VSCode 的概念簡化了，或者說先捨去一些設計，像是 Perspective 的概念，加入 Web 常見的用法。下圖是官方提供的架構圖：![](/images/Coding/Inspired-Design-From-Eclipse/VSCode-UI-Architecture2.png)圖檔來源：[VSCode Extension Guidelines](https://code.visualstudio.com/api/references/extension-guidelines)底下整理幾個 VSCode Extension 的概念：* Contribution Points--><hr><h1 id="從-Eclipse-學到的分散式架構啟發"><a href="#從-Eclipse-學到的分散式架構啟發" class="headerlink" title="從 Eclipse 學到的分散式架構啟發"></a>從 Eclipse 學到的分散式架構啟發</h1><p>Eclipse 本身屬於 <code>軟體層級</code> 的架構 (<code>Software Architecture</code>)，基於這樣的架構可以讓 Eclipse 達到擴充性。而我借用這個概念，把軟體架構變成 <code>系統架構 (System Archtiecture)</code> 層級的擴充架構，實作上就是基於 Web Service 為單位的擴充架構，也是現代基於 <code>分散式架構</code> 的 SaaS 產品要面對的核心問題：</p><ol><li>通訊模式</li><li>擴充架構與生態系</li><li>多租戶架構與模型</li></ol><h2 id="1-通訊模式：Concurrency-Infrastructure"><a href="#1-通訊模式：Concurrency-Infrastructure" class="headerlink" title="1. 通訊模式：Concurrency Infrastructure"></a>1. 通訊模式：<a href="https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/runtime_jobs.htm&cp=2_0_3_5">Concurrency Infrastructure</a></h2><p>下面兩張圖是我很久以前在設計 <a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a> 時所寫的管理介面，大概類似於 AWS Console EC2 個概念。</p><p><img src="/images/SQA/Regression/FP004.png"><br><img src="/images/SQA/Regression/FP003.png"></p><p>畫面上可以看一般應用程式的 Menu、主畫面 (有 Tab)、每個資源的 Detail View (下圖右邊) … 等基本結構。</p><p>這是很常見的，但是上述三個東西 (Menu &#x2F; Main Window &#x2F; Detail View) 彼此之間經常是需要 <code>資訊交換</code> 的，像是 當點選 Menu 裡一個物件的時候，Main Window 與 Detail View 需要做連動，把資訊帶入，或執行對應的行為。我就利用類似 Eclipse 裡的 <a href="https://help.eclipse.org/latest/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/runtime_jobs.htm&cp=2_0_3_5">Concurrency Infrastructure</a> 機制，讓彼此之間做通訊，後來我才知道這就是 Pub&#x2F;Sub。</p><p>用 Google Slide 來說，下圖畫面中有三個區域：</p><ol><li>上面的 Toolbar</li><li>左邊的預覽 Preview</li><li>右邊的編輯區域 (Editor)</li></ol><p>截圖的 Focus 停留在左邊預覽的 <code>第二頁</code>，另外兩個區域的行為有：</p><ol><li>Toolbar: 對應的 MenuItem 因為選擇改變功能，截圖 <code>格式</code> 相關的功能都 Disable 了，因為與在 Focus 的地方無關。</li><li>Editor: 顯示 Focus 對應的內容</li></ol><p><img src="/images/Coding/Inspired-Design-From-Eclipse/event1.png"></p><p>這三個區塊彼此是怎麼勾通的？線性的思路，就是 Foucs 點下去之後，另外兩個直接 Listen 物件的事件，然後把對應資訊傳給另外兩者處理。這樣做沒啥問題，也可以動。但如果區塊有五個？十個？二十個？100 個？還是直接這樣 Listen Event？而且直接 Listen 代表著這整個行為是 <a href="/2019/02/27/ComputerScience/IO-Models/">Blocking</a> 的，使用體驗也就不會好，通常也會因為 Blocking 而出現白畫面的現象。</p><p>而比較理想做法就是利用 Pub&#x2F;Sub 這種非同步的方式，結構除了原本的三個區域，後面多了一個 Pub&#x2F;Sub，而整個動作會變成這樣：</p><ol><li>使用者點在左邊的 Preview</li><li>Publish 一個 Message X，然後就返回。</li><li>另外兩個 (Toolbar &#x2F; Editor) 去 Subscribe 對應的 Message<ul><li>Toolbar 收到 Message X 處理定義的行為：Disable 相對應的 MenuItem</li><li>Editor 收到 Message X 處理定義的行為：顯示內容</li></ul></li></ol><p>這樣基本的概念就是：觸發 Event 以及處理 Message 兩者之間是非同步的，整個使用體驗可以做到完全 <a href="/2019/02/27/ComputerScience/IO-Models/">Non-Blocking</a> 以及即時的效果。這個例子 1: 2 的，即使到了 1 : N 效果也不會有太多影響。</p><p>這概念類似於 Eclipse 每個 Extension 之間、或者 View 之間的溝通，這也是現代分散式架構常見的模型 Pub&#x2F;Sub、在一個 Embedded 裡通常也會用 Queue 實作兩個 Device 的溝通、在作業系統則是透過 <code>Inter Process Communication</code> 實作 … 等。</p><p>通訊模式要解決的是：</p><ol><li>狀態一致：像是交易、狀態機</li><li>資料交換：傳檔、匯入、匯出</li></ol><p>通訊模式的關鍵技術則是：</p><ol><li><code>狀態一致性問題</code>，<a href="/2021/04/07/DistributedSystems/Dapr-Concepts-and-Designing/">Dapr 的設計與概念</a> 有著不錯的實踐。</li><li><a href="/2019/02/27/ComputerScience/IO-Models/">同步與非同步</a></li><li>相關關鍵基礎設施，參閱 <a href="/2021/05/14/DistributedSystems/Service-Governance/">服務治理</a></li></ol><h2 id="2-分散式架構的擴充與延伸架構"><a href="#2-分散式架構的擴充與延伸架構" class="headerlink" title="2. 分散式架構的擴充與延伸架構"></a>2. 分散式架構的擴充與延伸架構</h2><p>生態系是很多企業發展到一定程度後，勢必會出現的概念，很多大型公司都有這樣的概念，像是：</p><ol><li>Devices: 基於設備上的應用程式、應用市集<ul><li>iPhone &#x2F; macOS 的 App Store</li><li>Android 的 Google Play</li><li><a href="https://www.microsoft.com/zh-tw/store/apps/">Windows 上的 App Store</a></li><li><a href="https://www.qnap.com/zh-tw/app_center/">QNAP App Center</a></li><li>其實 PS5 &#x2F; Switch &#x2F; XBox 上的下載遊戲也算。。。</li></ul></li><li>Extensions &#x2F; Plguins &#x2F; Add-on in Web Services<ul><li><a href="https://slack.com/apps">Slack App</a></li><li><a href="https://aws.amazon.com/marketplace/">AWS 的 Marketplace</a></li><li><a href="https://apps.shopify.com/?itcat=home&itterm=app-store&locale=zh-TW">Shopify app store</a></li><li>Facebook 應用程式</li></ul></li><li>Extensions &#x2F; Plugins &#x2F; Add-on in App<ul><li>Line 在自己的 APP 裡搞的小程序</li><li><a href="https://chrome.google.com/webstore/category/extensions">Chrome Web Store</a></li><li>VSCode Extensions</li><li>Eclipse Plugins</li></ul></li></ol><p><code>擴充 (Plugins)</code> 與 <code>延伸 (Extension)</code> 是兩個概念，前者是基於既有的系統的功能，<code>垂直增加功能</code>；後者則是基於既有的系統 <code>水平擴充功能</code>。</p><ul><li><code>1)</code> 是集中管理、端點發布的架構：也就是應用程式需要被 <code>下載</code> 到使用者端，進行安裝後能夠使用。</li><li><code>2)</code> 是集中管理、共同使用架構：也就是所謂的 SaaS，使用者不需要下載、安裝，直接透過 Browser 使用。</li><li><code>3)</code> 是 <code>2)</code> 擴充，基於 <code>2)</code> 的結果繼續擴充。<ul><li>OS 之於 Chrome 的 Extension 屬於這種。</li><li>iOS 之於 Line 的 小程序 屬於這種。</li></ul></li></ul><p>下圖是 Google Docs Slide 的 Plugin，稱為 Google Workspace Marketplace</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/Google-Workspace-Marketplace.png"></p><p>水平擴充的例子在 Google 可以看到最好的例子，像是 Gmail &#x2F; Google Docs &#x2F; Slides &#x2F; Spreadsheet &#x2F; Calendar &#x2F; Meet … 就是水平功能，屬於獨立的產品線（在組織上應當屬於獨立盈利單位, BU)。他們共享的則是 SSO 機制，以及背後共用的介面、認證授權、以及 Multi-Tenancy 的隔離機制（我把它稱為 <code>Isolation Factor</code>)。</p><p><code>分散式系統擴充架構</code> 背後帶出的是另外一個 SaaS 平台的常見策略應用，也就是 Marketplace 或者稱為生態系，而背後的關鍵基礎建設則是：<a href="/2021/05/14/DistributedSystems/Service-Governance/">服務治理</a></p><p><code>擴充模式</code> 帶來的好處是：</p><ol><li>業務可拓展、探索性<ul><li>自己 (In-House) 開發</li><li>外包 (Out-Source) 給其他公司開發</li></ul></li><li>組織與架構的平衡性：參閱 <a href="/2019/03/17/Management/Perspective-in-XYZT/">看見怎樣的全貌 - 軟體開發的三體問題</a></li><li>開發可實驗性<ul><li>多種語言</li><li>跨平台</li></ul></li></ol><p><code>擴充模式</code> 的關鍵技術則是：</p><ol><li>具備 <code>通訊模式</code> 所需要的基礎設施</li><li>具備 擴展性結構 的規格</li><li>具備 良好的開發、測試規範</li></ol><p><code>擴充模式</code> 在程式語言的各種實踐樣態：</p><ol><li>Function &#x2F; Method …</li><li>Java 的 import, C# 的 using</li><li>Web Service</li><li>RPC (remote procedure call), gRPC</li><li>… 之後我會這個概念繼續掰下去 XD</li></ol><h2 id="3-多租戶架構與模型"><a href="#3-多租戶架構與模型" class="headerlink" title="3. 多租戶架構與模型"></a>3. 多租戶架構與模型</h2><p><code>多租戶架構 (Multi-Tenancy)</code> 是開發 SaaS 產品一定會面對的問題，其中 <code>產品線 (前面 Google Docs / Slide ... 等例子)</code> 與 <code>租戶 (Tenant)</code> 的關係如下圖：</p><ul><li>綠色：產品，圖直接用 AWS EC2 &#x2F; S3 &#x2F; DDB 當例子</li><li>藍色：使用者帳號，也就是 <code>租戶概念 (Tenant)</code></li></ul><p>多租戶架構設計的關鍵就是 <code>隔離 (Isolation)</code> 的實踐。</p><p><img src="/images/Coding/Inspired-Design-From-Eclipse/multi-tenancy.png"></p><p><code>隔離</code> 的概念，在各種應用系統都有，舉例來說：</p><ol><li>docker 實踐隔離的機制就是 cgroup, namespace, 隔離的是 <code>CPU</code>, <code>Memory</code>, <code>Network</code>, <code>Storage</code> 等計算機資源</li><li>VM 實踐隔離的透過模擬硬體隔離資源, 隔離的是整台 PC Hardware</li><li>K8s 透過 Namespace 隔離資源，隔離的是 deployment, pod, deamonset 這些 object.</li><li>Relation Database 實踐隔離則有各種層級與模式, 參閱論文 <a href="http://sites.computer.org/debull/A16mar/p3.pdf">The many faces of consistency</a></li><li>AWS 的 VPC 透過 overlay 實踐 <code>網路層級</code> 的隔離</li><li>語言實踐隔離的方法：Class &#x2F; Namespace 都是實踐的機制，隔離的是 <code>物件的有效範圍</code><ul><li>如果不是 OOP (像是 bash)，常用的隔離方法就是變數的命名加上 Prefix</li></ul></li><li>程式語言 Runtime 記憶體與作業系統隔離的方式: 像是 Java JVM 在作業系統 User Space 要一塊記憶體，然後與一班應用程式隔離。</li><li>WiFi Mesh 實踐的不是隔離，而是合併 ….</li><li>…</li></ol><p>通常商業軟體談的隔離則是業務邏輯的隔離概念，通常是一種 Identity 的概念。主要是因為從資源層級的隔離切入，往往不是成本太高，不然就是工程浩大，說白點一開始根本不是這樣設計，改就是傷筋動骨。</p><p>所以大部分打帶跑的開發就是從 Identity 出發做隔離，實作上就是 User Session 的概念。而因為開發階段不一樣，每個產品線可能都會有自己的隔離名稱，例如早期 S3 使用的是 <code>Canonical User ID</code> 作為隔離的單位，後來才統一使用 <code>Account Id</code> 。我把這個隔離抽象稱為 <code>隔離因子 (Isolation Factor)</code>，不同領域 Domain 會有不同名稱，做電商的會用 ShopId 做單位、開 Blog 的會用 UserId … etc。</p><p><code>多租戶架構與模型</code> 帶來的好處是：</p><ol><li>業務增長性<ul><li>與拓展不一樣</li></ul></li><li>業績直接的成長</li></ol><p><code>多租戶架構與模型</code> 的關鍵技術則是：</p><ol><li>隔離技術的實踐能力</li><li>隔離單位的定義：<ul><li>docker 可以 in docker</li><li>k8s 可以 in docker</li><li>vm 也可以 in docker</li><li>你知道 tenant 也可以 in tenant 嗎？…. 這種高 (ㄌㄞˊ) 級 (ㄌㄨㄢˋ) 的技術，一般鄉民是無法理解的。。。</li></ul></li></ol><p>SaaS 隔離具體的實踐是什麼？待我之後文章詳細整理與分析。</p><hr><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a> 一文提到這張圖：</p><p><img src="/images/AWS/API-Gateway/Private-Endpoint/Microservice-Arch-on-AWS_v3.png"></p><p>這張圖已經包含了這整個概念與脈絡，背後想表達的就是 <code>通訊模式</code> 與 <code>擴充</code> 概念，再加上這篇最後提到的多租戶與隔離的概念，一個基於分散式架構的 SaaS 平台基礎算式有了。</p><p>這篇起個頭，整理一些動手實踐、也翻滾幾年的想法，細節之後慢慢展開詳談。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2019/02/27/ComputerScience/IO-Models/">Study Notes - I&#x2F;O Models</a></li><li><a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a></li><li><a href="/2018/06/18/DistributedSystems/Gossip-in-Distributed-Systems/">聊聊分散式系統</a></li><li><a href="/2021/04/07/DistributedSystems/Dapr-Concepts-and-Designing/">摘要 Dapr 的設計與概念</a></li><li><a href="/2019/03/17/Management/Perspective-in-XYZT/">看見怎樣的全貌 - 軟體開發的三體問題</a></li><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li><a href="/2021/07/11/DistributedSystems/Experience-Dapr-PubSub/">Experience Dapr - Pub&#x2F;Sub</a></li><li><a href="/2013/11/17/OSX/Install-OSX-Mavericks-on-PC/">Install Mac OS Mavericks on PC (蘋果安裝筆記)</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://code.visualstudio.com/api">VS Code - Extension API</a></li><li><a href="https://docs.osgi.org/specification/osgi.core/7.0.0/">OSGi Specification License, Version 2.0</a></li><li><a href="http://sites.computer.org/debull/A16mar/p3.pdf">The many faces of consistency</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理關於 SaaS 架構設計的想法，部分是來自於 Eclipse 這個著名 Java IED 的設計概念。&lt;/p&gt;
&lt;p&gt;大約從 2018 之後，VSCode 可以算是統一 Open Source 的 IDE 了，之前由 GitHub 開發的 Atom 在微軟收購了 GitHub 之後，已經將在 December 15, 2022 落下了句點，其他 Editors (還不到 IDE) 大多還是屬於輔助性質，像是 Notepad++ 。&lt;/p&gt;
&lt;p&gt;而 VSCode 主要的設計者 &lt;a href=&quot;https://en.wikipedia.org/wiki/Erich_Gamma&quot;&gt;Erich Gamma&lt;/a&gt; 則是著名的 Design Pattern 的共同作者之一 (又稱 GoF)，而這個理論背後源自於他的實作，也是著名的 Java IDE - &lt;a href=&quot;https://en.wikipedia.org/wiki/Eclipse_(software)&quot;&gt;Eclipse&lt;/a&gt;，Erich Gamma 負責最核心的 JDT (Java development Tooling) 的設計。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2015/10/11/SQA/How-To-Be-An-SQA/&quot;&gt;2004 - 2012 年期間，我在 IBM 駐點開發 Rational 相關產品&lt;/a&gt;，其中主要就是 Eclipse Plugins 的開發，產品是給 Web Developer 用的工具，可以說就是在寫 IDE 的概念。過程曾經鑽研了 Eclipse Plugins、RCP (Rich Client Platform, XMind &amp;#x2F; DBeaver 就是這個開發的) &amp;#x2F; Equinox OSGi &amp;#x2F; SWT &amp;#x2F; JFace &amp;#x2F; EMF &amp;#x2F; GEF … 等設計概念，也因此對於 Eclipse 整個架構略有研究，而這些設計概念也不知不覺的用在之後工作上。&lt;/p&gt;
&lt;p&gt;這些年的更迭與代換，我自己的工作環境 &lt;a href=&quot;/2013/11/17/OSX/Install-OSX-Mavericks-on-PC/&quot;&gt;從 Windows 換到 macOS&lt;/a&gt;，開發工具從 Eclipse 換到了 Atom，然後又跳到 VSCode。在使用 VS Code 的過程，處處都聞到 Eclipse 的設計感。開始做分散式架構設計、重讀作業系統、學習 CS 基礎知識、探索 AWS &amp;#x2F; K8s … 等過程，發現這些背後的本質都有高度的雷同。&lt;/p&gt;</summary>
    
    
    
    <category term="Distributed Systems" scheme="https://rickhw.github.io/categories/Distributed-Systems/"/>
    
    
    <category term="Operating System" scheme="https://rickhw.github.io/tags/Operating-System/"/>
    
    <category term="Java" scheme="https://rickhw.github.io/tags/Java/"/>
    
    <category term="Pub/Sub" scheme="https://rickhw.github.io/tags/Pub-Sub/"/>
    
    <category term="Eclipse" scheme="https://rickhw.github.io/tags/Eclipse/"/>
    
    <category term="Event Driven Architecture" scheme="https://rickhw.github.io/tags/Event-Driven-Architecture/"/>
    
    <category term="Plugins" scheme="https://rickhw.github.io/tags/Plugins/"/>
    
    <category term="OSGi" scheme="https://rickhw.github.io/tags/OSGi/"/>
    
    <category term="Extension" scheme="https://rickhw.github.io/tags/Extension/"/>
    
    <category term="Design Thinking" scheme="https://rickhw.github.io/tags/Design-Thinking/"/>
    
    <category term="Multi-Tenancy" scheme="https://rickhw.github.io/tags/Multi-Tenancy/"/>
    
    <category term="Marketplace" scheme="https://rickhw.github.io/tags/Marketplace/"/>
    
    <category term="SaaS" scheme="https://rickhw.github.io/tags/SaaS/"/>
    
    <category term="Isolation Factor" scheme="https://rickhw.github.io/tags/Isolation-Factor/"/>
    
  </entry>
  
  <entry>
    <title>SRE Conference 2022 - 91APP 在 AWS 上的 SRE 實踐之路</title>
    <link href="https://rickhw.github.io/2022/05/10/About/2022-SREConf2022/"/>
    <id>https://rickhw.github.io/2022/05/10/About/2022-SREConf2022/</id>
    <published>2022-05-10T13:42:30.000Z</published>
    <updated>2022-12-19T14:07:23.780Z</updated>
    
    <content type="html"><![CDATA[<p>感謝 AWS 與 <a href="https://sre.ithome.com.tw/news-page/155">主辦單位 (iTHome)</a> 的邀請，讓我在 04&#x2F;29 有機會在第一次的 SRE Conf 分享這幾年的一些心得與想法。</p><span id="more"></span><h2 id="Slide-與錄影"><a href="#Slide-與錄影" class="headerlink" title="Slide 與錄影"></a>Slide 與錄影</h2><p>沒有來現場的朋友，可以透過以下的 Slide 與錄影回看內容：</p><iframe src="//www.slideshare.net/slideshow/embed_code/key/urWYYrWa2yTXAp" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/rickhwang/91app-aws-sre" title="SRE Conf 2022 - 91APP 在 AWS 上的 SRE 實踐之路" target="_blank">SRE Conf 2022 - 91APP 在 AWS 上的 SRE 實踐之路</a> </strong> from <strong><a href="//www.slideshare.net/rickhwang" target="_blank">Rick Hwang</a></strong> </div><iframe width="560" height="315" src="https://www.youtube.com/embed/f-__anVimq0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="重點摘要"><a href="#重點摘要" class="headerlink" title="重點摘要"></a>重點摘要</h2><ol><li>讓 <code>規範</code> 變 <code>規格 (Spec, RFC)</code>，用 <code>軟體工程</code> 解決 <code>維運問題</code></li><li>以 EO&#x2F;AP 模型規劃 SRE 平台藍圖與架構</li></ol><p><img src="/images/About/2022-SREConf/Platform-Blueprint.png"><br><img src="/images/About/2022-SREConf/DevOps-Governance.png"></p><p><img src="/images/About/2022-SREConf/Principle-Practice.png"></p><p><img src="/images/About/2022-SREConf/SRE-Platform.png"></p><h2 id="照片-by-主辦單位-iTHome"><a href="#照片-by-主辦單位-iTHome" class="headerlink" title="照片 by 主辦單位 (iTHome)"></a>照片 by 主辦單位 (iTHome)</h2><p>以下是主辦單位 - iTHome 提供的照片，感謝一起參與的朋友們～</p><p><img src="/images/About/2022-SREConf/Live1.jpg"><br><img src="/images/About/2022-SREConf/Live2.jpg"><br><img src="/images/About/2022-SREConf/Live3.jpg"></p><h2 id="感謝"><a href="#感謝" class="headerlink" title="感謝"></a>感謝</h2><p>感謝來現場來聽的朋友，還有回饋給我的朋友，感謝大家的建議，很感動～</p><p><img src="/images/About/2022-SREConf/Feedback.png"></p><p>然後也遇到幾位許有沒碰面的朋友 ( 蔡宗城, Sammy Lin, Weithenn Wang )、新朋友 Google 的 Shawn Ho<br>大家在後台喇賽合影留念 XD</p><p><img src="/images/About/2022-SREConf/backstage.jpeg"></p><p>還有神 (ㄌㄚˇ) 交 (ㄙㄞˋ) 好幾年的 Scott Liao ，終於碰面 XDD</p><p>還有 AWS 的老朋友們 Kim Kao, 梁綺軒, Hung-Che Lo<br>沒碰到面的 Chris Huang,  郭杰穎 ~~</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="https://www.slideshare.net/rickhwang/2020-aws-summit-aws">2020&#x2F;07&#x2F;10: 2020 AWS 雲端高峰會 - 演講：在矩陣型組織裡，如何有效管理 AWS 的成本結構與系統架構</a></li><li><a href="https://www.slideshare.net/rickhwang/aws-using-aws-for-disaster-recovery/">2020&#x2F;01&#x2F;08: AWS reInvent reCAP 2019 - 災難演練 @ AWS 實戰分享 </a></li><li><a href="/2019/03/28/DevOps/DevOpsTaiwan-Meetup-Beginning-in-Artifacts-Management/">2019&#x2F;03&#x2F;28: DevOps Taiwan Meetup #22 - 聊聊軟體交付的濫觴 談產出物管理</a></li><li><a href="/2018/09/12/DevOps/DevOpsDaysTaipei2018-Emergency-And-Incident-Management/">2018&#x2F;09&#x2F;12: 演講：從緊急事件 談 SRE 應變能力的培養</a></li><li><a href="/2018/05/26/About/201805-Monitoring-Tools-CloudWatch/">2018&#x2F;05&#x2F;26: 演講：Monitoring Tools 大亂鬥 - AWS CloudWatch</a></li><li><a href="/2018/07/18/About/20180718-API-Gateway/">2018&#x2F;06&#x2F;28: AWS Summit Taipei - API Gateway 導入之旅, AWS</a></li><li><a href="/2018/03/29/About/2018-Serverless-All-Star/">2018&#x2F;03&#x2F;29: 演講：Serverless All-Star - Ops as Code using Serverless</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;感謝 AWS 與 &lt;a href=&quot;https://sre.ithome.com.tw/news-page/155&quot;&gt;主辦單位 (iTHome)&lt;/a&gt; 的邀請，讓我在 04&amp;#x2F;29 有機會在第一次的 SRE Conf 分享這幾年的一些心得與想法。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Conference" scheme="https://rickhw.github.io/tags/Conference/"/>
    
    <category term="SRE" scheme="https://rickhw.github.io/tags/SRE/"/>
    
    <category term="Spec" scheme="https://rickhw.github.io/tags/Spec/"/>
    
    <category term="Design First" scheme="https://rickhw.github.io/tags/Design-First/"/>
    
  </entry>
  
  <entry>
    <title>As a Sofware Developer</title>
    <link href="https://rickhw.github.io/2022/05/07/Coding/As-Sofeware-Developer/"/>
    <id>https://rickhw.github.io/2022/05/07/Coding/As-Sofeware-Developer/</id>
    <published>2022-05-06T19:33:00.000Z</published>
    <updated>2022-12-19T11:47:28.853Z</updated>
    
    <content type="html"><![CDATA[<p>這篇是我在 <a href="https://www.facebook.com/completethink/posts/4600718506621275">2021&#x2F;05&#x2F;23</a> 寫的一篇關於 Developer 的條件寫的文章，我自己覺得這樣的要求是不過分的，但是，可能跟很多現代的過念有所差異，特別是一些從外面的培訓機構訓練出來的學生。</p><span id="more"></span><hr><h2 id="As-a-Software-Developer"><a href="#As-a-Software-Developer" class="headerlink" title="As a Software Developer"></a>As a Software Developer</h2><p>打從開始寫 Code ，我的認知開發者就是必須了解 <code>作業系統</code>，也一直把這當作是基本的條件，也就是不管是 Dev &#x2F; QA &#x2F; Ops 的角色，對作業系統有一定認識都是必備的基本技能。這樣的習慣與認知，從學生時代在寫 LAMP 時就是這樣。自己裝 OS、自己 Compile (PHP, MySQL, Apache)、把系統配置好，然後寫程式、寫應用、自己寫 installer。</p><p>這樣的習慣隨著後來虛擬化技術開始出現之後，依舊沒變，只是多了一個技能：VMWare。</p><p>從 3.0 開始玩，跑 Linux 、裝 Windows、後來工作上自己弄了一推 IBM 產品當 Lab 環境，跑各種模擬，把自己寫好的東西 (J2EE) 部署上去。後來類似的 Hypervisor 虛擬技術，像是 vSphere 、Proxmox、Hyper-V … 到 Cloud 像 AWS、GCP …. 就一路過來，從來就不是只是 Code Level 。</p><p>後來做 SQA 的角色，裝環境、自動換安裝更是家常便飯。後來帶 <a href="/2015/10/11/SQA/How-To-Be-An-SQA/">SQA Team</a>，建立整個 SQA 的 Lab (實體實驗室)，從網路規劃、設備採購、軟體配置、實驗室空間規劃、資源分配，全部都自己來，讓整個 Team 可以有效運作。而產品系統架構可以在實體實驗室完全重建，獨立驗證，也可以快速地搬到 AWS，作效能測試。</p><blockquote><p>相關參閱：</p><ul><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li></ul></blockquote><p>所以我認為一個 Developer 該會的技能，從來就不是只有 Programming Skills，不是只是談那些 CQRS、Saga、DDD … etc， 而是從系統、網路、程式語言、資料、演算法，整個能夠串起來。</p><p>不知曾幾何時，我被貼上 Infra &#x2F; Ops 的標籤，只要談到這些東西，很多 Dev &#x2F; QA 都會認為那不是他們需要會的東西。其實這樣的說法對我來說是不 Qualify 的，如果是面試，基本上已經被我刷掉了。</p><p>扯遠了，<a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">這篇文章</a> 是我多年前學 K8s 的筆記，從動手中學習，K8s 版本從 v1.11 -&gt; v1.21、作業系統 Ubuntu 從 16.04 -&gt; 20.04，VM 橫跨四種平台，很多細節我也不是很懂，但一次又一次的迭代與探索，也掌握了一些基本。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></li><li><a href="/2015/10/11/SQA/How-To-Be-An-SQA/">Software QA 的職能條件</a></li><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇是我在 &lt;a href=&quot;https://www.facebook.com/completethink/posts/4600718506621275&quot;&gt;2021&amp;#x2F;05&amp;#x2F;23&lt;/a&gt; 寫的一篇關於 Developer 的條件寫的文章，我自己覺得這樣的要求是不過分的，但是，可能跟很多現代的過念有所差異，特別是一些從外面的培訓機構訓練出來的學生。&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://rickhw.github.io/categories/Coding/"/>
    
    
    <category term="Operating System" scheme="https://rickhw.github.io/tags/Operating-System/"/>
    
    <category term="Software Developer" scheme="https://rickhw.github.io/tags/Software-Developer/"/>
    
  </entry>
  
  <entry>
    <title>Designing Configuration Loading Strategies</title>
    <link href="https://rickhw.github.io/2022/05/06/Coding/Designing-Configuration-Loading-Strategies/"/>
    <id>https://rickhw.github.io/2022/05/06/Coding/Designing-Configuration-Loading-Strategies/</id>
    <published>2022-05-06T10:21:00.000Z</published>
    <updated>2022-12-19T11:47:28.853Z</updated>
    
    <content type="html"><![CDATA[<p>應用程式 在啟動 or 初始化 (Initial &#x2F; Startup)的時候，配置 (Configuration) 載入的流程經過這麼多年的發展，基本上已經有一個常見的策略模式了，這些概念很重要，卻也很常被忽略，最後系統上線後只能夠透過改 Code 重新部署才能處理問題，好的設計應該是改配置就能滿足需求。</p><p>這篇原文是寫在 SRE 社群的一篇 <a href="https://www.facebook.com/groups/sre.taiwan/posts/2287745194724705/">筆記</a>，借保哥的 <a href="https://blog.miniasp.com/post/2022/05/02/Dont-use-ERR_UNSAFE_PORT-for-your-website">整理</a> 發揮另一個常見的東西：<code>配置與設定的讀取策略設計</code></p><span id="more"></span><h2 id="設計摘要"><a href="#設計摘要" class="headerlink" title="設計摘要"></a>設計摘要</h2><h3 id="名詞定義"><a href="#名詞定義" class="headerlink" title="名詞定義"></a>名詞定義</h3><ul><li><code>配置 (Configuration)</code>: 通常指的是儲存在某種 Storage 形式，像是 <code>檔案</code> 或者 存在 DB 的 Table</li><li><code>設定 (Settings)</code>: 每個配置裡的 K&#x2F;V 一對一對的東西稱為設定</li><li><code>應用程式 (Application)</code>：經常簡寫 AP or App，以獨立 Process 存在的 Deamon (Web) 或者透過 CronJob 短週期執行的批次應用。像是用 Java &#x2F; C# &#x2F; Golang &#x2F; PHP 寫的 Web App、或者非同步作業 Console 應用。</li></ul><h3 id="讀取策略"><a href="#讀取策略" class="headerlink" title="讀取策略"></a>讀取策略</h3><p>在大部分的應用程式 (特別是 Open Source Software, OSS) 設計的配置大概都有下圖的概念：</p><p><img src="/images/Coding/Configuration-Loading-Strategies_v20220508.png"></p><!--source:https://docs.google.com/presentation/d/14oEOfWYvl6DJF1wzeYt0Fxm0wQPeEvzgS36FHlUqlno/edit#slide=id.g13be4190e44_0_0--><ul><li><code>黑色實線區塊</code>：代表實體存在 Storage 的軟體</li><li><code>白色實線區塊</code>：代表存在於 Memory 的 Runtime</li><li><code>左邊區塊</code>：表示從作業系統角度切入，User Session 分成 Login Shell 和 Non-Login Shell 兩個狀態。</li><li><code>右邊區塊</code>：User Session 的狀態下，應用程式 (例如 nginx or express app、dotnet console … etc) 透過中間藍色的 <code>invoke</code> 帶起 Process 的過程。<ul><li>環境變數與 Arguments 隨著 invoke 帶給 Process</li></ul></li></ul><p>而這些配置讀取的策略大部分的 <code>先後次序</code> ：</p><ol><li><code>[紅底]</code> 讀取環境變數設定值：根據現在的 Session ，讀取 <code>環境變數 (Environment)</code><ul><li>環境變數的用途是 <code>選擇用途</code>，而不是 <code>指定數值</code>，像選擇 Profile，而不是指定 port number。</li><li>選擇 Profile 表示包含選擇不同認證授權的 Token 來源。</li><li>注意 Session 的狀態讀取的來源有所差異，例如 Login-Shell 跟 Non-Login Shell 初始的流程就不一樣，相關參閱 <a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">Shell and Bash Concepts</a> 的說明。</li></ul></li><li><code>[橘色]</code> 先看看參數是否有指定 (args &#x2F; options)，有的話會 <code>覆寫</code> 或者 <code>跳過</code>  2) User Level 的設定</li><li><code>[綠色]</code> 讀取 使用者設定檔 (Config)：通常讀取次序在環境變數之後，透過環境變數的選擇用途，指定大範圍的 <code>檔案</code> 或者 <code>目錄結構</code>。<ul><li>配置檔的 <code>形式</code> 分成 <code>靜態</code>、<code>動態</code> 兩種，靜態像是存在 storage 的 json &#x2F; yaml，動態像是存在 RDB &#x2F; Consul 裡的 K&#x2F;V</li><li>配置讀取的 <code>模式 </code>分成 <code>Pull</code>、<code>Push</code> 兩種。<ul><li>Pull 是應用程式主動去某個地方拿，像是檔案系統、DB … etc；</li><li>Push 則是配置檔的來源自己透過 Event 的方式把異動推給 Application。</li></ul></li></ul></li><li><code>[紫色]</code> 上述如果都沒有，直接使用 System Level (程式碼) 裡的預設值，像是寶哥舉例的 <code>kRestrictedPorts</code></li></ol><p>常見的一些工具讀取配置的策略大概都是這樣，像是大家常用的 kubectl、aws cli、 vscode 、git … 有些除了上述四的步驟，會多了認證授權的 credential.</p><p>這個 <code>配置與設定的讀取策略設計</code> 是大家可以留意的，出問題時，或者在用新工具、在開發新應用程式的時候，依照這個邏輯，才能正確確認應用程式有讀取到正確的配置。</p><p>實際上實作讀取策略的讀取次序，有可能跟上述描述剛好相反，但是結果是一致的，例如透過繼承概念實作讀取策略，那就是先讀預設值。</p><h3 id="注入來源"><a href="#注入來源" class="headerlink" title="注入來源"></a>注入來源</h3><p>通常 APP 在設計時，在 Code Level 會有一些 <code>預設</code> 設定值，然後在第一次啟動應用程式時，自動產生使用者配置，裡面會寫入一份預設值 (或者留白)。另外應用程式本身的執行程式通常也可以透過參數 (保哥文中提到的 <code>--explicitly-allowed-ports=10080</code>) 複寫這些設定值，或者可以透過 <code>環境變數 (ENV)</code> 選擇不同的 <code>配置</code>。</p><p>所以配置的設定值的來源有這些地方：</p><ul><li><code>程式碼裡的預設值 (Code Level)</code>：在應用程式裡宣告的預設值。<ul><li>通常是寫在 Constants or Interface or Enum 或者 c 的 header (.h)</li><li>相對於 <code>使用者層級設定</code>，預設就是 <code>系統層級設定 (System Level Settings)</code>，像是 Linux <code>/etc</code> 底下的都是系統層級的設定。</li></ul></li><li><code>使用者層級設定 (User Level Settings)</code>：<ul><li>使用者層級的配置，通常會放在 <code>$HOME/.&lt;appname&gt;/ (目錄)</code> 或者 <code>$HOME/.&lt;appname&gt;rc (檔案)</code></li><li>第一次應用程式初始的時候，初始設定的策略有幾種，依照應用程式設計特性而定。<ol><li>系統層級複製一份過來</li><li>從出廠預設複製一份</li><li>或者留空</li><li>初始透過問答 (prompt, wizard) 的方式產生 (像是 <a href="https://ohmyz.sh/">oh-my-zsh</a> &#x2F; <a href="https://github.com/romkatv/powerlevel10k">p10k</a> 的初始過程)</li></ol></li><li>大家可以在自己系統 (macOS &#x2F; linux &#x2F; Windows) <code>$HOME</code> 底下發現很多 用點 (dot) 開頭的 <code>目錄</code> 或者 <code>檔案</code></li><li>我很常舉例的就是 unix 登入時的初始流程 Login Shell 與 Non-Login Shell 的概念，相關說明參閱 <a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">Shell and Bash Concepts</a></li></ul></li><li><code>臨時的參數啟動 (Inject by Arguments)</code><ul><li>通常給進階使用者、開發者自己使用，可以臨時替換配置檔裡的設定，不需要改檔案內容就能測試。</li><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a> 提到的 Testcase 的 Config Management 就有這樣的設計。開發測試案例者，可以透過參數化的方式 overwrite 檔案的配置，提高 <code>測試 - 測試案例</code> 的便利性。</li></ul></li><li><code>環境變數指定 (Environment Variables)</code>：選擇適當的配置項目，像是選擇不同身份以及配置<ul><li>AWS CLI 預設就是透過 <code>AWS_PROFILE</code> 選擇不同的 AK&#x2F;SK，沒有指定則讀取 <code>default</code></li><li>Environment Variables 的來源跟 unix shell 初始流程很有關係，相關說明參閱 <a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">Shell and Bash Concepts</a> 的 Login Shell 與 Non-Login Shell。</li></ul></li></ul><h3 id="環境變數的應用"><a href="#環境變數的應用" class="headerlink" title="環境變數的應用"></a>環境變數的應用</h3><p>環境變數常見的用法有以下幾種：</p><ol><li>指定使用者的 Profile：環境變數本身是 Session Base，適用的情境就是依照使用者身份，提供 Profile 選擇。</li><li>關鍵路徑的指定，像是 <code>HOME</code>、<code>LOG_PATH</code>、<code>Lib Path</code> 等</li><li>系統層級的交互餐數：像是 C compiler command 、 LDFLAGS (linker flags)</li></ol><p>應用程式自己業務邏輯的參數，建議都放在 Configuration 裡，而不是透過 Environment 注入。</p><h3 id="參數的設計"><a href="#參數的設計" class="headerlink" title="參數的設計"></a>參數的設計</h3><p>另外，通常建議設計一個 Flag (像是 <code>--verbose</code>、<code>--debug</code>、<code>--dryrun</code>) ，讓應用程式初始化之後顯示上述的配置，可以用來快速確認目前啟動是否正確。甚至直接做 Validation，只要配置有錯誤，就直接中斷應用程式。</p><h3 id="預設值"><a href="#預設值" class="headerlink" title="預設值"></a>預設值</h3><hr><h2 id="Application-Interface-Spec"><a href="#Application-Interface-Spec" class="headerlink" title="Application Interface Spec"></a>Application Interface Spec</h2><p>通常在除錯時，都要確認一些基礎資訊的正確性：</p><p>a. <code>由外而內</code>: 輸入資料來源的正確性 (API Request Payload)<br>b. <code>由內而外</code>: 應用程式的配置正確性</p><p>如果系統已經執行一段時間，通常找問題的點都會在 a)，也就是輸入資料的正確性，像是 API 的 Payload 某些值有錯誤、超出範圍。</p><p>如果系統是新部署 (更版 &#x2F; 業務拓展 &#x2F; 測試環境)，通常要先確認的是 b)、再來才是 a)。很多時候都是應用程式初始過程中的配置有問題，像是外部依賴的位址給錯了 (通常是 copy &amp; paste 忘了改)、或者某些 secret 給錯、對於系統外部程式的依賴版本錯誤 … 等，而怎麼初始配置的流程則是除錯過程中必要知道的 Know How。</p><blockquote><p>註：這裡的 <code>內、外</code> 指的是應用程式從 Artifact 跑起來變成 Process 之後，給予的資訊流。以 WebApp 來講，<code>由外而內</code> 就是透過 WebAPI 提供資訊所造成的行為。而 <code>由內而外</code> 則是 Process 自身內部 Event 或者生命週期提供的資訊，像是 Configuration。</p></blockquote><p>上述的 <code>a) + b)</code> 我把它稱為 <code>Application Interface Spec</code> (暫時縮寫成 <code>AppInterSpec</code>) ，範圍涵蓋以下：</p><ol><li><code>由外而內</code>：<code>使用者</code> 看得到的介面，形式有以下<ol><li><code>API</code>: 形式包含 <code>WebAPI</code>、<code>Libraries API</code></li><li><code>通訊協議與資料結構</code>:<ul><li>L7&#x2F;HTTP:<ul><li>RESTful 的 request &#x2F; response</li><li>HTTP Header</li><li>JWT Payload</li><li>Cookies</li></ul></li><li>RPC 溝通的資料結構</li></ul></li><li>通訊認證:<ul><li>企業內部系統之間的通訊認證模式，相關概念參閱 <a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a></li><li>對外部系統的通訊認證模式</li></ul></li></ol></li><li><code>由內而外</code>：<code>開發團隊</code> 看得到的介面<ol><li><code>Environment Variables</code>: 明確環境變數的用途與適用範圍</li><li><code>Configuration</code>: Config 與 Settings 的定義、配置檔案的策略、設定操作策略 (static &#x2F; dynamic)<ul><li><code>Static (or 被動 / pull)</code>: file or db base</li><li><code>Dynamic (or 主動 / push)</code>: event base, 像是 feature toggle 的實作, consul … etc.</li></ul></li><li><code>Secret</code>: 算是 Configuration 的一環，牽涉敏感，所以通常獨立於 Configuration 之外。<ul><li>Loading 的技術概念與 Configuration 一致，同樣分成 static &#x2F; dynamic or pull &#x2F; push 等模式。</li><li>Data Storage Source 會配合 KMS 方式加解密，也會有其他的管理政策配合。</li></ul></li><li><code>Database Schema</code>: 不管是 RDB or NoSQL，都是要有結構定義的</li><li><code>Storage Structure</code>: 非結構性的資料存放結構，通常都要有目錄結構的定義與宣告。</li></ol></li></ol><p>而本文談的是 <code>2.1)</code>、<code>2.2)</code> 的設計原則。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>開發者很常討論 OOD 的 <code>DI (Dependency Injection, 依賴注入 or Dependency Inversion, 依賴反轉)</code>，談的是 Code Level 的注入資訊反轉、與注入策略與模式，這些都是程式啟動後 Runtime 過程 Object 的行為，不管是範圍 (Scope) 還是物件啟動的生命週期。</p><p>而本文著眼的是應用程式初始化 (Initial &#x2F; Startup) 時，配置載入的流程策略與模式，我把這些配置稱為 <code>Application Interface Spec</code> 的其中一部分。Configuration 是應用程式層級的 DI，透過他可以靈活的控制應用程式的行為、邏輯，讓使用者有能力控制整個應用程式的行為，不需要改程式碼，重新編譯打包。</p><p>這個設計一個新的應用程式時候，就必須確立好 AppInterSpec 的範圍，然後經過開發的持續迭代，持續修正與調整。</p><!--### 配置的配置複雜應用程式的配置，會開始具備 DSL (Domain Specific Languague) 的特性，也就是因應特定用途產生的，最經典的例子就是 Java 的老朋友 Ant 這個建制工具。後來類似概念的東西衍生的則是 Gradle ，Gradle 本身就是個 DSL，只是透過 Groovy 這個 JVM scripting lanaguage 呈現。--><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2021/01/03/Linux/Shell-and-Bash-Concepts/">Shell and Bash Concepts</a></li><li><a href="/2018/05/12/SQA/Designing-Test-Architecture-and-Framework/">Designing Test Architecture and Framework</a></li><li><a href="/2020/03/02/AWS/Study-Notes-KMS/">Study Notes - Key Management Service</a></li><li><a href="/2021/05/14/DistributedSystems/Service-Governance/">聊聊分散式架構的服務治理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;應用程式 在啟動 or 初始化 (Initial &amp;#x2F; Startup)的時候，配置 (Configuration) 載入的流程經過這麼多年的發展，基本上已經有一個常見的策略模式了，這些概念很重要，卻也很常被忽略，最後系統上線後只能夠透過改 Code 重新部署才能處理問題，好的設計應該是改配置就能滿足需求。&lt;/p&gt;
&lt;p&gt;這篇原文是寫在 SRE 社群的一篇 &lt;a href=&quot;https://www.facebook.com/groups/sre.taiwan/posts/2287745194724705/&quot;&gt;筆記&lt;/a&gt;，借保哥的 &lt;a href=&quot;https://blog.miniasp.com/post/2022/05/02/Dont-use-ERR_UNSAFE_PORT-for-your-website&quot;&gt;整理&lt;/a&gt; 發揮另一個常見的東西：&lt;code&gt;配置與設定的讀取策略設計&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Coding" scheme="https://rickhw.github.io/categories/Coding/"/>
    
    
    <category term="DI" scheme="https://rickhw.github.io/tags/DI/"/>
    
    <category term="Application Interface Spec" scheme="https://rickhw.github.io/tags/Application-Interface-Spec/"/>
    
    <category term="Configuration" scheme="https://rickhw.github.io/tags/Configuration/"/>
    
    <category term="Dependency Injection" scheme="https://rickhw.github.io/tags/Dependency-Injection/"/>
    
    <category term="Dependency Inversion" scheme="https://rickhw.github.io/tags/Dependency-Inversion/"/>
    
  </entry>
  
  <entry>
    <title>Version Control 與 Artifact Management</title>
    <link href="https://rickhw.github.io/2022/04/06/SoftwareEngineering/Artifact-Management-and-Version-Control/"/>
    <id>https://rickhw.github.io/2022/04/06/SoftwareEngineering/Artifact-Management-and-Version-Control/</id>
    <published>2022-04-06T01:50:30.000Z</published>
    <updated>2022-12-19T11:47:28.870Z</updated>
    
    <content type="html"><![CDATA[<p>幾年前的分享 <a href="/2019/03/28/DevOps/DevOpsTaiwan-Meetup-Beginning-in-Artifacts-Management/">聊聊軟體交付的濫觴 - 談產出物管理</a>，簡報最後面留幾個問題讓大家思考。</p><p><img src="/images/SoftwareEngineering/Artifact-And-VersionControl.png"></p><p>最近有朋友私下敲我，問了最後一個問題：</p><blockquote><p><code>分支策略</code> 跟 <code>Artifact Management</code> 的關係？</p></blockquote><p>問題背後是他在新創團隊裡，遇到在處理分支策略的同時，也遇到如何打包 Artifact ，兩者的衝突與矛盾。</p><p>底下是我針對這個問題整理的摘要。</p><blockquote><p>本文重新整理我在 <a href="https://www.facebook.com/rick.kyhwang/posts/10216798025462365">FB</a> 寫的草稿，之後嘗試錄了一段口述，提供給大家參考。</p></blockquote><iframe width="560" height="315" src="https://www.youtube.com/embed/dkF_sGuwjjo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><span id="more"></span><hr><h2 id="要解決怎樣的問題？"><a href="#要解決怎樣的問題？" class="headerlink" title="要解決怎樣的問題？"></a>要解決怎樣的問題？</h2><p>這兩個東西各有要解決的問題。</p><blockquote><p>分支策略 要解決的核心問題：<code>團隊協作的問題</code></p></blockquote><ul><li>一堆人開發，比較流暢的方式。</li><li>開發流程的分工與切割？</li><li>顆粒度大小？</li><li>libraries or web service ? console ? …</li></ul><p>分支策略，應該要減少影響發布流程，也就是常說的 CI &#x2F; CD Pipeline 過程，太複雜的分支策略，會製造出很複雜的 Pipeline。</p><p>各種分支策略的比較，參閱 <code>持續交付2 第八章</code>，這不是 0 or 1 的是非題，而是看組織 &#x2F; 架構 發展到哪個階段 (#康威定律)，還有 Tech Lead 能掌握的狀況。</p><blockquote><p>Artifact Management 要解決的則是 <code>軟體交付標準化</code> 的問題。</p></blockquote><ul><li>給 docker image or zip?</li><li>這東西我能用嗎？你可以不要一直改嗎？</li><li>我是 QA，正在測一個 long running 情境，我要哪哪一個版本測？</li><li>我明天就要開工，你可以先給我一個沒有實作的 lib 嗎？</li><li>我要部署到美西，給北美市場，請問我要部署哪一個版本</li><li>我要部署到火星，給木星市場，請問我要部署哪一個版本</li></ul><h2 id="Artifact-交付的原則-Version-Control"><a href="#Artifact-交付的原則-Version-Control" class="headerlink" title="Artifact 交付的原則 - Version Control"></a>Artifact 交付的原則 - Version Control</h2><p>簡單定義 Artfact 交付的一些基本概念：</p><blockquote><p>我把 <code>交付</code> 定義成 Artifact 主要目的，也就是 <code>版本控管 (Version Control)</code></p></blockquote><p>核心規則如下：</p><p>Artifact Image 會分兩種 Types:</p><ul><li><code>dev</code>: development version<ul><li><code>假設功能尚未被驗證，以驗證功能為主，只能在團隊內部使用。</code></li><li>具備 debug 功能, 特殊後門, 特殊 config flag, 選擇性編譯 (build flag) … etc.<ul><li>binary 沒有最佳化, 放特殊 trace flag …</li><li>如果是 open source 專案，找找官網的 nightly build or daily build，就是這一類。</li></ul></li></ul></li><li><code>rel</code>: release version<ul><li><code>功能已經完成驗證，經過認證程序，可以給客戶使用。</code></li><li>debug 功能關閉，或者需要其他特殊方法才能開啟<ul><li>特殊方法：<a href="https://www.techbang.com/posts/86376-klomi-classic-secret-35th-anniversary-mv-up-down-left-and">上上下下左右左右BABA</a></li></ul></li><li>binary 有最佳化，像是混淆、簽章</li><li>一個版本，最後只會有一個，也就是在外面流通的。</li></ul></li></ul><p>底下舉例，這段例子在 <a href="/2015/02/11/SoftwareEngineering/Version-Control/">Version Control</a> 一文也有描述 ：</p><ul><li>開發中: v1.0.0<ul><li>今天 (04&#x2F;06) 建制的版本：RickLds-v1.0.0-dev-b20220406-1200.zip</li><li>明天 (04&#x2F;07) 建制的版本：RickLds-v1.0.0-dev-b20220407-1200.zip</li><li>大後天建制的版本：RickLds-v1.0.0-dev-b20220408-1200.zip</li><li>類推，就是個 Time Series 的概念。</li><li>注意：版本 (v1.0.0) 都還沒跳號，不管過程中發現多少 defects</li><li>直到完成 v1.0.0 的 release procedure 後</li><li>下一個開發循環開始的時候，跳 v1.1.0 ，回到 (a.)</li></ul></li><li>Release: v1.0.0<ul><li>完成 v1.0.0 release procedure，</li><li>最後產出 release image: <code>RickLds-v1.0.0-rel.zip</code> or <code>RickLds:v1.0.0-rel</code><ul><li>只有一個，透過 sign 的方式確認檔案的唯一性 (md5&#x2F;sha256&#x2F;sha512)</li></ul></li><li>artifact 與 config 是 1 對多的關係。</li><li>config 的數量 &#x3D; env 數量。</li></ul></li></ul><h3 id="平常看得到的案例"><a href="#平常看得到的案例" class="headerlink" title="平常看得到的案例"></a>平常看得到的案例</h3><ul><li>微軟 Windows<ul><li>試用版或者內部人員流出來的開發版，就是上述的 dev version，可能會有多個。</li><li>正式 release 的就是上述的 release version，通常一個版本只會有一個。<ul><li>有些會有 RC (release candidate) 或者 beta version. (名稱差異代表開發流程的定義)</li></ul></li></ul></li><li>dapr: <a href="https://github.com/dapr/dapr/releases">https://github.com/dapr/dapr/releases</a><ul><li>release &#x2F; rc: 鄉民可以拿來玩的東西</li><li>dev: 看不到，自己下載 source 自己 build ㄅ</li></ul></li><li><a href="https://go.dev/blog/publishing-go-modules">Go 的 Module 發布</a>: 官方文件建議用 <a href="https://go.dev/ref/mod#pseudo-versions">pseudo-versions</a> 表示發布之前的版本，其實就是我前述的 <code>開發版</code>。官方設計的 pseudo-version 包含以下三個資訊：<ul><li><code>A base version prefix (vX.0.0 or vX.Y.Z-0)</code>, which is either derived from a semantic version tag that precedes the revision or vX.0.0 if there is no such tag.</li><li><code>A timestamp (yyyymmddhhmmss)</code>, which is the UTC time the revision was created. In Git, this is the commit time, not the author time.</li><li><code>A revision identifier (abcdefabcdef)</code>, which is a 12-character prefix of the commit hash, or in Subversion, a zero-padded revision number.</li></ul></li></ul><h3 id="Artifact-Images-的規則是必要的？"><a href="#Artifact-Images-的規則是必要的？" class="headerlink" title="Artifact Images 的規則是必要的？"></a>Artifact Images 的規則是必要的？</h3><p>Q: 我的團隊從來都沒有你說的東西 dev &#x2F; rel，一樣能跑。所以真的需要這樣分？什麼時候需分 <code>開發版</code> 與 <code>釋出版</code> 的 Artifact Images？</p><blockquote><p>沒有 dev &#x2F; rel 團隊依然可以運作，大部分是因為遇到依賴管理問題，所以就不會有這樣的需求，也沒意會到這樣的問題。依賴管理指的是團隊彼依賴的功能是透過 Artficat 發布的方式運作，像是彼此是透過 NuGET &#x2F; Docker &#x2F; mvn &#x2F; npm … 等。當團隊規模到一定程度之後，拆分模組獨立發布與管理，這是必然的需求。</p><p>會覺得沒有這樣的問題，常常是因為參照的方式是透過 <code>檔案相對路徑</code> 參考，而不是透過 artifact 參考。像是 .NET 專案 (.csproj) 裡面的 dependency 是相對路徑，而不是 reference。</p><p>最常見的是開發共用的 libraries 給大家用，開發過程必然會有開發中的版本 (dev version)，給自己團隊內部測試、驗證使用，以及釋出給別人 (其他團隊、客戶) 使用的 rel version。</p></blockquote><h3 id="最常見的錯誤觀念"><a href="#最常見的錯誤觀念" class="headerlink" title="最常見的錯誤觀念"></a>最常見的錯誤觀念</h3><ul><li>開發中的版本, ex v1.1.0, 還沒 release 就要 進版號, 不管是 x, y, or z.</li><li>沒有區分 dev &#x2F; rel ，不管怎樣的環境都用同一種</li><li>把 config 包進去 artifact</li><li>以為只能用在 semanitc versioning, chrome 單一版號也適用。</li><li>以為這樣不能跑敏捷開發 (ex: scrum): 這好像沒關係。</li><li>以為用了這個就不敏捷 …. 我下班了。</li></ul><h2 id="Semantic-Versioning"><a href="#Semantic-Versioning" class="headerlink" title="Semantic Versioning"></a>Semantic Versioning</h2><p><a href="/2015/02/11/SoftwareEngineering/Version-Control/">Version Control</a> 通常會搭配 版本號碼的規則，而 <a href="https://semver.org/">Semantic Versioning</a> (x.y.z) 則是最常見、最普遍的通則。</p><h3 id="初始專案實踐-Semantic-Versioning-的方式"><a href="#初始專案實踐-Semantic-Versioning-的方式" class="headerlink" title="初始專案實踐 Semantic Versioning 的方式"></a>初始專案實踐 Semantic Versioning 的方式</h3><p>初始專案指的是新專案，從 0 -&gt; 1 的階段，在這段時間 <a href="https://semver.org/">Semantic Versioning</a> 跳號方式：</p><p>建議從 v0.1 開始跳，每個 sprint 跳一個 v0.2-dev, v0.3-dev …<br>直到可以 release 給第一個客戶，直接跳 v1.0-rel</p><p>進入專案的 1 -&gt; 10 的階段，就進入正常的跳號流程，<br>每個 release 都跳 第二碼，也就是 v1.1.0 -&gt; v1.2.0 -&gt; v1.3.0 …</p><h3 id="Deliver-Hello-World-in-First-Day"><a href="#Deliver-Hello-World-in-First-Day" class="headerlink" title="Deliver Hello World in First Day"></a>Deliver Hello World in First Day</h3><p>專案之初，通常是從 0 -&gt; 1 的階段<br>就要把上述流程建好，<br>不管是開發 Web Service &#x2F; Frontend &#x2F; Libraries &#x2F; Desktop App &#x2F; Console …<br>都是一樣的原則。</p><p>換言之<br>專案開跑的時候，<br>就可以 build 可以交付的 artifact<br>我把這概念稱為 <code>Deliver Hello World in First Day</code><br>第一天就要可以交付。<br>這種交付不是透過 IDE 那種 export 功能完成的<br>而是透過 ci server 建制出來的。</p><p>第一天就要完成 <a href="/2019/04/04/DevOps/Four-Pillars-of-Software-Delivery/">軟體交付的四大支柱</a> 定義的東西。</p><p>這個概念，跟 Unit Test 的概念是一樣的，只是對象不一樣而已。錄影中我嘗試闡述這段 <code>Deliver Hello World in First Day</code> 的想法：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/dkF_sGuwjjo?start=835" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>所以 Artifact Management 跟分支策略的關係是？我具體的回答如下：</p><blockquote><p>沒關係，因為要解決的問題不一樣。在 <a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">軟體開發生命週期 (SDLC)</a> 過程，都應該要有 <code>開發版</code> 與 <code>釋出版</code>，不管哪個分支策略，技術上都做得到，也應該做得到。</p><p>至於本文前述中我定義的名詞 (dev &#x2F; rel)，可能和一些生態系用語會有些差異。像微軟預設就有 Release &#x2F; Debug 的定義，而我把 debug 定義成 另一個 flag 的概念。因為不管 dev or rel 都具備 debug 功能，也可以關掉。不然你以為 <a href="https://www.techbang.com/posts/86376-klomi-classic-secret-35th-anniversary-mv-up-down-left-and">上上下下左右左右BABA</a> 是怎麼來的？XDD</p><p>所以兩者要解決的問題不一樣，關係不太。100 團隊有 1000 種分支策略跑法。但 Artifact Management 的原則都一樣，但實作可能也有 1000 種。像是版號: 三碼 (x.y.z)、還是一碼 (chrome 99)？支援多少種 artifact type (docker &#x2F; raw &#x2F; nuget &#x2F; npm … etc)，artifact image 命名規則大家都不一樣，<a href="/2015/02/11/SoftwareEngineering/Version-Control/">Version Control</a> 整理一些以前的例子，<a href="/2018/07/08/DevOps/Artifacts-Management/">Artifacts Management</a> 最後面的截圖舉了兩種例子。</p></blockquote><h3 id="版本管理與軟體開發"><a href="#版本管理與軟體開發" class="headerlink" title="版本管理與軟體開發"></a>版本管理與軟體開發</h3><p>By the way，我口語的 <code>版本管理</code> 跟大部分寫 Code 的 Engineer 是不一樣的意思，大部分 Engineer 談的都是 <code>VSC (Version Control System)</code>，像是 git &#x2F; svn &#x2F; p4 … 這種 <code>工具</code>，談的是分支策略, 或者是 git 怎麼操作 (man git)。</p><p>而我講的 <code>版本管理</code> 是 <a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">軟體開發週期 (SDLC)</a>，如何定義好版本 以及開發過程中，如何交付給別人使用，從使用者角度。</p><p>而這篇文章描述是我用來判斷是否了解 <a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">軟體開發週期 (SDLC)</a> 的依據之一，特別是擔任軟體 TPM &#x2F; PM &#x2F; PO 是必須清楚掌握的，因為無法掌握整個 SDLC，就是掌握不住團隊運作的 <code>節奏</code>，一首歌拍子不對，音符彈的再炫砲、技術再厲害，曲就是不成歌。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章"><a href="#站內文章" class="headerlink" title="站內文章"></a>站內文章</h2><ul><li><a href="/2019/03/28/DevOps/DevOpsTaiwan-Meetup-Beginning-in-Artifacts-Management/">聊聊軟體交付的濫觴 談產出物管理 (Artifacts Management)</a></li><li><a href="/2015/02/11/SoftwareEngineering/Version-Control/">Version Control</a></li><li><a href="/2018/07/08/DevOps/Artifacts-Management/">Artifacts Management</a></li><li><a href="/2017/09/14/SoftwareEngineering/Software-Development-Lifecycle/">Software Development Lifecycle</a></li><li><a href="/2019/04/04/DevOps/Four-Pillars-of-Software-Delivery/">軟體交付的四大支柱 (Four Pillars of Software Delivery)</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://semver.org/">Semantic Versioning</a></li><li><a href="https://blog.philipphauer.de/version-numbers-continuous-delivery-maven-docker/">Version Numbers for Continuous Delivery with Maven and Docker</a></li></ul><!--// Step 1main(void) {    return 0;}@unitestmain_test() {    assert(main() == 0, true);}=> librick-v0.1.0-dev-2022120323.so// Step 2main(int x, int y) {    if (x < 0 || y < 0) {        return -1;    }    return x+y;}@unitestmain_test1() {    assert(main(1,3) == 4, true);}main_test2() {    assert(main(-1,-1) == -1, true);}=> librick-v0.1.0-dev-20221203334.so-->]]></content>
    
    
    <summary type="html">&lt;p&gt;幾年前的分享 &lt;a href=&quot;/2019/03/28/DevOps/DevOpsTaiwan-Meetup-Beginning-in-Artifacts-Management/&quot;&gt;聊聊軟體交付的濫觴 - 談產出物管理&lt;/a&gt;，簡報最後面留幾個問題讓大家思考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SoftwareEngineering/Artifact-And-VersionControl.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近有朋友私下敲我，問了最後一個問題：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;分支策略&lt;/code&gt; 跟 &lt;code&gt;Artifact Management&lt;/code&gt; 的關係？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;問題背後是他在新創團隊裡，遇到在處理分支策略的同時，也遇到如何打包 Artifact ，兩者的衝突與矛盾。&lt;/p&gt;
&lt;p&gt;底下是我針對這個問題整理的摘要。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文重新整理我在 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/10216798025462365&quot;&gt;FB&lt;/a&gt; 寫的草稿，之後嘗試錄了一段口述，提供給大家參考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/dkF_sGuwjjo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;</summary>
    
    
    
    <category term="Software Engineering" scheme="https://rickhw.github.io/categories/Software-Engineering/"/>
    
    
    <category term="Artifact Management" scheme="https://rickhw.github.io/tags/Artifact-Management/"/>
    
    <category term="Version Control" scheme="https://rickhw.github.io/tags/Version-Control/"/>
    
    <category term="Semantic Versioning" scheme="https://rickhw.github.io/tags/Semantic-Versioning/"/>
    
    <category term="Branch Strategies" scheme="https://rickhw.github.io/tags/Branch-Strategies/"/>
    
  </entry>
  
  <entry>
    <title>團隊溝通的通訊協議</title>
    <link href="https://rickhw.github.io/2021/12/19/Management/Protocol-to-Communication/"/>
    <id>https://rickhw.github.io/2021/12/19/Management/Protocol-to-Communication/</id>
    <published>2021-12-19T10:21:00.000Z</published>
    <updated>2022-12-19T11:47:28.865Z</updated>
    
    <content type="html"><![CDATA[<p>怎樣做好溝通、有效的溝通一直以來都是管理者的工作範疇之一。也因此我一直在探索背後的本質問題，像是 <a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a>、<a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a>、<a href="/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/">會議原則</a>、<a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></p><p>底下整理幾篇今年隨筆寫下的想法，主要是關於 <code>團隊溝通的通訊協議</code> 的想法。</p><ul><li><a href="https://www.facebook.com/completethink/posts/4977764562249999">2021&#x2F;09&#x2F;24</a>: 通訊協議與團隊溝通</li><li><a href="https://www.facebook.com/rick.kyhwang/posts/10215493367966743">2021&#x2F;05&#x2F;10</a>: 團隊溝通的標準化</li></ul><span id="more"></span><hr><h2 id="通訊協議與團隊溝通"><a href="#通訊協議與團隊溝通" class="headerlink" title="通訊協議與團隊溝通"></a>通訊協議與團隊溝通</h2><p>在計算機科學裡，<code>協議 (Protocol)</code> 扮演著讓各種 <code>資源 (Client / Server)</code> 有著統一個溝通介面，目的就是讓 <code>通訊 (Commuication)</code> 有效率、有品質，才能真的做事。最有名的協議就是 <code>TCP/IP</code> 這個已經數十年的標準，其他還有眾多協議，像是網路七層裡 (OSI) 最常用的 L7 協議 <code>HTTP</code>、之前整理的 <a href="/2021/08/20/ComputerScience/HTTPS-TLS/">TLS 安全協議</a>、分散式系統的 <a href="/2018/08/11/DistributedSystems/Distributed-Consistency-and-Consensus-Algorithm/">共識演算法</a> … 等，在 <code>RFC (Request for Comments)</code> 裡有著成千的協議標準定義，背後目的都是讓通訊有正確性、有效率。</p><p>計算機科學裡很多概念，都可以用在真實世界，只是把主詞換一下，變成某人而已。像是組織內部團隊的 <code>通訊協議</code>，很常見的系統化方法就是透過 <a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">Issue Tracking</a> 具體這些標準，組織越大，標準化工作就越顯重要。</p><h3 id="群體溝通常見的現象"><a href="#群體溝通常見的現象" class="headerlink" title="群體溝通常見的現象"></a>群體溝通常見的現象</h3><p><a href="/2020/03/24/Management/Principles-of-Communication/">人類的溝通</a>，受限於每個人的理解、背景知識、環境等內外在因素，再加上 <code>有意</code> 或 <code>無意</code> 的 <code>資訊落差</code> 的問題，往往溝通是牛頭不對馬嘴的。</p><blockquote><p>你不知道某些事，但我知道。資訊落差就是 <code>情報</code>，在戰場上，情報就決定勝負了</p></blockquote><p>用前面提到的 網路七層 來比喻，常常聽到這樣的對話：</p><ul><li>A: 我想要 NLB 幫我轉導 URL Path 可以嗎？</li><li>B: NLB 處理的是 L4，你的需求是 L7 的。</li></ul><p>這就是一種錯頻的溝通，另外常常看到的對話，討論內容的動詞，第一句與第二句的主詞根本就錯亂，整個溝通根本就是牛頭不對馬嘴。用生活中比較容易理解的話來說：就是 <code>狗和熱狗</code> 的對話。</p><h3 id="組織溝通常見的問題"><a href="#組織溝通常見的問題" class="headerlink" title="組織溝通常見的問題"></a>組織溝通常見的問題</h3><p>用理性、有邏輯的討論事情，才是有效率的、<a href="/2018/09/12/DevOps/DevOpsDaysTaipei2018-Emergency-And-Incident-Management/">有正確性的溝通</a>(P130). 組織裡的溝通效率，隨著 <a href="/2017/09/03/Management/Phases-in-Startup/">組織不同階段的發展</a>，溝通模式也要跟著調整，以下是常見的幾種問題：</p><ol><li>隨便走過來說兩句話就交辦任務，沒提供客觀資料、有整理過的資訊、補齊資訊落差的對談與需求，基本上都是在浪費時間。</li><li>沒有理性閱讀資料、深入理解，理性建議與討論的會議是沒有意義的</li><li>各種溝通的標準模式：與設計 API 一樣，人跟人溝通也都要標準化，像是會議、決策會議、溝通會議、狀態更新會議、新技術研討會 …. 等各種形式的標準化。</li></ol><p>實際上，有效率的方法，就是 <a href="/2015/01/06/Management/%E5%8D%94%E5%90%8C%E5%90%88%E4%BD%9C%E7%B3%BB%E7%B5%B1%E5%BB%BA%E5%88%B6%E8%88%87%E5%B0%8E%E5%85%A5-%E4%BB%A5-Redmine-%E7%82%BA%E4%BE%8B/">Issue Tracking</a>，而這件事情是整個組織，從上到下都要跟上的，<strong>特別是管理階層</strong>，沒有跟上的，對於資訊掌握能力就不夠，對於現場判斷容易有認知誤差，而 Issue Tracking System (Redmine &#x2F; JIRA &#x2F; VSTS) 是非常系統化且邏輯的溝通介面，能處理的是也就大、且複雜。</p><p>國外具規模以上 (500+) 的公司，Issue Tracking 的標準化是很核心的工作，怎樣讓組織運作有效率，團隊分工清楚，是要從管理階層開始的。管理階層怎麼掌握現在過去、未來、任務的狀況，不是靠一堆沒有章法、結構不一的 Excel &#x2F; Slide，也不是靠自己電腦用的 evernotes、notion，更不是用 slack 這種通訊工具 隨便 at 一些人就搞定的，而是實實在在地透過 <code>系統化</code>、<code>結構化</code>，加上 <code>流程</code> 與 <code>狀態機</code>，<code>執行</code> 與 <code>專案管理</code> 則 配合現在 <code>敏捷</code> 的概念 (看板, Scrum) ，才是整個組織有效率的基礎。</p><hr><h2 id="團隊溝通的標準化"><a href="#團隊溝通的標準化" class="headerlink" title="團隊溝通的標準化"></a>團隊溝通的標準化</h2><p>管理者對於溝通管理應該有以下工作：</p><ul><li><ol><li>建立團隊之間協作的 <code>通訊協議 (Protocol)</code></li></ol><ul><li>有了協議，才能有效溝通</li><li>成員有機會專心做事，才會有產出</li></ul></li><li><ol start="2"><li>確立目的、目標、優先序</li></ol></li><li><ol start="3"><li>給資源、時間</li></ol></li><li><ol start="4"><li>教練</li></ol></li></ul><blockquote><p>能獨自處理 2), 1) 者，為潛力人才。</p></blockquote><p>溝通沒效率的問題，都在 1) 沒做到位。設計不良的系統，問題也都在 1)。TCP&#x2F;IP 之所以能用這麼多年，因為他是兩個網路設備之間溝通的標準。</p><blockquote><p>SSL、OAuth2、HTTP、TCP … 等, 都是協議。</p></blockquote><p>做好通訊協議的步驟：</p><ul><li><ol><li>定義好雙方的 <code>Interface</code>、必要 <code>資訊 (data structure)</code></li></ol></li><li><ol start="2"><li>定義好處理的 <code>核心資源</code>，人跟人之間處理的核心問題統稱 <code>議題 (Issue)</code></li></ol></li><li><ol start="3"><li>定義核心資源的 <code>狀態機 (FSM)</code>，說白話：<code>工作流程 (Workflow)</code></li></ol></li><li><ol start="4"><li>定義狀態機狀態移轉的條件，也就是 <code>誰</code> 能做 <code>狀態改變 (Transition)</code></li></ol></li><li><ol start="5"><li>接下來才是狀態移轉的方法，也就是導入 OOXX 系統來提升效率化。</li></ol></li></ul><p>整個過程跟計算機科學差不多。</p><h3 id="無效溝通的現象"><a href="#無效溝通的現象" class="headerlink" title="無效溝通的現象"></a>無效溝通的現象</h3><p>無效溝通有以下狀況：</p><ul><li><ol><li><code>定義沒共識</code>：你的 <code>商品</code> 跟我的 <code>商品</code> 定義不一樣，<code>你的架構</code> 跟 <code>我的架構</code> 圖完全不一樣，<code>你的名字</code> 和 <code>我的名字</code> 不一樣。</li></ol></li><li><ol start="2"><li><code>溝通的角色不對等</code>：高層在乎的、與執行者在乎的本來就不一樣。高層談業績、談風險、成本，執行談實作、談技術、落地。</li></ol></li><li><ol start="3"><li><code>層次不對等</code>：討論高層次 (High View) 的概念，卻拿細節鑽牛角尖。就像是 HTTP 跟 TCP 討論 Header 到底要帶啥鬼一樣，是沒意義的。</li></ol></li><li><ol start="4"><li><code>搞不清楚狀況</code>：沒做功課就去溝通，<code>RTFM</code> <code>WTF</code></li></ol></li><li><ol start="5"><li><code>問題定義</code>：問題定義尚未確立，所有人還搞不清楚，就開始討論做法，跳到 2), 3), 4) 的時候整個浪費時間.</li></ol></li></ul><p>這些都是肇因沒有建立好溝通的通訊協議。</p><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2020/03/24/Management/Principles-of-Communication/">溝通的原理</a></li><li><a href="/2020/08/01/Management/Expression-and-Communication/">表達與溝通的差異</a></li><li><a href="/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/">會議原則</a></li><li><a href="/2020/10/11/Management/Effective-Meetings/">一場有效的會議</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;怎樣做好溝通、有效的溝通一直以來都是管理者的工作範疇之一。也因此我一直在探索背後的本質問題，像是 &lt;a href=&quot;/2020/03/24/Management/Principles-of-Communication/&quot;&gt;溝通的原理&lt;/a&gt;、&lt;a href=&quot;/2020/08/01/Management/Expression-and-Communication/&quot;&gt;表達與溝通的差異&lt;/a&gt;、&lt;a href=&quot;/2014/11/26/Management/%E9%96%8B%E6%9C%83%E5%8E%9F%E5%89%87/&quot;&gt;會議原則&lt;/a&gt;、&lt;a href=&quot;/2020/10/11/Management/Effective-Meetings/&quot;&gt;一場有效的會議&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;底下整理幾篇今年隨筆寫下的想法，主要是關於 &lt;code&gt;團隊溝通的通訊協議&lt;/code&gt; 的想法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.facebook.com/completethink/posts/4977764562249999&quot;&gt;2021&amp;#x2F;09&amp;#x2F;24&lt;/a&gt;: 通訊協議與團隊溝通&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/10215493367966743&quot;&gt;2021&amp;#x2F;05&amp;#x2F;10&lt;/a&gt;: 團隊溝通的標準化&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="經營管理" scheme="https://rickhw.github.io/categories/%E7%B6%93%E7%87%9F%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="溝通" scheme="https://rickhw.github.io/tags/%E6%BA%9D%E9%80%9A/"/>
    
    <category term="Protocol" scheme="https://rickhw.github.io/tags/Protocol/"/>
    
    <category term="協議" scheme="https://rickhw.github.io/tags/%E5%8D%94%E8%AD%B0/"/>
    
  </entry>
  
  <entry>
    <title>Experience EKS Anywhere</title>
    <link href="https://rickhw.github.io/2021/09/23/AWS/Experience-EKS-Anywhere/"/>
    <id>https://rickhw.github.io/2021/09/23/AWS/Experience-EKS-Anywhere/</id>
    <published>2021-09-23T14:37:00.000Z</published>
    <updated>2022-12-19T11:47:28.844Z</updated>
    
    <content type="html"><![CDATA[<p>AWS 把 EKS 本身開源了，稱為 <code>EKS Anywhere</code>，除了在 AWS 自己之外，也可以安裝在私有 (on-premises) 的環境。</p><p>本文整理體驗的筆記，我在 macOS、ubuntu20.04 都有做過，本文記錄則以 ubuntu 20.04 為主，內容以參考 <a href="https://anywhere.eks.amazonaws.com/docs/getting-started/install/">EKS Anywhere</a> 官方文件為主。</p><span id="more"></span><hr><h1 id="準備"><a href="#準備" class="headerlink" title="準備"></a>準備</h1><h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><p>我用 VMWare 準備了一台 Ubuntu 20.04，資源有:</p><ul><li>CPU: 4core</li><li>Memory: 16GiB</li><li>Disk: 100GiB</li><li>Network: Bridge Mode</li></ul><p>軟體準備：</p><ul><li>Docker CE v20.x 以上，相關安裝可以參考 <a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></li></ul><p>如果是直接在 macOS 上用 Docker CE 跑，建議先修改 docker Resources 資源，我把記憶體拉到很高，同時關掉其他的 containers，如圖：</p><p><img src="/images/AWS/EKS/Anywhere/docker-ce-macos.png"></p><h2 id="準備-K8s-amp-EKS-CLI"><a href="#準備-K8s-amp-EKS-CLI" class="headerlink" title="準備 K8s &amp; EKS CLI"></a>準備 K8s &amp; EKS CLI</h2><p>EKS Anywhere 主要使用 兩個 AWS 的 CLI:</p><ol><li><code>eksctl</code></li><li><code>eksctl-anywhere</code></li></ol><p>下載這兩個工具，這個筆記統一都放在 <code>$HOME/bin</code> 底下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1. 下載 eksctl</span></span><br><span class="line">~<span class="comment"># curl &quot;https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz&quot; \</span></span><br><span class="line">    --silent --location \</span><br><span class="line">    | tar xz -C /usr/local/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. 下載 eksctl-anywhere, 並指定 EKSA 的版本</span></span><br><span class="line">~<span class="comment"># export EKSA_RELEASE=&quot;0.5.0&quot; OS=&quot;$(uname -s | tr A-Z a-z)&quot;</span></span><br><span class="line">~<span class="comment"># curl &quot;https://anywhere-assets.eks.amazonaws.com/releases/eks-a/1/artifacts/eks-a/v$&#123;EKSA_RELEASE&#125;/$&#123;OS&#125;/eksctl-anywhere-v$&#123;EKSA_RELEASE&#125;-$&#123;OS&#125;-amd64.tar.gz&quot; \</span></span><br><span class="line">    --silent --location \</span><br><span class="line">    | tar xz /usr/local/eksctl-anywhere</span><br><span class="line"></span><br><span class="line">~<span class="comment"># eksctl anywhere version</span></span><br><span class="line">v0.5.0</span><br></pre></td></tr></table></figure><p>新的 VM 也要準備 kubectl。</p><h2 id="下載-docker-images"><a href="#下載-docker-images" class="headerlink" title="下載 docker images"></a>下載 docker images</h2><p>EKS anywhere 安裝過程，需要使用一些 EKS 官方的 Images，如果網路速度不快，安裝過程需要時間等待，所以建議先把這些 images 下載。</p><p>我安裝的時候，下載了以下 images:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-server:~<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                                                                                        TAG                            IMAGE ID       CREATED        SIZE</span><br><span class="line">public.ecr.aws/eks-anywhere/mrajashree/etcdadm-bootstrap-provider                                 v0.1.0-beta-4.1-eks-a-1        fdf90a12059b   13 days ago    39.5MB</span><br><span class="line">public.ecr.aws/eks-anywhere/mrajashree/etcdadm-controller                                         v0.1.0-beta-4.1-eks-a-1        1df9b1e09c08   13 days ago    44.2MB</span><br><span class="line">public.ecr.aws/eks-anywhere/cli-tools                                                             v0.1.0-eks-a-1                 ab7c32596071   13 days ago    390MB</span><br><span class="line">public.ecr.aws/eks-anywhere/kubernetes-sigs/kind/node                                             v1.21.2-eks-d-1-21-4-eks-a-1   e786b2049245   13 days ago    1.64GB</span><br><span class="line">public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api-provider-aws/cluster-api-aws-controller   v0.6.4-eks-a-1                 f19480314c0c   13 days ago    65.2MB</span><br><span class="line">public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/capd-manager                              v0.3.23-eks-a-1                9551d1a8c5e4   13 days ago    228MB</span><br><span class="line">public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/kubeadm-control-plane-controller          v0.3.23-eks-a-1                9e78bc6ef020   13 days ago    62.1MB</span><br><span class="line">public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/kubeadm-bootstrap-controller              v0.3.23-eks-a-1                c74f411ef1c2   13 days ago    56.4MB</span><br><span class="line">public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/cluster-api-controller                    v0.3.23-eks-a-1                8cc018325da7   13 days ago    57.4MB</span><br><span class="line">public.ecr.aws/eks-anywhere/jetstack/cert-manager-webhook                                         v1.1.0-eks-a-1                 ff993602e2ca   13 days ago    42.4MB</span><br><span class="line">public.ecr.aws/eks-anywhere/jetstack/cert-manager-controller                                      v1.1.0-eks-a-1                 07ed0e004245   13 days ago    52.8MB</span><br><span class="line">public.ecr.aws/eks-anywhere/jetstack/cert-manager-cainjector                                      v1.1.0-eks-a-1                 3e6a2a6e0bd3   13 days ago    40.8MB</span><br><span class="line">public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api-provider-vsphere/release/manager          v0.7.10-eks-a-1                a11c8cf5aa7f   13 days ago    55.4MB</span><br><span class="line">public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy                                                v0.8.0-eks-a-1                 f35c58b91b9c   13 days ago    41.7MB</span><br><span class="line">kindest/haproxy                                                                                   v20210715-a6da3463             083ad526a17e   2 months ago   31.8MB</span><br><span class="line">hello-world                                                                                       latest                         d1165f221234   6 months ago   13.3kB</span><br></pre></td></tr></table></figure><p>底下是用 docker 下載的 scripts，這些資訊是在 <code>~/$&#123;CLUSTER_NAME&#125;/generated/clusterctl_tmp.yaml</code> 裡面找到的，並且整理出來的，這些資訊應該會隨著版本的演進而有所改變，所以以下的資訊與版本僅供參考：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker pull public.ecr.aws/eks-anywhere/cli-tools:v0.1.0-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/kubernetes-sigs/kind/node:v1.21.2-eks-d-1-21-4-eks-a-1</span><br><span class="line">docker pull kindest/haproxy:v20210715-a6da3463</span><br><span class="line"></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/jetstack/cert-manager-cainjector:v1.1.0-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/jetstack/cert-manager-controller:v1.1.0-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/jetstack/cert-manager-webhook:v1.1.0-eks-a-1</span><br><span class="line"></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/cluster-api-controller:v0.3.23-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy:v0.8.0-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/kubeadm-bootstrap-controller:v0.3.23-eks-a-1</span><br><span class="line"></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/kubeadm-control-plane-controller:v0.3.23-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy:v0.8.0-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api-provider-aws/cluster-api-aws-controller:v0.6.4-eks-a-1</span><br><span class="line"></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy:v0.8.0-eks-a-1 <span class="comment">#org one is v0.4.1</span></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api-provider-vsphere/release/manager:v0.7.10-eks-a-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy:v0.8.0-eks-a-1 <span class="comment">#org one is v0.8.0</span></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/kubernetes-sigs/cluster-api/capd-manager:v0.3.23-eks-a-1</span><br><span class="line"></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy:v0.8.0-eks-a-1 <span class="comment">#org one is v0.4.0</span></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/mrajashree/etcdadm-bootstrap-provider:v0.1.0-beta-4.1-eks-a-1</span><br><span class="line"></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy:v0.8.0-eks-a-1 <span class="comment">#org one is v0.4.0</span></span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/mrajashree/etcdadm-controller:v0.1.0-beta-4.1-eks-a-1</span><br><span class="line">docker pull public.ecr.aws/eks-anywhere/brancz/kube-rbac-proxy:v0.8.0-eks-a-1 <span class="comment">#org one is v0.4.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述資訊是我自己手動整理的，應該會變化很快。之所以整理這份，是我在 lab 的過程，剛好遇到網路狀況不好，所以花很多時間下載 images ，如果預先下載好，整個安裝速度就快很多。</p><hr><h1 id="建立-Local-Cluster"><a href="#建立-Local-Cluster" class="headerlink" title="建立 Local Cluster"></a>建立 Local Cluster</h1><p>準備好前述工作，接下來就可以開始建立 EKS Cluster 了。</p><h2 id="產生配置"><a href="#產生配置" class="headerlink" title="產生配置"></a>產生配置</h2><p>透過 <code>eksctl</code> 產生一個 clusterconfig:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CLUSTER_NAME=<span class="string">&quot;ricklab-cluster&quot;</span></span><br><span class="line">eksctl anywhere generate clusterconfig <span class="variable">$CLUSTER_NAME</span> \</span><br><span class="line">   --provider docker &gt; <span class="variable">$CLUSTER_NAME</span>.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看一下這個檔案內容有什麼：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">anywhere.eks.amazonaws.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ricklab-cluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterNetwork:</span></span><br><span class="line">    <span class="attr">cni:</span> <span class="string">cilium</span></span><br><span class="line">    <span class="attr">pods:</span></span><br><span class="line">      <span class="attr">cidrBlocks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">172.16</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">      <span class="attr">cidrBlocks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line">  <span class="attr">controlPlaneConfiguration:</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">datacenterRef:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">DockerDatacenterConfig</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ricklab-cluster</span></span><br><span class="line">  <span class="attr">externalEtcdConfiguration:</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">kubernetesVersion:</span> <span class="string">&quot;1.21&quot;</span></span><br><span class="line">  <span class="attr">workerNodeGroupConfigurations:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">count:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">anywhere.eks.amazonaws.com/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DockerDatacenterConfig</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ricklab-cluster</span></span><br><span class="line"><span class="attr">spec:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>這份 config 裡有幾個重要的資訊：</p><ol><li>K8s 版本是 <code>1.21</code><ol><li>Control Plane 有一個 node</li><li>Worker Node 有一個 node</li><li>etcd 有一個 node</li></ol></li><li>CNI 使用 <a href="https://cilium.io/">cilium</a>: eBPF-based Networking, Observability, and Security<ol><li>指定了 pod 的 CIDR Blocks, 注意預設的範圍 <code>192.168.0.0/16</code>，可能會跟網路環境衝突或者重疊，所以我改成了 <code>172.16.0.0/16</code></li><li>指定了 Services 的 CIDR Blocks，跟我的環境沒有衝突，所以沒有改。</li></ol></li><li>Data Center 的 Kind 是 Docker</li></ol><h2 id="建立-Local-Cluster-1"><a href="#建立-Local-Cluster-1" class="headerlink" title="建立 Local Cluster"></a>建立 Local Cluster</h2><p>建立一個 Local Cluster，這會花一點時間</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">❯ ~ ··· at 14:51:27</span><br><span class="line">❯ eksctl anywhere create cluster -f <span class="variable">$CLUSTER_NAME</span>.yaml -v 5</span><br><span class="line">Performing setup and validations</span><br><span class="line">Warning: The docker infrastructure provider is meant <span class="keyword">for</span> <span class="built_in">local</span> development and testing only</span><br><span class="line">✅ Docker Provider setup is valid</span><br><span class="line">Creating new bootstrap cluster</span><br><span class="line">Installing cluster-api providers on bootstrap cluster</span><br><span class="line">Provider specific setup</span><br><span class="line">Creating new workload cluster</span><br><span class="line">Installing networking on workload cluster</span><br><span class="line">Installing storage class on workload cluster</span><br><span class="line">Installing cluster-api providers on workload cluster</span><br><span class="line">Moving cluster management from bootstrap to workload cluster</span><br><span class="line">Installing EKS-A custom components (CRD and controller) on workload cluster</span><br><span class="line">Creating EKS-A CRDs instances on workload cluster</span><br><span class="line">Installing AddonManager and GitOps Toolkit on workload cluster</span><br><span class="line">GitOps field not specified, bootstrap flux skipped</span><br><span class="line">Writing cluster config file</span><br><span class="line">Deleting bootstrap cluster</span><br><span class="line">🎉 Cluster created!</span><br><span class="line"></span><br><span class="line">❯  ~ ··· took 10m 11s at 15:02:00</span><br><span class="line">❯</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述資訊是完全沒有調整 docker CE 的資源 (預設記憶體是 8GiB) 、跑在 MacOS 上，過程跑了將近 10 分鐘，調整到 20GiB 之後，跑完約 7 分鐘。</p><p>如果畫面很久沒反應，可以增加參數 <code>-v 5</code> 了解狀況，底下是在 Ubuntu 上執行時的紀錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-server:~<span class="comment"># export CLUSTER_NAME=&quot;dev-cluster&quot;</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># eksctl anywhere generate clusterconfig $CLUSTER_NAME \</span></span><br><span class="line">&gt;    --provider docker &gt; <span class="variable">$CLUSTER_NAME</span>.yaml</span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment"># eksctl anywhere create cluster -f $CLUSTER_NAME.yaml -v 5</span></span><br><span class="line">2021-09-23T13:12:57.401ZV4Logger init completed&#123;<span class="string">&quot;vlevel&quot;</span>: 5&#125;</span><br><span class="line">2021-09-23T13:13:00.159ZV1Setting up cli docker dependencies</span><br><span class="line">2021-09-23T13:13:00.159ZV2Pulling docker image&#123;<span class="string">&quot;image&quot;</span>: <span class="string">&quot;public.ecr.aws/eks-anywhere/cli-tools:v0.1.0-eks-a-1&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:13:02.407ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;setup-validate&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:13:02.407ZV0Performing setup and validations</span><br><span class="line">2021-09-23T13:13:02.407ZV0Warning: The docker infrastructure provider is meant <span class="keyword">for</span> <span class="built_in">local</span> development and testing only</span><br><span class="line">2021-09-23T13:13:02.407ZV0✅ Docker Provider setup is valid</span><br><span class="line">2021-09-23T13:13:02.407ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;setup-validate&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;47.271µs&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:13:02.407ZV4----------------------------------</span><br><span class="line">2021-09-23T13:13:02.407ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;bootstrap-cluster-init&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:13:02.407ZV0Creating new bootstrap cluster</span><br><span class="line">2021-09-23T13:13:02.407ZV4Creating kind cluster&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;ricklab-cluster-eks-a-cluster&quot;</span>, <span class="string">&quot;kubeconfig&quot;</span>: <span class="string">&quot;ricklab-cluster/generated/ricklab-cluster.kind.kubeconfig&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:13:47.919ZV4Applying extra objects&#123;<span class="string">&quot;cluster&quot;</span>: <span class="string">&quot;ricklab-cluster&quot;</span>, <span class="string">&quot;resources&quot;</span>: [<span class="string">&quot;core-dns-clusterrole&quot;</span>]&#125;</span><br><span class="line">2021-09-23T13:13:48.319ZV0Installing cluster-api providers on bootstrap cluster</span><br><span class="line">2021-09-23T13:16:06.334ZV0Provider specific setup</span><br><span class="line">2021-09-23T13:16:06.334ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;bootstrap-cluster-init&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;3m3.927762619s&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:16:06.334ZV4----------------------------------</span><br><span class="line">2021-09-23T13:16:06.334ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;workload-cluster-init&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:16:06.335ZV0Creating new workload cluster</span><br><span class="line">2021-09-23T13:16:07.096ZV5Retry execution successful&#123;<span class="string">&quot;retries&quot;</span>: 1, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;760.594964ms&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:16:07.096ZV3Waiting <span class="keyword">for</span> external etcd to be ready</span><br><span class="line">2021-09-23T13:16:22.806ZV3External etcd is ready</span><br><span class="line">2021-09-23T13:16:22.806ZV3Waiting <span class="keyword">for</span> control plane to be ready</span><br><span class="line">2021-09-23T13:17:16.617ZV5Retry execution successful&#123;<span class="string">&quot;retries&quot;</span>: 1, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;278.043187ms&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:17:16.617ZV3Waiting <span class="keyword">for</span> controlplane and worker machines to be ready</span><br><span class="line">2021-09-23T13:17:16.850ZV4Nodes are not ready yet&#123;<span class="string">&quot;total&quot;</span>: 2, <span class="string">&quot;ready&quot;</span>: 1&#125;</span><br><span class="line">2021-09-23T13:17:17.090ZV4Nodes are not ready yet&#123;<span class="string">&quot;total&quot;</span>: 2, <span class="string">&quot;ready&quot;</span>: 1&#125;</span><br><span class="line">2021-09-23T13:17:17.090ZV5Error happened during retry&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;nodes are not ready yet&quot;</span>, <span class="string">&quot;retries&quot;</span>: 1&#125;</span><br><span class="line">2021-09-23T13:17:17.090ZV5Sleeping before next retry&#123;<span class="string">&quot;time&quot;</span>: <span class="string">&quot;1s&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:17:18.331ZV4Nodes are not ready yet&#123;<span class="string">&quot;total&quot;</span>: 2, <span class="string">&quot;ready&quot;</span>: 1&#125;</span><br><span class="line">2021-09-23T13:17:18.331ZV5Error happened during retry&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;nodes are not ready yet&quot;</span>, <span class="string">&quot;retries&quot;</span>: 2&#125;</span><br><span class="line">2021-09-23T13:17:18.331ZV5Sleeping before next retry&#123;<span class="string">&quot;time&quot;</span>: <span class="string">&quot;1s&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">... 略 ...</span><br><span class="line"></span><br><span class="line">2021-09-23T13:18:10.382ZV0Installing storage class on workload cluster</span><br><span class="line">2021-09-23T13:18:10.382ZV0Installing cluster-api providers on workload cluster</span><br><span class="line">2021-09-23T13:20:40.502ZV4Installing machine health checks on bootstrap cluster</span><br><span class="line">2021-09-23T13:20:40.502ZV4Skipping machine health checks</span><br><span class="line">2021-09-23T13:20:40.502ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;workload-cluster-init&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;4m34.167905829s&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:20:40.502ZV4----------------------------------</span><br><span class="line">2021-09-23T13:20:40.502ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;capi-management-move&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:20:40.502ZV0Moving cluster management from bootstrap to workload cluster</span><br><span class="line">2021-09-23T13:20:40.502ZV3Waiting <span class="keyword">for</span> management machines to be ready before move</span><br><span class="line">2021-09-23T13:20:40.774ZV4Nodes ready&#123;<span class="string">&quot;total&quot;</span>: 2&#125;</span><br><span class="line">2021-09-23T13:20:43.420ZV3Waiting <span class="keyword">for</span> control planes to be ready after move</span><br><span class="line">2021-09-23T13:20:44.938ZV3Waiting <span class="keyword">for</span> machines to be ready after move</span><br><span class="line">2021-09-23T13:20:45.239ZV4Nodes ready&#123;<span class="string">&quot;total&quot;</span>: 2&#125;</span><br><span class="line">2021-09-23T13:20:45.239ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;capi-management-move&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;4.736253314s&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:20:45.239ZV4----------------------------------</span><br><span class="line">2021-09-23T13:20:45.239ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;eksa-components-install&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:20:45.239ZV0Installing EKS-A custom components (CRD and controller) on workload cluster</span><br><span class="line">2021-09-23T13:20:46.961ZV5Retry execution successful&#123;<span class="string">&quot;retries&quot;</span>: 1, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;962.076365ms&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:06.898ZV0Creating EKS-A CRDs instances on workload cluster</span><br><span class="line">2021-09-23T13:21:06.898ZV4Applying eksa yaml resources to cluster</span><br><span class="line">2021-09-23T13:21:07.608ZV5Retry execution successful&#123;<span class="string">&quot;retries&quot;</span>: 1, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;710.107178ms&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.015ZV5Retry execution successful&#123;<span class="string">&quot;retries&quot;</span>: 1, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;403.533216ms&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.340ZV5Retry execution successful&#123;<span class="string">&quot;retries&quot;</span>: 1, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;324.587963ms&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.686ZV5Retry execution successful&#123;<span class="string">&quot;retries&quot;</span>: 1, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;346.697543ms&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.686ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;eksa-components-install&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;23.447764425s&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.686ZV4----------------------------------</span><br><span class="line">2021-09-23T13:21:08.687ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;addon-manager-install&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.687ZV0Installing AddonManager and GitOps Toolkit on workload cluster</span><br><span class="line">2021-09-23T13:21:08.687ZV0GitOps field not specified, bootstrap flux skipped</span><br><span class="line">2021-09-23T13:21:08.687ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;addon-manager-install&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;16.609µs&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.687ZV4----------------------------------</span><br><span class="line">2021-09-23T13:21:08.687ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;write-cluster-config&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.687ZV0Writing cluster config file</span><br><span class="line">2021-09-23T13:21:08.687ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;write-cluster-config&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;381.756µs&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.687ZV4----------------------------------</span><br><span class="line">2021-09-23T13:21:08.687ZV4Task start&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;delete-kind-cluster&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:08.687ZV0Deleting bootstrap cluster</span><br><span class="line">2021-09-23T13:21:08.944ZV5Executed kind get clusters&#123;<span class="string">&quot;response&quot;</span>: <span class="string">&quot;dev-cluster\ndev-cluster-eks-a-cluster\nricklab-cluster\nricklab-cluster-eks-a-cluster\n&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:09.549ZV4Deleting kind cluster&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;ricklab-cluster-eks-a-cluster&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:10.918ZV0🎉 Cluster created!</span><br><span class="line">2021-09-23T13:21:10.918ZV4Task finished&#123;<span class="string">&quot;task_name&quot;</span>: <span class="string">&quot;delete-kind-cluster&quot;</span>, <span class="string">&quot;duration&quot;</span>: <span class="string">&quot;2.230882453s&quot;</span>&#125;</span><br><span class="line">2021-09-23T13:21:10.918ZV4----------------------------------</span><br><span class="line">2021-09-23T13:21:10.918ZV4Tasks completed&#123;<span class="string">&quot;duration&quot;</span>: <span class="string">&quot;8m8.511328006s&quot;</span>&#125;</span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>這段 log 可以看到過程詳細的執行資訊，整個過程跑了大約 8 分鐘，這是我已經預先下載 docker images 的狀況，所以建議先下載過 docekr images.</p><blockquote><p>同樣的背景，有一次裝跑了 25m ，同樣是 docker images 預先下載好的狀況。</p></blockquote><h2 id="觀察"><a href="#觀察" class="headerlink" title="觀察"></a>觀察</h2><p>從前述的 detail log 可以發現有以下 tasks:</p><ol><li>setup-validate</li><li>bootstrap-cluster-init</li><li>workload-cluster-init</li><li>capi-management-move</li><li>eksa-components-install</li><li>addon-manager-install</li><li>write-cluster-config</li><li>delete-kind-cluster</li></ol><p>每個步驟背後都是透過 container <code>public.ecr.aws/eks-anywhere/cli-tools:v0.1.0-eks-a-1</code> 在控制與操作，底下是 <code>bootstrap-cluster-init</code> 的過程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-server:~<span class="comment"># docker logs inspiring_chebyshev</span></span><br><span class="line">Creating cluster <span class="string">&quot;ricklab-cluster-eks-a-cluster&quot;</span> ...</span><br><span class="line"> • Ensuring node image (public.ecr.aws/eks-anywhere/kubernetes-sigs/kind/node:v1.21.2-eks-d-1-21-4-eks-a-1) 🖼  ...</span><br><span class="line"> ✓ Ensuring node image (public.ecr.aws/eks-anywhere/kubernetes-sigs/kind/node:v1.21.2-eks-d-1-21-4-eks-a-1) 🖼</span><br><span class="line"> • Preparing nodes 📦   ...</span><br><span class="line"> ✓ Preparing nodes 📦</span><br><span class="line"> • Writing configuration 📜  ...</span><br><span class="line"> ✓ Writing configuration 📜</span><br><span class="line"> • Starting control-plane 🕹️  ...</span><br><span class="line"> ✓ Starting control-plane 🕹️</span><br><span class="line"> • Installing CNI 🔌  ...</span><br><span class="line"> ✓ Installing CNI 🔌</span><br><span class="line"> • Installing StorageClass 💾  ...</span><br><span class="line"> ✓ Installing StorageClass 💾</span><br><span class="line">Set kubectl context to <span class="string">&quot;kind-ricklab-cluster-eks-a-cluster&quot;</span></span><br><span class="line">You can now use your cluster with:</span><br><span class="line"></span><br><span class="line">kubectl cluster-info --context kind-ricklab-cluster-eks-a-cluster --kubeconfig ricklab-cluster/generated/ricklab-cluster.kind.kubeconfig</span><br><span class="line"></span><br><span class="line">Have a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/<span class="comment">#community 🙂</span></span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>過程中比較花時間的是這個 <code>Waiting for cert-manager to be available</code> 的 task，過程在等待啥東西，我沒找到原因，Github 上的 <a href="https://github.com/aws/eks-anywhere/issues/261">Issue</a> 目前 (2021&#x2F;09&#x2F;23) 還是 Open 的狀態。。。他的 Log 如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-server:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE                                                                                COMMAND                  CREATED              STATUS              PORTS                       NAMES</span><br><span class="line">66edc1f9a3d9   public.ecr.aws/eks-anywhere/cli-tools:v0.1.0-eks-a-1                                 <span class="string">&quot;clusterctl init --c…&quot;</span>   38 seconds ago       Up 37 seconds                                   serene_hopper</span><br><span class="line">57932fdcc915   public..../node:v1.21.2-eks-d-1-21-4-eks-a-1   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   About a minute ago   Up About a minute   127.0.0.1:42309-&gt;6443/tcp   dev-cluster-eks-a-cluster-control-plane</span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment"># docker logs -f serene_hopper</span></span><br><span class="line">Fetching providers</span><br><span class="line">Using Override=<span class="string">&quot;core-components.yaml&quot;</span> Provider=<span class="string">&quot;cluster-api&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span></span><br><span class="line">Using Override=<span class="string">&quot;bootstrap-components.yaml&quot;</span> Provider=<span class="string">&quot;bootstrap-kubeadm&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span></span><br><span class="line">Using Override=<span class="string">&quot;bootstrap-components.yaml&quot;</span> Provider=<span class="string">&quot;bootstrap-etcdadm-bootstrap&quot;</span> Version=<span class="string">&quot;v0.1.0-beta-4.1&quot;</span></span><br><span class="line">Using Override=<span class="string">&quot;bootstrap-components.yaml&quot;</span> Provider=<span class="string">&quot;bootstrap-etcdadm-controller&quot;</span> Version=<span class="string">&quot;v0.1.0-beta-4.1&quot;</span></span><br><span class="line">Using Override=<span class="string">&quot;control-plane-components.yaml&quot;</span> Provider=<span class="string">&quot;control-plane-kubeadm&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span></span><br><span class="line">Using Override=<span class="string">&quot;infrastructure-components-development.yaml&quot;</span> Provider=<span class="string">&quot;infrastructure-docker&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span></span><br><span class="line">Installing cert-manager Version=<span class="string">&quot;v1.1.0&quot;</span></span><br><span class="line">Waiting <span class="keyword">for</span> cert-manager to be available...</span><br><span class="line">Installing Provider=<span class="string">&quot;cluster-api&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span> TargetNamespace=<span class="string">&quot;capi-system&quot;</span></span><br><span class="line">Installing Provider=<span class="string">&quot;bootstrap-kubeadm&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span> TargetNamespace=<span class="string">&quot;capi-kubeadm-bootstrap-system&quot;</span></span><br><span class="line">Installing Provider=<span class="string">&quot;bootstrap-etcdadm-bootstrap&quot;</span> Version=<span class="string">&quot;v0.1.0-beta-4.1&quot;</span> TargetNamespace=<span class="string">&quot;etcdadm-bootstrap-provider-system&quot;</span></span><br><span class="line">Installing Provider=<span class="string">&quot;bootstrap-etcdadm-controller&quot;</span> Version=<span class="string">&quot;v0.1.0-beta-4.1&quot;</span> TargetNamespace=<span class="string">&quot;etcdadm-controller-system&quot;</span></span><br><span class="line">Installing Provider=<span class="string">&quot;control-plane-kubeadm&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span> TargetNamespace=<span class="string">&quot;capi-kubeadm-control-plane-system&quot;</span></span><br><span class="line">Installing Provider=<span class="string">&quot;infrastructure-docker&quot;</span> Version=<span class="string">&quot;v0.3.23&quot;</span> TargetNamespace=<span class="string">&quot;capd-system&quot;</span></span><br><span class="line"></span><br><span class="line">Your management cluster has been initialized successfully!</span><br><span class="line"></span><br><span class="line">You can now create your first workload cluster by running the following:</span><br><span class="line"></span><br><span class="line">  clusterctl config cluster [name] --kubernetes-version [version] | kubectl apply -f -</span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>底下是其他 task 的 logs 觀察，因為 container name 沒有用 task name ，所以看不出來是哪個 task：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-server:~<span class="comment"># docker logs -f cool_mcclintock</span></span><br><span class="line">deployment.apps/capi-kubeadm-bootstrap-controller-manager condition met</span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment"># docker logs -f zealous_mclaren</span></span><br><span class="line">deployment.apps/capd-controller-manager condition met</span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment"># docker logs -f cranky_bouman</span></span><br><span class="line">cluster.cluster.x-k8s.io/dev-cluster condition met</span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment"># docker logs -f cranky_hofstadter</span></span><br><span class="line">cluster.cluster.x-k8s.io/dev-cluster condition met</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最後查看 <code>etcd</code> 的 Logs：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-server:~<span class="comment"># docker logs ricklab-cluster-etcd-cjvzj</span></span><br><span class="line">INFO: ensuring we can execute mount/umount even with userns-remap</span><br><span class="line">INFO: remounting /sys read-only</span><br><span class="line">INFO: making mounts shared</span><br><span class="line">INFO: detected cgroup v1</span><br><span class="line">INFO: fix cgroup mounts <span class="keyword">for</span> all subsystems</span><br><span class="line">INFO: clearing and regenerating /etc/machine-id</span><br><span class="line">Initializing machine ID from random generator.</span><br><span class="line">INFO: faking /sys/class/dmi/id/product_name to be <span class="string">&quot;kind&quot;</span></span><br><span class="line">INFO: faking /sys/class/dmi/id/product_uuid to be random</span><br><span class="line">INFO: faking /sys/devices/virtual/dmi/id/product_uuid as well</span><br><span class="line">INFO: setting iptables to detected mode: legacy</span><br><span class="line">INFO: Detected IPv4 address: 172.18.0.4</span><br><span class="line">INFO: Detected IPv6 address: fc00:f853:ccd:e793::4</span><br><span class="line"></span><br><span class="line">Welcome to Amazon Linux 2!</span><br><span class="line"></span><br><span class="line">[  OK  ] Set up automount Arbitrary Executab...ats File System Automount Point.</span><br><span class="line">[  OK  ] Reached target Local File Systems.</span><br><span class="line">[  OK  ] Reached target Swap.</span><br><span class="line">[  OK  ] Started Dispatch Password Requests to Console Directory Watch.</span><br><span class="line">[  OK  ] Reached target Paths.</span><br><span class="line">[  OK  ] Created slice Root Slice.</span><br><span class="line"></span><br><span class="line">... 略 ...</span><br><span class="line"></span><br><span class="line">         Starting Create Static Device Nodes <span class="keyword">in</span> /dev...</span><br><span class="line">         Starting Flush Journal to Persistent Storage...</span><br><span class="line">[  OK  ] Started Create Static Device Nodes <span class="keyword">in</span> /dev.</span><br><span class="line">[  OK  ] Started Update UTMP about System Boot/Shutdown.</span><br><span class="line">[  OK  ] Started Flush Journal to Persistent Storage.</span><br><span class="line">[  OK  ] Started Rebuild Hardware Database.</span><br><span class="line">         Starting Update is Completed...</span><br><span class="line">[  OK  ] Started Update is Completed.</span><br><span class="line">[  OK  ] Reached target System Initialization.</span><br><span class="line">[  OK  ] Started Daily Cleanup of Temporary Directories.</span><br><span class="line">[  OK  ] Reached target Timers.</span><br><span class="line">[  OK  ] Listening on D-Bus System Message Bus Socket.</span><br><span class="line">[  OK  ] Reached target Sockets.</span><br><span class="line">[  OK  ] Reached target Basic System.</span><br><span class="line">         Starting containerd container runtime...</span><br><span class="line">         Starting Cleanup of Temporary Directories...</span><br><span class="line">[  OK  ] Started Cleanup of Temporary Directories.</span><br><span class="line">[  OK  ] Started containerd container runtime.</span><br><span class="line">[  OK  ] Reached target Multi-User System.</span><br><span class="line">[  OK  ] Reached target Graphical Interface.</span><br><span class="line">         Starting Update UTMP about System Runlevel Changes...</span><br><span class="line">[  OK  ] Started Update UTMP about System Runlevel Changes.</span><br></pre></td></tr></table></figure><p>最後觀察 <code>docker ps</code> 建立那一些 container:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu-server:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE                                                                                COMMAND                  CREATED          STATUS          PORTS                                  NAMES</span><br><span class="line">2e432b89f3f8   public.ecr.aws/eks-anywhere/kubernetes-sigs/kind/node:v1.21.2-eks-d-1-21-4-eks-a-1   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   13 minutes ago   Up 13 minutes                                          ricklab-cluster-md-0-76b7b5578c-zhs7d</span><br><span class="line">d0e7ac20a689   public.ecr.aws/eks-anywhere/kubernetes-sigs/kind/node:v1.21.2-eks-d-1-21-4-eks-a-1   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   14 minutes ago   Up 14 minutes   34917/tcp, 127.0.0.1:34917-&gt;6443/tcp   ricklab-cluster-4n42d</span><br><span class="line">a18287b7d33d   public.ecr.aws/eks-anywhere/kubernetes-sigs/kind/node:v1.21.2-eks-d-1-21-4-eks-a-1   <span class="string">&quot;/usr/local/bin/entr…&quot;</span>   14 minutes ago   Up 14 minutes                                          ricklab-cluster-etcd-cjvzj</span><br><span class="line">7c95c9a2a15a   kindest/haproxy:v20210715-a6da3463                                                   <span class="string">&quot;haproxy -sf 7 -W -d…&quot;</span>   14 minutes ago   Up 14 minutes   45713/tcp, 0.0.0.0:45713-&gt;6443/tcp     ricklab-cluster-lb</span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>裡面包含了:</p><ul><li><code>control plane</code>: ricklab-cluster-4n42d</li><li><code>worker node</code>: ricklab-cluster-md-0-76b7b5578c-zhs7d</li><li><code>etced</code>: ricklab-cluster-etcd-cjvzj</li><li><code>load balance</code>: haproxy -&gt; 實際上並不是 ingress controller.</li></ul><h2 id="驗證-Cluster"><a href="#驗證-Cluster" class="headerlink" title="驗證 Cluster"></a>驗證 Cluster</h2><p>確認 cluster 是否正常運作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CLUSTER_NAME=<span class="string">&quot;ricklab-cluster&quot;</span></span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=<span class="variable">$&#123;HOME&#125;</span>/<span class="variable">$&#123;CLUSTER_NAME&#125;</span>/<span class="variable">$&#123;CLUSTER_NAME&#125;</span>-eks-a-cluster.kubeconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得 componentstatus (cs)</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl get cs</span></span><br><span class="line">Warning: v1 ComponentStatus is deprecated <span class="keyword">in</span> v1.19+</span><br><span class="line">NAME                 STATUS      MESSAGE                                                                                       ERROR</span><br><span class="line">scheduler            Unhealthy   Get <span class="string">&quot;http://127.0.0.1:10251/healthz&quot;</span>: dial tcp 127.0.0.1:10251: connect: connection refused</span><br><span class="line">controller-manager   Unhealthy   Get <span class="string">&quot;http://127.0.0.1:10252/healthz&quot;</span>: dial tcp 127.0.0.1:10252: connect: connection refused</span><br><span class="line">etcd-0               Healthy     &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 如果狀態跟上面一樣有問題，請參閱這份文件調整:  https://my.oschina.net/u/1431757/blog/4550843</span></span><br><span class="line"><span class="comment">## 正常如下：</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl get cs</span></span><br><span class="line">Warning: v1 ComponentStatus is deprecated <span class="keyword">in</span> v1.19+</span><br><span class="line">NAME                 STATUS    MESSAGE             ERROR</span><br><span class="line">controller-manager   Healthy   ok</span><br><span class="line">etcd-0               Healthy   &#123;<span class="string">&quot;health&quot;</span>:<span class="string">&quot;true&quot;</span>&#125;</span><br><span class="line">scheduler            Healthy   ok</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取的 api-resources</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl api-resources</span></span><br><span class="line">NAME                              SHORTNAMES     APIVERSION                                     NAMESPACED   KIND</span><br><span class="line">bindings                                         v1                                             <span class="literal">true</span>         Binding</span><br><span class="line">componentstatuses                 cs             v1                                             <span class="literal">false</span>        ComponentStatus</span><br><span class="line">configmaps                        cm             v1                                             <span class="literal">true</span>         ConfigMap</span><br><span class="line">endpoints                         ep             v1                                             <span class="literal">true</span>         Endpoints</span><br><span class="line"></span><br><span class="line">... 略 ...</span><br><span class="line"></span><br><span class="line">namespaces                        ns             v1                                             <span class="literal">false</span>        Namespace</span><br><span class="line">nodes                             no             v1                                             <span class="literal">false</span>        Node</span><br><span class="line">persistentvolumeclaims            pvc            v1                                             <span class="literal">true</span>         PersistentVolumeClaim</span><br><span class="line"></span><br><span class="line">... 略 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得目前的 namespaces</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME                                STATUS   AGE</span><br><span class="line">capd-system                         Active   17m</span><br><span class="line">capi-kubeadm-bootstrap-system       Active   17m</span><br><span class="line">capi-kubeadm-control-plane-system   Active   17m</span><br><span class="line">capi-system                         Active   17m</span><br><span class="line">capi-webhook-system                 Active   17m</span><br><span class="line">cert-manager                        Active   18m</span><br><span class="line">default                             Active   19m</span><br><span class="line">eksa-system                         Active   16m</span><br><span class="line">etcdadm-bootstrap-provider-system   Active   17m</span><br><span class="line">etcdadm-controller-system           Active   17m</span><br><span class="line">kube-node-lease                     Active   19m</span><br><span class="line">kube-public                         Active   19m</span><br><span class="line">kube-system                         Active   19m</span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得目前的 nodes 狀態</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl get node -o wide</span></span><br><span class="line">NAME                                    STATUS   ROLES                  AGE   VERSION              INTERNAL-IP   EXTERNAL-IP   OS-IMAGE         KERNEL-VERSION     CONTAINER-RUNTIME</span><br><span class="line">ricklab-cluster-4n42d                   Ready    control-plane,master   17m   v1.21.2-eks-1-21-4   172.18.0.5    &lt;none&gt;        Amazon Linux 2   5.4.0-84-generic   containerd://1.4.6</span><br><span class="line">ricklab-cluster-md-0-76b7b5578c-zhs7d   Ready    &lt;none&gt;                 16m   v1.21.2-eks-1-21-4   172.18.0.6    &lt;none&gt;        Amazon Linux 2   5.4.0-84-generic   containerd://1.4.6</span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取的 pod</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl get pod --all-namespaces</span></span><br><span class="line">NAMESPACE                           NAME                                                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">capd-system                         capd-controller-manager-659dd5f8bc-bnp5m                         2/2     Running   0          15m</span><br><span class="line">capi-kubeadm-bootstrap-system       capi-kubeadm-bootstrap-controller-manager-69889cb844-ndxsp       2/2     Running   0          15m</span><br><span class="line">capi-kubeadm-control-plane-system   capi-kubeadm-control-plane-controller-manager-6ddc66fb75-mhmn7   2/2     Running   0          15m</span><br><span class="line">capi-system                         capi-controller-manager-db59f5789-w9dvp                          2/2     Running   0          15m</span><br><span class="line">capi-webhook-system                 capi-controller-manager-64b8c548db-wv6mz                         2/2     Running   0          15m</span><br><span class="line">capi-webhook-system                 capi-kubeadm-bootstrap-controller-manager-68b8cc9759-75l4p       2/2     Running   0          15m</span><br><span class="line">capi-webhook-system                 capi-kubeadm-control-plane-controller-manager-7dc88f767d-7cx4l   2/2     Running   0          15m</span><br><span class="line">cert-manager                        cert-manager-5f6b885b4-gcf95                                     1/1     Running   0          16m</span><br><span class="line">cert-manager                        cert-manager-cainjector-bb6d9bcb5-rrp7b                          1/1     Running   0          16m</span><br><span class="line">cert-manager                        cert-manager-webhook-56cbc8f5b8-2767z                            1/1     Running   0          16m</span><br><span class="line">eksa-system                         eksa-controller-manager-6769764b45-jv5q9                         2/2     Running   0          14m</span><br><span class="line">etcdadm-bootstrap-provider-system   etcdadm-bootstrap-provider-controller-manager-54476b7bf9-qgblp   2/2     Running   0          15m</span><br><span class="line">etcdadm-controller-system           etcdadm-controller-controller-manager-d5795556-bxsb2             2/2     Running   0          15m</span><br><span class="line">kube-system                         cilium-7gkp5                                                     1/1     Running   0          16m</span><br><span class="line">kube-system                         cilium-bq8pk                                                     1/1     Running   0          16m</span><br><span class="line">kube-system                         cilium-operator-6bf46cc6c6-56wn2                                 1/1     Running   0          16m</span><br><span class="line">kube-system                         cilium-operator-6bf46cc6c6-lkxrn                                 1/1     Running   0          16m</span><br><span class="line">kube-system                         coredns-7c68f85774-2pnxk                                         1/1     Running   0          17m</span><br><span class="line">kube-system                         coredns-7c68f85774-m7f99                                         1/1     Running   0          17m</span><br><span class="line">kube-system                         kube-apiserver-ricklab-cluster-4n42d                             1/1     Running   0          17m</span><br><span class="line">kube-system                         kube-controller-manager-ricklab-cluster-4n42d                    1/1     Running   0          17m</span><br><span class="line">kube-system                         kube-proxy-mnrtv                                                 1/1     Running   0          17m</span><br><span class="line">kube-system                         kube-proxy-sl6sq                                                 1/1     Running   0          16m</span><br><span class="line">kube-system                         kube-scheduler-ricklab-cluster-4n42d                             1/1     Running   0          17m</span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>CRI: containerd</li><li>OS-Image: Amazon Linux 2</li><li>CNI: cilium</li></ul><h2 id="用-Rancher-觀察"><a href="#用-Rancher-觀察" class="headerlink" title="用 Rancher 觀察"></a>用 Rancher 觀察</h2><p>把 cluster 匯入 Rancher 查看，底下是 Node 和 Pod 的狀況</p><p><img src="/images/AWS/EKS/Anywhere/rancher_nodes.png"></p><p><img src="/images/AWS/EKS/Anywhere/rancher_pod.png"></p><h2 id="Deploy-an-application"><a href="#Deploy-an-application" class="headerlink" title="Deploy an application"></a>Deploy an application</h2><p>部署官方提供的應用範例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f <span class="string">&quot;https://anywhere.eks.amazonaws.com/manifests/hello-eks-a.yaml&quot;</span></span><br><span class="line"></span><br><span class="line">kubectl get pods -l app=hello-eks-a</span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl logs -l app=hello-eks-a</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: using the &quot;epoll&quot; event method</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: nginx/1.21.1</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: built by gcc 10.3.1 20210424 (Alpine 10.3.1_git20210424)</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: OS: Linux 5.4.0-84-generic</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: start worker processes</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: start worker process 39</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: start worker process 40</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: start worker process 41</span></span><br><span class="line">2021/09/21 15:07:07 [notice] 1<span class="comment">#1: start worker process 42</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@ubuntu-server:~<span class="comment"># kubectl port-forward deploy/hello-eks-a 8000:80</span></span><br><span class="line">Forwarding from 127.0.0.1:8000 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8000 -&gt; 80</span><br><span class="line">Handling connection <span class="keyword">for</span> 8000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 測試</span></span><br><span class="line">root@ubuntu-server:~<span class="comment"># curl http://localhost:8000</span></span><br><span class="line">⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢</span><br><span class="line"></span><br><span class="line">Thank you <span class="keyword">for</span> using</span><br><span class="line"></span><br><span class="line">███████╗██╗  ██╗███████╗</span><br><span class="line">██╔════╝██║ ██╔╝██╔════╝</span><br><span class="line">█████╗  █████╔╝ ███████╗</span><br><span class="line">██╔══╝  ██╔═██╗ ╚════██║</span><br><span class="line">███████╗██║  ██╗███████║</span><br><span class="line">╚══════╝╚═╝  ╚═╝╚══════╝</span><br><span class="line"></span><br><span class="line"> █████╗ ███╗   ██╗██╗   ██╗██╗    ██╗██╗  ██╗███████╗██████╗ ███████╗</span><br><span class="line">██╔══██╗████╗  ██║╚██╗ ██╔╝██║    ██║██║  ██║██╔════╝██╔══██╗██╔════╝</span><br><span class="line">███████║██╔██╗ ██║ ╚████╔╝ ██║ █╗ ██║███████║█████╗  ██████╔╝█████╗</span><br><span class="line">██╔══██║██║╚██╗██║  ╚██╔╝  ██║███╗██║██╔══██║██╔══╝  ██╔══██╗██╔══╝</span><br><span class="line">██║  ██║██║ ╚████║   ██║   ╚███╔███╔╝██║  ██║███████╗██║  ██║███████╗</span><br><span class="line">╚═╝  ╚═╝╚═╝  ╚═══╝   ╚═╝    ╚══╝╚══╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝</span><br><span class="line"></span><br><span class="line">You have successfully deployed the hello-eks-a pod hello-eks-a-9644dd8dc-fn4vk</span><br><span class="line"></span><br><span class="line">For more information check out</span><br><span class="line">https://anywhere.eks.amazonaws.com</span><br><span class="line"></span><br><span class="line">⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢⬡⬢</span><br><span class="line">root@ubuntu-server:~<span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="刪除-Cluster"><a href="#刪除-Cluster" class="headerlink" title="刪除 Cluster"></a>刪除 Cluster</h2><p>有頭有尾，官方文件說用以下刪除 clsuter</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CLUSTER_NAME=<span class="string">&quot;ricklab-cluster&quot;</span></span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=<span class="variable">$&#123;HOME&#125;</span>/<span class="variable">$&#123;CLUSTER_NAME&#125;</span>/<span class="variable">$&#123;CLUSTER_NAME&#125;</span>-eks-a-cluster.kubeconfig</span><br><span class="line"></span><br><span class="line">eksctl anywhere delete cluster <span class="variable">$&#123;CLUSTER_NAME&#125;</span></span><br><span class="line"></span><br><span class="line">Performing provider setup and validations</span><br><span class="line">Creating management cluster</span><br><span class="line">Installing cluster-api providers on management cluster</span><br><span class="line">Moving cluster management from workload cluster</span><br><span class="line">Deleting workload cluster</span><br><span class="line">Clean up Git Repo</span><br><span class="line">GitOps field not specified, clean up git repo skipped</span><br><span class="line">🎉 Cluster deleted!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我實際上都直接砍了 docker container 比較快 XD</p><h1 id="Q-and-A"><a href="#Q-and-A" class="headerlink" title="Q and A"></a>Q and A</h1><ul><li>Q: Local Cluster 建議的硬體資源是多少？</li></ul><blockquote><p>底下是官方給的資訊：</p><ul><li>Docker 20.x.x</li><li>Mac OS (10.15) &#x2F; Ubuntu (20.04.2 LTS)</li><li>4 CPU cores</li><li>16GB memory</li><li>30GB free disk space</li></ul><p>實際上則看使用需求而言。</p></blockquote><ul><li>Q: 為什麼會需要用 EKS Anywhere？</li></ul><blockquote><p>針對如果要使用像是 <code>IRSA</code> 做 AuthN、AuthZ ，或者 <code>OIDC</code> 管理帳號，</p><p>我個人之所以想試看看 EKS Anywhere 主要是因為公司的環境都以 EKS 為主，而我在部門內部有一台 PC 當 Lab 環境，我裝了 Proxmox，上面我手動用 <a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">kubeadm</a> 裝了整個環境讓團隊練習使用。雖然我算是很熟練整個安裝過程，但如果要交給其他成員維護的話，還是有些難度。另外我們使用 EKS 的 IRSA 做管理，所以我也希望能夠讓 Lab 環境跟線上環境更一致。</p></blockquote><!--* Q: 如何新增 worker node?--><ul><li>Q: 如何讓外面存取 cluster?</li></ul><blockquote><p>範例中的 <code>$&#123;HOME&#125;/$&#123;CLUSTER_NAME&#125;/$&#123;CLUSTER_NAME&#125;-eks-a-cluster.kubeconfig</code> 裡面的 <code>server: https://127.0.0.1:43835</code> 是本機位置，修改成機器 (host machine) 的 IP 就可以從外面操作了。</p></blockquote><ul><li>Q: 誰適合使用 EKS Anywhere？</li></ul><blockquote><p>K8s 的使用者有兩個面向：<code>1) 使用容器</code>、<code>2) 管理容器平台</code>，這是兩個不同使用者導向的設計，更多參閱 <a href="https://speakerdeck.com/pichuang/20210824-yun-yuan-sheng-ren-cai-xun-zhao-de-nan-chu-ji-chang-jian-wu-qu-tan-tao?slide=12">雲原生人才尋找的難處及常見誤區探討, P12-13</a>。而 EKS Anywhere 我覺得是後者，也就是設計給 <code>管理容器平台</code> 的人。設計給使用容器的 K8s 平台，大概就是 minikube、microK8s、K3d 之類的。</p></blockquote><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><h2 id="站內文章：K8s-相關"><a href="#站內文章：K8s-相關" class="headerlink" title="站內文章：K8s 相關"></a>站內文章：K8s 相關</h2><ul><li><a href="/2017/07/15/Container/Experience-minikube/">Experience minikube</a></li><li><a href="/2021/09/23/AWS/Experience-EKS-Anywhere/">Experience EKS Anywhere</a></li><li><a href="/2019/03/17/Container/Install-K8s-with-Kubeadm/">K8s 學習筆記 - kubeadm 手動安裝</a></li><li><a href="/2019/03/17/Container/Install-Addons-For-K8s/">K8s 學習筆記 - 工具篇</a></li><li><a href="/2019/03/17/Container/Admin-Maintenance-And-Troubleshooting-K8s/">K8s 學習筆記 - 維護與常見問題</a></li><li><a href="/2019/10/13/AWS/Study-Notes-EKS_Provision-Cluster/">EKS 學習筆記 - 基礎安裝篇</a></li><li><a href="/2019/10/19/AWS/Study-Notes-EKS_Networking/">EKS 學習筆記 - 網路規劃與管理篇</a></li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://anywhere.eks.amazonaws.com/docs/getting-started/install/">EKS Anywhere</a></li><li><a href="https://aws.amazon.com/tw/blogs/aws/amazon-eks-anywhere-now-generally-available-to-create-and-manage-kubernetes-clusters-on-premises/">Amazon EKS Anywhere – Now Generally Available to Create and Manage Kubernetes Clusters on Premises</a></li><li><a href="https://speakerdeck.com/pichuang/20210824-yun-yuan-sheng-ren-cai-xun-zhao-de-nan-chu-ji-chang-jian-wu-qu-tan-tao?slide=12">雲原生人才尋找的難處及常見誤區探討</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;AWS 把 EKS 本身開源了，稱為 &lt;code&gt;EKS Anywhere&lt;/code&gt;，除了在 AWS 自己之外，也可以安裝在私有 (on-premises) 的環境。&lt;/p&gt;
&lt;p&gt;本文整理體驗的筆記，我在 macOS、ubuntu20.04 都有做過，本文記錄則以 ubuntu 20.04 為主，內容以參考 &lt;a href=&quot;https://anywhere.eks.amazonaws.com/docs/getting-started/install/&quot;&gt;EKS Anywhere&lt;/a&gt; 官方文件為主。&lt;/p&gt;</summary>
    
    
    
    <category term="AWS" scheme="https://rickhw.github.io/categories/AWS/"/>
    
    
    <category term="Linux" scheme="https://rickhw.github.io/tags/Linux/"/>
    
    <category term="EKS" scheme="https://rickhw.github.io/tags/EKS/"/>
    
    <category term="Docker" scheme="https://rickhw.github.io/tags/Docker/"/>
    
    <category term="VMWare" scheme="https://rickhw.github.io/tags/VMWare/"/>
    
    <category term="K8s" scheme="https://rickhw.github.io/tags/K8s/"/>
    
    <category term="IRSA" scheme="https://rickhw.github.io/tags/IRSA/"/>
    
  </entry>
  
  <entry>
    <title>職涯、探索、退休</title>
    <link href="https://rickhw.github.io/2021/09/10/About/Self-Exploration/"/>
    <id>https://rickhw.github.io/2021/09/10/About/Self-Exploration/</id>
    <published>2021-09-10T04:39:00.000Z</published>
    <updated>2022-12-19T11:47:28.852Z</updated>
    
    <content type="html"><![CDATA[<p>一直以來，都有朋友會找我聊 <code>職涯規劃</code> 的問題，整理幾段我敲在 <a href="https://www.facebook.com/rick.kyhwang/posts/10215716222817975">Facebook</a> 上的隨筆</p><ul><li><a href="https://www.facebook.com/rick.kyhwang/posts/10215716222817975">2021&#x2F;06&#x2F;25: 談探索自我</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/10211086815805693">2019&#x2F;04&#x2F;21: 談退休</a></li></ul><p>內容以職涯角度切入，談的是 <code>探索自己</code>，然後延伸到 <code>生死</code>、<code>退休</code> … 等。</p><span id="more"></span><hr><h1 id="探索自己-2021-x2F-06-x2F-25"><a href="#探索自己-2021-x2F-06-x2F-25" class="headerlink" title="探索自己 (2021&#x2F;06&#x2F;25)"></a>探索自己 (2021&#x2F;06&#x2F;25)</h1><p>最近跟幾個朋友聊到職涯，通常最後我都會聊到一個話題：</p><blockquote><p>探索自己、了解自己、找人生的方向</p></blockquote><h2 id="經歷與際遇"><a href="#經歷與際遇" class="headerlink" title="經歷與際遇"></a>經歷與際遇</h2><p>有的人，人生的每個階段要的東西不一樣，<br>隨著經歷、遭遇、心境，而改變；<br>有的人，一輩子，都很清楚知道自己要什麼，<br>可能是小時候的環境在心裡種下的因，<br>可能是一個人生重大的經歷，改變了信念，<br>可能是信仰，成就方向，<br>也有可能是以上的結合。</p><p>了解自己，<br>知道自己想要的是什麼之後，<br>下一步是 <code>認清事實</code>。</p><h2 id="認識世界、認清事實"><a href="#認識世界、認清事實" class="headerlink" title="認識世界、認清事實"></a>認識世界、認清事實</h2><p>認清事實就是自己想要的，<br>跟外面現實世界的距離有多大？<br>現在所處的環境是怎樣的狀況？<br>有沒有適當的位置？<br>或者，理想的位置？<br>或者，可以創造的位置？</p><p>『認識事實』的意思是，<br>自己能否接受？<br>接受什麼？<br>自己想要的，這輩子有沒機會做到？<br>或者沒做到，會不會後悔？<br>或者外在條件根本無法讓你有機會去伸展？<br>或者，需要有貴人的協助？<br>或者，自己去創造條件（環境）？</p><p>認清這些東西，<br>下一步就是，那自己先在離那裡有多遠？<br>缺什麼？是能力（技能）？<br>還是機會？還是舞台？<br>還是貴人？</p><p>能力可以靠時間養成，<br>靠學習成長，刻意練習，<br>重點是持之以恆。</p><h2 id="機會"><a href="#機會" class="headerlink" title="機會"></a>機會</h2><p>機會本身就是個隨機的概念，<br>有技能不見得有機會發會<br>或者反過來，機會來了，但根本沒那個能力；<br>或者機會擺在你眼前，你也不知道。<br>要能判斷這是否是個機會？是否要抓住。</p><p>不管是機會，還是舞台，<br>最重要的是你想往哪裡去？<br>方向是什麼？</p><hr><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>方向 是一個大題目，<br>人生的大方向、階段性的方向。</p><p>方向這件事情，是有點運氣成分的，<br>不是每個人都找得到，<br>我不認為每個人這一輩子都能夠找到方向，<br>或者這一輩子的方向都不會改變。</p><p>一些創業家，很年輕就找到方向，<br>立志創業，然後知道自己要做什麼，<br>一直堅持二三十年的，是很少的。<br>很多人遇到一點挫折，就放棄了。<br>一些創業者可能到四五十歲才創業，<br>才找到方向。</p><p>所以當找不到方向的時候，<br>不要覺得是自己的問題，<br>或者否決掉自己的努力。<br>有些人的方向是因緣際會產生的，他不得不；<br>有些人很早就了解自己要什麼，<br>他剛好有那樣的天時地利人和，剛好有那樣的機會。<br>有些時候方向是靠大家一起想、<br>一起討論、一起激盪出來，一起完成的。</p><p>很多人可能一輩子，<br>都不知道自己喜歡什麼、擅長什麼。<br>有人知道自己喜歡什麼，但卻不擅長；<br>相反的，有人知道自己擅長什麼，<br>但卻不見得喜歡。</p><p>方向不是寫一本書、講一場演講、<br>開一家公司、賺一億 …. 這種，方向或許可以抽像成這樣的想法：</p><ul><li>解決問題</li><li>創造價值</li></ul><p>助人解決困難的問題，<br>進而取得成就，每一次解決問題都是一個里程碑，<br>讓任務順利完成、事情順利走完。<br>因為創造新的事物，<br>帶來新的價值與改變，影響很多人事物。</p><h2 id="了解自己"><a href="#了解自己" class="headerlink" title="了解自己"></a>了解自己</h2><p>回到一開始，<br>你夠了解自己嗎？<br>知道自己要什麼嗎？<br>探索自己內心真正的聲音？<br>你是誰？<br>你在哪裡？<br>你要往哪裡去？</p><hr><h1 id="喜歡跟興趣-2019-x2F-08-x2F-07"><a href="#喜歡跟興趣-2019-x2F-08-x2F-07" class="headerlink" title="喜歡跟興趣 (2019&#x2F;08&#x2F;07)"></a>喜歡跟興趣 (2019&#x2F;08&#x2F;07)</h1><p><img src="/images/About/20190807.jpeg"></p><hr><h1 id="談退休-2019-x2F-04-x2F-21"><a href="#談退休-2019-x2F-04-x2F-21" class="headerlink" title="談退休 (2019&#x2F;04&#x2F;21)"></a>談退休 (2019&#x2F;04&#x2F;21)</h1><p>跟朋友聊到 <code>退休</code> 的議題，我腦袋就是這場演講的內容。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/-bGUUhI80Ks" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>我常常問一個問題：</p><blockquote><p>假設不缺錢，身體健康，不需要工作，你最想做什麼？</p></blockquote><p>大部分的人工作為的是錢，除了錢之外呢？你的生命每天有一半以上的時間在工作，下班每天有八小時在睡覺，扣掉民生必需時間 2-3 小時，跟親友相處的時間只有 1-2 小時，跟最親愛的人相處的時間可能只有一小時（除了睡覺）。</p><p>那麼你人生的意義是什麼？</p><p>退休了，不缺錢，有時間，有體力？聽過太多不切實際的想法，像是：環遊世界、學樂器、含飴弄孫、看書、學 OOXX …</p><p>說得直白點：</p><ul><li>你有體力環遊世界？你知道什麼叫舟車勞頓？你有那個知識去探索世界？還是只是走馬看花？另一半願意跟你跑？有辦法跑？</li><li>學樂器：這我聽過最多的，大多我都是勸退的，最重要的是不會欣賞。因為學樂器是很苦的，想要有成就感不要學樂器，而是學攝影。</li><li>含飴弄孫：那要確定你能跟小孩好好溝通，可能你連跟同學都不知道要聊什麼了</li><li>看書：看一輩子？平常閱讀習慣？能看長篇文字？現代人的閱讀能力我是打問號的</li><li>學 OOXX ：醒醒吧阿宅</li></ul><p>寫這段是因為，看過很多長輩（&gt;60y），整天不知道做什麼，整天罵政府、出一張嘴。誇自己有年輕時有多厲害，然後呢？現在在做什麼？請問今年做了什麼？影響年輕人什麼？</p><p>有一篇文章說：</p><blockquote><p>很多人三十歲就死了，只是七十歲才埋葬，一堆活死人整天在街上走。</p></blockquote><p>而吳念真這段說得很好，做自己想做的事，然後永不止息，保持熱忱，死在喜歡的事情上。</p><p>然後 <code>幾歲</code> 這件事情從來都不是問題，唯一的問題是你沒有想完成的事，你不知道走這一遭的目的是什麼。</p><hr><h1 id="生死、關係"><a href="#生死、關係" class="headerlink" title="生死、關係"></a>生死、關係</h1><p>另外幾篇先不貼上來，可能會比較沈重的，談的是 <code>生死</code>、<code>人際關係</code>，我寫的比較直接，有興趣的朋友可以點過去看。</p><ul><li><a href="https://www.facebook.com/rick.kyhwang/posts/10215751405857529">2021&#x2F;07&#x2F;04: 談生死、退休</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/10214113237664348">2020&#x2F;08&#x2F;19: 關係的層次</a></li></ul><hr><h1 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h1><ul><li><a href="/2017/09/20/About/Learning-Approaches/">學習法則</a></li></ul><h2 id="Facebook-隨筆"><a href="#Facebook-隨筆" class="headerlink" title="Facebook 隨筆"></a>Facebook 隨筆</h2><ul><li><a href="https://www.facebook.com/rick.kyhwang/posts/10215716222817975">2021&#x2F;06&#x2F;25: 談探索自我</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/10215751405857529">2021&#x2F;07&#x2F;04: 談生死、退休</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/10214113237664348">2020&#x2F;08&#x2F;19: 關係的層次</a></li><li><a href="https://www.facebook.com/rick.kyhwang/posts/10211086815805693">2019&#x2F;04&#x2F;21: 談退休</a></li><li><a href="https://www.facebook.com/notes/10214559371657419/">2009&#x2F;08&#x2F;26: 退休規劃</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直以來，都有朋友會找我聊 &lt;code&gt;職涯規劃&lt;/code&gt; 的問題，整理幾段我敲在 &lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/10215716222817975&quot;&gt;Facebook&lt;/a&gt; 上的隨筆&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/10215716222817975&quot;&gt;2021&amp;#x2F;06&amp;#x2F;25: 談探索自我&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.facebook.com/rick.kyhwang/posts/10211086815805693&quot;&gt;2019&amp;#x2F;04&amp;#x2F;21: 談退休&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;內容以職涯角度切入，談的是 &lt;code&gt;探索自己&lt;/code&gt;，然後延伸到 &lt;code&gt;生死&lt;/code&gt;、&lt;code&gt;退休&lt;/code&gt; … 等。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="Bus Memo" scheme="https://rickhw.github.io/tags/Bus-Memo/"/>
    
  </entry>
  
  <entry>
    <title>AWS Community Hero 2021</title>
    <link href="https://rickhw.github.io/2021/08/27/About/AWS-Community-Hero-2021/"/>
    <id>https://rickhw.github.io/2021/08/27/About/AWS-Community-Hero-2021/</id>
    <published>2021-08-27T04:39:00.000Z</published>
    <updated>2022-12-19T11:47:28.850Z</updated>
    
    <content type="html"><![CDATA[<p>很高興有機會被推薦成為 2021 年的 <a href="https://aws.amazon.com/developer/community/heroes/rick-hwang/">AWS Community Hero</a>。</p><p>感謝 AWS Leslie 的推薦，過程中 Kim 得協助，讓我有機會可以有這份榮耀。</p><p>底下是 AWS 官方公告，截圖作紀念：</p><p><a href="https://aws.amazon.com/blogs/aws/announcing-the-latest-aws-heroes-august-2021/">Announcing the latest AWS Heroes – August 2021</a></p><p><img src="/images/About/AWS-Hero/aws-news-blog.png"></p><p><img src="/images/About/AWS-Hero/AWS-Hero-2021.png"></p><p>過去幾年，沈浸在 AWS 的技術領域，我自己很享受學習 AWS 的過程，很多想法都在研究過程中激盪出來，最終把想法實際落地。</p><p>今年 (2021) 我開始有機會專注在新一代基礎架構設計，過去累積的經驗與想法、從學習 AWS 中累積的能量，有機會動手一一實踐。</p><span id="more"></span><hr><h1 id="相關資訊"><a href="#相關資訊" class="headerlink" title="相關資訊"></a>相關資訊</h1><ul><li><a href="https://aws.amazon.com/developer/community/heroes/rick-hwang/">AWS Community Hero 2021 - Rick Hwang</a></li><li><a href="https://aws.amazon.com/blogs/aws/announcing-the-latest-aws-heroes-august-2021/">Announcing the latest AWS Heroes – August 2021</a></li><li><a href="/2016/10/01/AWS-Study-Roadmap/">AWS Study Roadmap</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;很高興有機會被推薦成為 2021 年的 &lt;a href=&quot;https://aws.amazon.com/developer/community/heroes/rick-hwang/&quot;&gt;AWS Community Hero&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;感謝 AWS Leslie 的推薦，過程中 Kim 得協助，讓我有機會可以有這份榮耀。&lt;/p&gt;
&lt;p&gt;底下是 AWS 官方公告，截圖作紀念：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/blogs/aws/announcing-the-latest-aws-heroes-august-2021/&quot;&gt;Announcing the latest AWS Heroes – August 2021&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/About/AWS-Hero/aws-news-blog.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/About/AWS-Hero/AWS-Hero-2021.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;過去幾年，沈浸在 AWS 的技術領域，我自己很享受學習 AWS 的過程，很多想法都在研究過程中激盪出來，最終把想法實際落地。&lt;/p&gt;
&lt;p&gt;今年 (2021) 我開始有機會專注在新一代基礎架構設計，過去累積的經驗與想法、從學習 AWS 中累積的能量，有機會動手一一實踐。&lt;/p&gt;</summary>
    
    
    
    <category term="About" scheme="https://rickhw.github.io/categories/About/"/>
    
    
    <category term="AWS Hero" scheme="https://rickhw.github.io/tags/AWS-Hero/"/>
    
    <category term="AWS" scheme="https://rickhw.github.io/tags/AWS/"/>
    
  </entry>
  
</feed>
